\documentclass[]{report}
\title{\textbf{API on Rails}\\ Construction d'API REST avec Rails 5}
\author{Alexandre Rousseau}

\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{csquotes}
\usepackage{tcolorbox}
\usepackage{listings}
\usepackage{lstautogobble}
\usepackage{color}
\usepackage{xcolor}


\hbadness=99999
\hfuzz=999pt

\pagestyle{headings}

\definecolor{codeborder}{rgb}{0.9,0.9,0.9}

\hypersetup{
    colorlinks,
%     citecolor=black,
%     filecolor=black,
%     urlcolor=black
}
\lstset{
  % backgroundcolor = \color{lightgray},
  autogobble,% remove leading space indentation
  breaklines=true, % sets automatic line breaking
  % captionpos=b, % sets the caption-position to bottom
  frame=single, % adds a frame around the code
  showtabs=false, % show tabs within strings adding particular underscores
  tabsize=2, % sets default tabsize to 2 spaces
  rulecolor = \color{codeborder},
  keywordstyle=\bfseries\color{purple!40!black},
  commentstyle=\itshape\color{gray},
  % identifierstyle=\color{blue},
  % numberstyle=\tiny\color{green},
  stringstyle=\color{blue!40!black},
}

\begin{document}


\maketitle
\newpage
\tableofcontents
\newpage
\pagenumbering{arabic}

\section{Avant-propos}

  \textquote{API on Rails: Construction d'API REST avec Rails} est une mise à jour et une traduction française du livre \href{http://apionrails.icalialabs.com/book/}{\textquote{APIs on Rails: Building REST APIs with Rails}}. Celui-ci fut initialement publié en 2014 par \href{https://twitter.com/kurenn}{Abraham Kuri} sous les licences \href{http://opensource.org/licenses/MIT}{MIT} et \href{http://people.freebsd.org/~phk/}{Beerware}.

  \section{A propos de l'autheur original}

    \href{https://twitter.com/kurenn}{Abraham Kuri} est un développeur de Rails avec 5 ans d'expérience. Son expérience inclut le travail en tant que freelance dans la construction de produits logiciels et plus récemment dans la collaboration au sein de la communauté open source. Il a développé \href{http://icalialabs.github.io/furatto/}{Furatto} un cadre frontal construit avec Sass, \href{https://github.com/IcaliaLabs/sabisu-rails}{Sabisu} la prochaine génération d'explorateur d'API pour votre application Rails et a collaboré sur d'autres projets. Diplômé en informatique d'ITESM, il a fondé deux sociétés au Mexique (\href{http://icalialabs.com/}{Icalia Labs} et \href{http://codeandomexico.org/}{Codeando Mexico}).

  \section{Droits d'auteur et licence}

    Cette traduction est disponnible sous \href{http://opensource.org/licenses/MIT}{licence MIT}. Tout le code source de ce livre est disponnible au format \href{https://fr.wikipedia.org/wiki/LaTeX}{\LaTeX} sur \href{https://github.com/madeindjs/api_on_rails}{Github}

    \begin{tcolorbox}{The MIT License}
      Copyright (c) 2018 Alexandre Rousseau

      Permission est accordée, à titre gratuit, à toute personne obtenant une copie de ce logiciel et la documentation associée, pour faire des modification dans le logiciel sans restriction et sans limitation des droits d’utiliser, copier, modifier, fusionner, publier, distribuer, concéder sous licence, et / ou de vendre les copies du Logiciel, et à autoriser les personnes auxquelles le Logiciel est meublé de le faire, sous réserve des conditions suivantes:

      L’avis de copyright ci-dessus et cette autorisation doit être inclus dans toutes les copies ou parties substantielles du Logiciel.

      LE LOGICIEL EST FOURNI «TEL QUEL», SANS GARANTIE D’AUCUNE SORTE, EXPLICITE OU IMPLICITE, Y COMPRIS, MAIS SANS S’Y LIMITER, LES GARANTIES DE QUALITÉ MARCHANDE, ADAPTATION À UN USAGE PARTICULIER ET D’ABSENCE DE CONTREFAÇON. EN AUCUN CAS LES AUTEURS OU TITULAIRES DU ETRE TENU RESPONSABLE DE TOUT DOMMAGE, RÉCLAMATION OU AUTRES RESPONSABILITÉ, SOIT DANS UNE ACTION DE CONTRAT, UN TORT OU AUTRE, PROVENANT DE, DE OU EN RELATION AVEC LE LOGICIEL OU L’UTILISATION OU DE TRANSACTIONS AUTRES LE LOGICIEL.
    \end{tcolorbox}

    API on Rails de \href{https://github.com/madeindjs/api_on_rails}{Alexandre Rousseau} est mis à disposition selon les termes de la licence \href{http://creativecommons.org/licenses/by-sa/4.0/}{Creative Commons Attribution - Partage dans les Mêmes Conditions 4.0 International}.
    Fondé sur une œuvre à \url{http://apionrails.icalialabs.com/book/}.

\chapter{Introduction}\label{chapter:1}

  Bienvenue sur APIs on Rails, un tutoriel sous stéroïdes sur la façon de construire votre prochaine API avec Rails. Le but de ce livre est de vous fournir une méthodologie pour développer une API RESTful en suivant les meilleures pratiques existantes. Lorsque vous en aurez fini avec les API Rails, vous devriez être en mesure de créer votre propre API et de l'intégrer à n'importe quel client comme un navigateur Web ou votre une application mobile. Le code généré est construit sur Ruby on Rails 5 qui est la version actuelle, pour plus d'informations à ce sujet, consultez \href{http://rubyonrails.org/}{rubyonrails.org}. La version la plus récente de APIs on Rails se trouve sur \href{https://apionrails.icalialabs.com}{apionrails.icalialabs.com} ; n'oubliez pas de mettre à jour votre version hors ligne si c'est le cas.

  L'intention de ce livre n'est pas d'enseigner comment construire une API avec Rails, mais plutôt de vous apprendre comment construire une API évolutive et maintenable avec Rails. C'est-à-dire améliorer vos connaissances actuelles avec Rails. Dans ce voyage, vous allez apprendrez à:

  \begin{itemize}
    \item Construire des réponses JSON
    \item Utiliser Git pour le contrôle de version
    \item Test de vos points finaux
    \item Optimiser et mettre en cache l'API
  \end{itemize}

  Je vous recommande fortement de suivre toutes les étapes de ce livre. Essayez de ne pas sauter des chapitres car je vous donne des conseils et des faits intéressants pour améliorer vos compétences. Vous pouvez vous considérer comme le personnage principal d'un jeu vidéo qui obtient un niveau supérieur à chaque chapitre.

  Dans ce premier chapitre, je vous expliquerai comment configurer votre environnement (au cas où vous ne l'auriez pas déjà). Nous allons ensuite créer une application appelée \verb|market_place_api|. Je veillerai à vous enseigner les meilleures pratiques que j'ai pu apprendre au cours de mon experience. Cela signifie qu'après avoir initialisé le projet (Section 1.3), nous commencerons à utiliser Git (Section \ref{setup_git}).

  Dans les prochains chapitres, nous allons construire l'application en suivant un \textit{workflow} simple que j'utilise quotidiennement. Nous développerons toute l'application en utilisant le développement piloté par les tests (TDD). Je vous expliquerai l’intérêt d'utiliser une API pour votre prochain projet et de choisir un format de réponse adapté comme le JSON ou le XML. Du chapitre \ref{chapter:3} au chapitre \ref{chapter:8}, nous mettrons les mains dans le code et nous compléterons les bases de l'application en construisant tous les points finaux nécessaires. Nous sécuriserons l'accès à l'API et en gérant l'authentification par échange d'en-têtes HTTP. Enfin, dans le dernier chapitre (Chapitre \ref{chapter:11}), nous ajouterons quelques techniques d'optimisation pour améliorer les temps de réponse du serveur.

  L'application finale sera une foncation pour une application de place de marché où les utilisateurs seront en mesure de passer des commandes, télécharger des produits et plus encore. Il existe de nombreuses options pour créer une boutique en ligne comme \href{http://shopify.com/}{Shopify}, \href{http://spreecommerce.com/}{Spree} ou \href{http://magento.com/}{Magento}.

  À la fin ou au cours du processus (cela dépend vraiment de votre expertise), vous allez vous améliorer et être en mesure de mieux comprendre certaines des meilleures ressources Rails. J'ai aussi pris certaines des pratiques que j'ai trouvé sur ces sites:

  \begin{itemize}
    \item \href{http://railscasts.com/}{Railscasts}
    \item \href{http://codeschool.com/}{CodeSchool}
    \item \href{http://jsonapi.org/format/}{JSON API}
  \end{itemize}

  \section{Conventions sur ce livre}

    Les conventions de ce livre sont basées sur celles du Tutoriel Ruby on Rails. Dans cette section, j'en mentionnerai quelques-unes qui ne sont peut-être pas aussi claires.

    Je vais utiliser de nombreux exemples en utilisant des ligne de commande. Je ne vais pas traiter avec Windows \verb|cmd| (désolé les gars). Je vais baser tous les exemples en utilisant l'invite de ligne de commande de style Unix. Voici un exemple:

    \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ echo "A command-line command"
    A command-line command
    \end{lstlisting}
    \end{scriptsize}

    J'utiliserai quelques principes spécifiques à Ruby. C'est-à-dire:

    \begin{itemize}
      \item \textquote{Éviter} signifie que tu n'es pas censé le faire.
      \item \textquote{Préférer} indique que parmi les 2 options, la première est la plus appropriée.
      \item \textquote{Utiliser} signifie que vous êtes en mesure d'utiliser la ressource.
    \end{itemize}

    Si vous rencontrez une erreur quelconque lors de l'execution d'une commande, je vous recommande d'utiliser un moteur de recherche pour trouvez votre solution. Malheuresement, je ne peux pas couvrir tous les erreurs possibles. Si vous avez envie de prendre une bière ou si vous rencontrez des problèmes avec ce tutoriel, vous pouvez toujours \href{http://twitter.com/kurenn}{me tweeter} ou \href{mailto:contact@rousseau-alexandre.fr}{m'envoyer un email}.

  \section{Pour commencer}

    Pour presque tous les développeurs, l'une des parties les plus douloureuses est de mettre en place un environnement de développement comfortable. Si vous le faites correctement, les prochaines étapes devraient être un jeu d'enfant. Afin de vous faciliter la tâche et de vous motiver, nous utiliserons un script bash que je maintiens appelé Kaishi\footnote{Kaishi ne fonctionne actuellement que pour Mac OS}. il inclut tous les outils nécessaires (encadré \ref{box:kaishi_tools}) et plus encore pour configurer votre environnement de développement.

    \begin{tcolorbox}{Outils de développement Kaishi}\label{box:kaishi_tools}
      \begin{itemize}
        \item \href{https://github.com/robbyrussell/oh-my-zsh}{oh-my-zsh}  en tant que Shell par défault
        \item \href{http://brew.sh/}{Homebrew} pour la gestion des paquets
        \item \href{http://git-scm.com/}{Git} en tant que gestionnaire de base de données
        \item \href{http://www.postgresql.org/}{Postresql} en tant que gestionnaire de base de données
        \item \href{http://www.vim.org/}{Vim} pour l'édition de texte
        \item \href{http://www.imagemagick.org/}{ImageMagick} pour le traitement d'images
        \item \href{https://github.com/sstephenson/rbenv}{Rbenv} pour la gestion de l'environnement rubis
        \item \href{http://bundler.io/}{Bundler}
        \item \href{https://github.com/ddollar/foreman}{Foreman} pour l'exécution d'applications
        \item \href{http://rubyonrails.org/}{Rails} pour la création de n'importe quelle application rails
        \item \href{https://toolbelt.heroku.com/}{Heroku} pour interagir avec l'API Heroku
        \item \href{https://github.com/IcaliaLabs/railsAppCustomGenerator}{RailsAppCustomGenerator} pour initialiser n'importe quelle application Rails avec le modèle d'Icalia
        \item \href{http://pow.cx/}{Pow} pour exécuter des applications locales en local comme un super-héros
      \end{itemize}
    \end{tcolorbox}

  \section{Environnements de développement}

    \subsection{Editeurs de texte et Terminal}

      Il existe de nombreux cas dans lesquels les environnements de développement peuvent différer d'un ordinateur à l'autre. Ce n'est pas le cas avec les éditeurs de texte. Je pense que pour le développement avec Rails, un IDE est beaucoup trop lourd (d'autres pourraient trouver que c'est la meilleure façon de travailler\footnote{Si c'est votre cas, je vous recommande d'essayer avec \href{http://www.aptana.com/products/radrails}{RadRails} ou \href{http://www.jetbrains.com/ruby/index.html}{RubyMine}, les deux sont bien soutenus et possèdent de nombreuses intégrations par défault.}).

      Maintenant pour ceux qui sont comme moi, je peux vous dire qu'il y a beaucoup d'options disponibles que vous pouvez personnaliser via des plugins et plus.

      \begin{description}
        \item[Editeur de texte] J'utilise personnellement \href{http://www.vim.org/}{Vim} comme éditeur par défaut avec \href{https://github.com/carlhuda/janus}{Janus} qui ajoute et gère plusieurs des plugins que vous allez probablement utiliser. Au cas où vous n'êtes pas un fan de Vim comme moi, il y a beaucoup d'autres solutions comme \href{http://www.sublimetext.com/}{Sublime Text} qui est une multiplateforme facile à apprendre et à personnaliser (c'est probablement votre meilleure option), il est fortement inspiré par \href{http://macromates.com/}{TextMate}\footnote{disponible uniquement pour Mac OS}. Une troisième option est d'utiliser un éditeur de texte plus récent des gars de \href{http://gitub.com/}{Github} appelé \href{https://atom.io/}{Atom}, c'est un éditeur de texte prometteur fait en Javascript. Il est facile à personnaliser pour répondre à vos besoins, faites un essai. N'importe lequel des éditeurs que je vous présente fera le travail, donc je vous laisserai décider lequel vous convient.

        \item[Terminal] Si vous avez décidé d'utiliser \href{http://icalialabs.github.io/kaishi/}{kaishi} pour paramétrer l'environnement, vous remarquerez qu'il définit le shell par défaut à \verb|zsh|, ce que je recommande vivement. Pour le terminal, je ne suis pas un fan de l'application Terminal par défault sous Mac OS. Je recommande \href{http://www.iterm2.com/#/section/home}{iTerm2}, qui est un remplacement de terminal pour Mac OS. Si vous êtes sous Linux, vous avez probablement déjà un beau terminal, mais le défaut devrait fonctionner très bien.
      \end{description}

    \subsection{Navigateur web}

      Quand il s'agit de navigateurs, je conseillerai directement \href{http://www.mozilla.org/en-US/firefox/new/}{Firefox}. Mais d'autres développeurs utilisent \href{https://www.google.com/intl/en/chrome/browser/}{Chrome} ou même \href{https://www.apple.com/safari/}{Safari}. N'importe lequel d'entre eux vous aidera à construire l'application que vous voulez. Ils porposent tous un bon inspecteur pour le DOM, un analyseur de réseau et de nombreuses autres fonctionnalités que vous connaissez peut-être déjà.

    \subsection{Note sur les outils}

      Vous ne voudrez peut-être pas inclure tous les paquets qui viennent avec \href{http://icalialabs.github.io/kaishi/}{kaishi} et je vous comprends. Peut-être que vous avez déjà quelques outils installés. Je vais vous décrire comment installer seulment ce dont vous avez besoin pour commencer.

    \subsection{Gestionnaire de paquets}

      \begin{description}
        \item[Mac OS] Il existe de nombreuses options pour gérer la façon dont vous installez les paquets sur votre Mac, comme \href{https://www.macports.org/}{Mac Ports} ou \href{http://brew.sh/}{Homebrew}. Les deux sont de bonnes options, mais je choisirais la dernière. J'ai rencontré moins de problèmes lors de l'installation de logiciels avec Homebrew. Pour installer \verb|brew| il suffit d'exécuter la commande ci-dessous:
        \begin{scriptsize}
          \begin{lstlisting}[language=bash]
          $ ruby -e "$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)"
          \end{lstlisting}
        \end{scriptsize}
        \item[Linux], vous êtes quasiment prêts! Peu importe si vous utilisez \verb|apt|, \verb|pacman|, \verb|yum| tant que vous vous sentez à l'aise et que vous savez comment installer des paquets.
      \end{description}

    \subsection{Git}
      \label{setup_git}

      Nous utiliserons beaucoup Git et vous devriez aussi l'utiliser (non seulement pour le but de ce tutoriel mais pour tout vos projet).

      Instalation de Git sous Mac OS:
      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ brew install git
        \end{lstlisting}
      \end{scriptsize}

      Instalation de Git sous Linux:
      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ sudo apt-get install git
        \end{lstlisting}
      \end{scriptsize}

    \subsection{Ruby}

      Il existe de nombreuseuses façons d'installer et de gérer Ruby. Vous devriez probablement déjà avoir une version installée sur votre système. Pour connaître votre version, tapez simplement:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ ruby -v
        \end{lstlisting}
      \end{scriptsize}

      Rails 5 nécessite l'installation de la version 2.2.2 ou supérieure. Pour l'installer, je vous recommande d'utiliser \href{http://rvm.io/}{Ruby Version Manager (RVM)} ou \href{http://rbenv.org/}{rbenv}. Ces outils vous permettrons d'installer plusieurs versions de \verb|ruby|. J'ai récemment changé de RVM à rbenv mais peu importe laquelle de ces deux options que vous utiliserez. Dans ce tutoriel, nous allons utiliser rbenv\footnote{Note pour Mac OS: si vous utilisez Mac, n'oubliez pas que vous devez avoir installé les \href{https://developer.apple.com/downloads/}{outils en ligne de commande pour Xcode}.}

      \subsubsection{Mac OS}

        Pour commencer l'installation de ruby, tapez:

        \begin{scriptsize}
          \begin{lstlisting}[language=bash]
          $ rbenv install 2.1.2
          \end{lstlisting}
        \end{scriptsize}

        Ensuite, vous devez configurer la version de ruby qui vient d'être installée comme version par défaut:

        \begin{scriptsize}
          \begin{lstlisting}[language=bash]
          $ rbenv global 2.1.2
          $ rbenv rehash
          \end{lstlisting}
        \end{scriptsize}

        La commande \verb|rehash| est supposée s'exécuter à chaque fois que vous installez une nouvelle version de Ruby ou une Gem. Pour plus d'informations sur la personnalisation ou d'autres types d'installation, consultez la \href{https://github.com/sstephenson/rbenv}{documentation du projet}.

      \subsubsection{Linux}

        La première étape est de configurer quelques dépendances pour Ruby:

        \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ sudo apt-get update
        $ sudo apt-get install git-core curl zlib1g-dev build-essential libssl-dev \
                            libreadline-dev libyaml-dev libsqlite3-dev sqlite3 \
                            libxml2-dev libxslt1-dev libcurl4-openssl-dev zlib1g-dev \
                            python-software-properties
        \end{lstlisting}
        \end{scriptsize}

        Ensuite, vouss pouvez installer la dernière version de Ruby:

        \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ cd
        $ git clone git://github.com/sstephenson/rbenv.git .rbenv
        $ echo 'export PATH="$HOME/.rbenv/bin:$PATH"' >> ~/.bash_profile
        $ echo 'eval "$(rbenv init -)"' >> ~/.bash_profile

        $ git clone git://github.com/sstephenson/ruby-build.git ~/.rbenv/plugins/ruby-build
        $ echo 'export PATH="$HOME/.rbenv/plugins/ruby-build/bin:$PATH"' >> ~/.bash_profile
        $ source ~/.bash_profile

        $ rbenv install 2.5.3
        $ rbenv global 2.5.3
        \end{lstlisting}
        \end{scriptsize}

        Si tout s'est bien passé, il est temps d'installer le reste des dépendances que nous allons utiliser.

      \subsubsection{Gems, Rails et bibliothèques manquantes}

        Tout d'abord, nous mettons à jour les Gems sur l'ensemble du système:

        \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ gem update --system
        \end{lstlisting}
        \end{scriptsize}

        Dans la plupart des cas, si vous êtes sous Mac OS, vous devriez installer des bibliothèques supplémentaires:

        \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ brew install libtool libxslt libksba openssl
        \end{lstlisting}
        \end{scriptsize}

        Nous installons ensuite les gems nécessaires et ignorons la documentation pour chaque gemme:

        \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ printf 'gem: --no-document' >> ~/.gemrc
        $ gem install bundler
        $ gem install foreman
        $ gem install rails -v 5.2
        \end{lstlisting}
        \end{scriptsize}

        Vérifiez que tout fonctionne bien:

        \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ rails -v 5.2
        5.2.0
        \end{lstlisting}
        \end{scriptsize}

      \subsubsection{Bases de données}

        Je vous recommande fortement d'installer \href{http://www.postgresql.org/}{Postgresql} pour gérer vos bases de données. Mais ici, plus de simplicité, nous allons utiliser \href{http://www.sqlite.org/}{SQlite}. Si vous utilisez Mac OS vous n'avez pas de bibliothèques supplémentaire à installer. Si vous êtes sous Linux, ne vous inquiétez pas, je vous guide:

        \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ sudo apt-get install libxslt-dev libxml2-dev libsqlite3-dev
        \end{lstlisting}
        \end{scriptsize}

        ou

        \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ sudo yum install libxslt-devel libxml2-devel libsqlite3-devel
        \end{lstlisting}
        \end{scriptsize}

  \section{Initialisation du projet}

    Vous devez sans doute déjà savoir comment initialiser une application Rails. Si ce n'est pas le cas, jettez un coup d'oeuil au listing \ref{rails_new}.

    Sachez que nous utiliserons \href{http://rspec.info/}{Rspec} comme suite de test. Assurez-vous d'inclure l'option \verb|-T| lors de la création de l'application.

    \begin{scriptsize}
    \begin{lstlisting}[language=bash, caption={Initialisation du projet avec 'rails new'.}, label={rails_new}]
    $ mkdir ~/workspace
    $ cd workspace
    $ rails new market_place_api -T
    \end{lstlisting}
    \end{scriptsize}

    Comme vous pouvez le deviner, les commandes ci-dessus (Listing \ref{rails_new}) génèreront les éléments indispensables à votre application Rails. La prochaine étape est d'ajouter quelques gems que nous utiliserons pour construire l'API.

    \subsection{Installer Pow ou Prax}\label{subsection:install_pow}

      Vous pouvez vous demander \textquote{pourquoi diable voudrais-je installer ce type de paquet?}. La réponse est simple. Nous allons travailler avec des \href{http://en.wikipedia.org/wiki/Subdomain}{sous-domaines}. \href{http://pow.cx/}{Pow} et \href{https://github.com/ysbaddaden/prax.cr}{Prax} vont nous aider a les créer très facilement.

      \subsubsection{Installer Pow}

        Pow ne fonctionne que sous Mac OS. Ne vous inquiétez pas, il existe une alternative qui imite les fonctionnalités sous Linux (Section \ref{subsubsect:prax}). Pour l'installer, tapez simplement:

        \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ curl get.pow.cx | sh
        \end{lstlisting}
        \end{scriptsize}

        Et c'est tout ce que vous avez à faire. Il suffit d'établir un lien symbolique avec l'application pour configurer l'application Rack.

        D'abord vous allez dans le répertoire \verb|~/.pow|:

        \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ cd ~/.pow
        \end{lstlisting}
        \end{scriptsize}

        Ensuite, vous pouvez créer le \href{http://en.wikipedia.org/wiki/Symbolic_link}{lien symbolique}

        \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ ln -s ~/workspace/market_place_api
        \end{lstlisting}
        \end{scriptsize}

        N'oubliez pas de changer le répertoire utilisateur pour celui qui correspond au votre. Vous pouvez maintenant accéder à l'application via \href{http://market_place_api.dev/}{http://market\_place\_api.dev}. Votre application devrait être en cours d'exécution comme celle illustrée à la Figure \ref{rails_new}.

      \subsubsection{Installer Prax}\label{subsubsect:prax}

        Pour les utilisateurs de Linux uniquement, \href{https://github.com/ysbaddaden/prax.cr}{Prax} distribue des paquets déjà compilé pour les distributions Debian / Ubuntu. Il suffit donc de télécharger le paquet \verb|.deb| et de l'installer avec \verb|dpkg|.

        \begin{scriptsize}
        \begin{lstlisting}[language=bash, breaklines]
        $ cd /tmp
        $ wget https://github.com/ysbaddaden/prax.cr/releases/download/v0.8.0/prax_0.8.0-1_amd64.deb
        $ sudo dpkg -i prax_0.8.0-1_amd64.deb
        \end{lstlisting}
        \end{scriptsize}

        Ensuite, il ne nous reste plus qu'à lier les applications:

        \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ cd ~/workspace/market_place_api
        $ prax link
        \end{lstlisting}
        \end{scriptsize}

        Si vous voulez démarrer le prax server automatiquement, ajoutez cette ligne au fichier \verb|.profile|:

        \begin{scriptsize}
        \begin{lstlisting}
        prax start
        \end{lstlisting}
        \end{scriptsize}

        Lors de l'utilisation de \href{https://github.com/ysbaddaden/prax.cr}{Prax}, vous devez spécifier le port de l'URL, dans ce cas-ci: \href{http://market_place_api.dev:3000/}{http://market\_place\_api.dev:3000}:

        Vous devriez voir l'application en marche, voir Figure \ref{fig:pow_running}.

        \begin{figure}
          \includegraphics[width=\linewidth]{img/pow_running.png}
          \caption{http://market\_place\_api.dev/}
          \label{fig:pow_running}
        \end{figure}

        Une fois l'application Rails créée, l'étape suivante consiste à ajouter une Gem simple mais très puissante pour sérialiser les ressources que nous allons exposer sur l'API. La Gem s'appelle \verb|active_model_serializers|. C'est un excellent choix pour la construction de ce type d'application car la librairie est bien entretenu et la \href{https://github.com/rails-api/active_model_serializers}{documentation} est incroyable.

        Votre \verb|Gemfile| devrait donc ressembler à ceci (Listing \ref{listing:gemfile_active _model_serializers}) après avoir ajouté la gemme \verb|active _model_serializers|:


        \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Le Gemfile par défaut avec la Gem des sérialiseurs.}, label={listing:gemfile_active _model_serializers}, breaklines]
        # Gemfile
        source 'https://rubygems.org'
        git_source(:github) { |repo| "https://github.com/#{repo}.git" }

        ruby '2.5.3'

        # Bundle edge Rails instead: gem 'rails', github: 'rails/rails'
        gem 'rails', '~> 5.2.0'
        # Use sqlite3 as the database for Active Record
        gem 'sqlite3'
        # Use Puma as the app server
        gem 'puma', '~> 3.11'
        # Use SCSS for stylesheets
        gem 'sass-rails', '~> 5.0'
        # Use Uglifier as compressor for JavaScript assets
        gem 'uglifier', '>= 1.3.0'

        # Api gems
        gem 'active_model_serializers'

        # ...
        \end{lstlisting}
        \end{scriptsize}

        Notez que j'enlève les gemmes \verb|jbuilder| et \verb|turbolinks| et \verb|coffee-rails| car nous n'allons pas les utiliser.

        C'est une bonne pratique aussi d'inclure la version Ruby utilisée sur l'ensemble du projet, ce qui empêche les dépendances de casser si le code est partagé entre différents développeurs, que ce soit pour un projet privé ou public.

        Il est également important que vous mettiez à jour le Gemfile pour regrouper les différentes gemmes dans l'environnement correct (Listing \ref{lst:gemfile_active _group}) :

        \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Le Gemfile mis à jour pour différents groupes.}, label={lst:gemfile_active _group}]
        # Gemfile
        # ...
        group :development do
          gem 'sqlite3'
        end
        # ...
        \end{lstlisting}
        \end{scriptsize}

        Ceci, comme vous vous en souvenez peut-être, empêchera l'installation ou l'utilisation de sqlite lorsque vous déployez votre application chez un fournisseur de serveurs comme Heroku\footnote{En raison de la structure de l'application, nous n'allons déployer l'application sur aucun serveur, mais nous allons utiliser \href{http://pow.cx/}{Pow} de \href{https://basecamp.com/}{Basecamp}. Si vous utilisez Linux, il existe une solution similaire appelée \href{https://github.com/ysbaddaden/prax.cr}{Prax} par \href{https://github.com/ysbaddaden}{ysbaddaden}. Voir la section \ref{subsection:install_pow}}.

        \begin{displayquote}
          Pow est un serveur Rack zéro-configuration pour Mac OS X. Servez vos applications localement en moins d'une minute. - \href{https://basecamp.com/}{Basecamp}
        \end{displayquote}

        Une fois cette configuration configurée, il est temps d'exécuter la commande d'installation du paquet pour intégrer les dépendances correspondantes:

        \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ bundle install
        \end{lstlisting}
        \end{scriptsize}

        Une fois que la commande a terminé son exécution, il est temps de commencer à suivre le projet avec git (Section \ref{section:git})

  \section{Contrôle de version}\label{section:git}

    Rappelez-vous que Git vous aide à suivre et à maintenir l'historique de votre code. Gardez à l'esprit que le code source de l'application est publié sur Github. Vous pouvez suivre le référentiel sur \href{https://github.com/madeindjs/market_place_api}{github.com/madeindjs/market\_place\_api}

    À ce stade, je suppose que vous avez déjà configuré git et que vous êtes prêt à l'utiliser pour suivre le projet. Si ce n'est pas votre cas, suivez les étapes de première installation (Listing \ref{lst:setup_git}):

    \begin{scriptsize}
    \begin{lstlisting}[language=bash, label={lst:setup_git}]
    $ git config --global user.name "Type in your name"
    $ git config --global user.email "Type in your email"
    $ git config --global core.editor "vim"
    \end{lstlisting}
    \end{scriptsize}

    Il est donc temps d'initier le projet avec Git. N'oubliez pas de naviguer dans le répertoire racine de l'application \verb|market_place_api|:

    \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ git init
    Initialized empty Git repository in ~/workspace/market_place_api/.git/
    \end{lstlisting}
    \end{scriptsize}

    L'étape suivante est d'ignorer certains fichiers que nous ne voulons pas suivre. Votre fichier \verb|.gitignore| devrait ressembler à celui montré ci-dessous (Listing \ref{lstlisting:gitignore}):

    \begin{scriptsize}
    \begin{lstlisting}[breaklines, caption={La version modifiée du fichier .gitignore}, label={lstlisting:gitignore}]
    # Ignore bundler config.
    /.bundle

    # Ignore the default SQLite database.
    /db/*.sqlite3
    /db/*.sqlite3-journal

    # Ignore all logfiles and tempfiles.
    /log/*
    /tmp/*
    !/log/.keep
    !/tmp/.keep

    # Ignore uploaded files in development
    /storage/*

    /node_modules
    /yarn-error.log

    /public/assets
    .byebug_history

    # Ignore master key for decrypting credentials and more.
    /config/master.key
    \end{lstlisting}
    \end{scriptsize}

    Après avoir modifié le fichier \verb|.gitignore|, il suffit d'ajouter les fichiers et de valider les modifications. Les commandes nécessaires sont indiquées ci-dessous:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ git add .
      $ git commit -m "Initial commit"
      \end{lstlisting}
    \end{scriptsize}

    Bonne pratique : J'ai appris que commencer un message par un verbe au présent décrit ce que fait le commit et non ce qu'il a fait. De cette façon il est plus facile de lire et de comprendre l'histoirique du projet (ou du moins pour moi). Je vais suivre cette pratique jusqu'à la fin du tutoriel.

    Enfin, et c'est une étape optionnelle, nous installons le projet github (je ne vais pas l'expliquer ici) et poussons notre code vers le serveur distant:

    On ajoute d'abord le serveur distant:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ git remote add origin git@github.com:madeindjs/market_place_api.git
      \end{lstlisting}
    \end{scriptsize}

    ensuite:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ git push -u origin master
      \end{lstlisting}
    \end{scriptsize}

    Au fur et à mesure que nous avançons dans le tutoriel, j'utiliserai les pratiques que j'utilise quotidiennement. Cela inclut le travail avec les branches, le rebasage, le squash et bien d'autres. Vous n'avez pas à vous inquiéter si vous ne connaissez pas tous ces termes: Je les expliquerai le temps venu.

  \section{Conclusion}

    Cela a été un chapitre assez long. Si vous êtes arrivé ici, permettez-moi de vous féliciter. Les choses vont s'améliorer à partir de ce point. Commençons à mettre les mains dans le code!

\chapter{L'API}\label{chapter:2}

  Dans ce chapitre, je vais vous donner les grandes lignes de l'application. Vous devriez avoir lu le chapitre précedent. Si ce n'est pas le cas, je vous recommande de le faire.

  Vous pouvez cloner le projet jusqu'ici avec :

  \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ git clone https://github.com/madeindjs/market_place_api
    $ cd market_place_api
    $ git checkout -b chapter1 b98a9a7a328017640482af95beebc1d6e612e0ac
    \end{lstlisting}
  \end{scriptsize}

  Pour résumer, nous avons mis à jour le Gemfile pour ajouter la Gem \verb|active_model_serializers| (Listing \ref{listing:gemfile_active _model_serializers}).

  \section{Planification de l'application}

    Notre application sera assez simple, elle se composera de 5 modèles (Figure \ref{fig:data_model}). Ne vous inquiétez pas si vous ne comprenez pas bien ce qui se passe, nous reverrons et développerons chacune de ces ressources au fur et à mesure que nous avancerons avec le tutoriel.

    \begin{figure}
      \includegraphics[width=\linewidth]{img/data_model.png}
      \caption{Schéma des liaisons entre les différent modèles}
      \label{fig:data_model}
    \end{figure}

    En bref, nous avons l'utilisateur (\verb|User|) qui sera en mesure de passer de nombreuses commandes (\verb|Order|), télécharger de multiples produits (\verb|product|) qui peuvent avoir de nombreuses images (\verb|Image|) ou commentaires (\verb|Comment|) d'autres utilisateurs sur l'application.

    Nous n'allons pas construire d'interface pour l'interaction avec l'API afin de ne pas surcharger le tutoriel.  Si vous voulez construire des vues, il existe de nombreuses options comme des frameworks javascript (\href{https://angularjs.org/}{Angular}, \href{https://vuejs.org/}{Vue.JS}, \href{https://reactjs.org/}{React}) ou des librairies mobile (\href{https://github.com/AFNetworking/AFNetworking}{AFNetworking}).

    À ce stade, vous devez vous poser la question \textquote{d'accord, mais j'ai besoin d'explorer et de visualiser l'API que nous allons construire}, et c'est juste. Si vous googlez quelque chose lié à l'exploration d'une API, vous allez sûremment entendre parler de \href{https://www.getpostman.com/}{Postman}. C'est un excellent complément si vous utilisez chrome, mais nous ne l'utiliserons pas de toute façon, car probablement pas tous les développeurs utilisent le navigateur Google. Au lieu de cela, nous utiliserons une gemme que j'ai construite appelée  qui est un puissant client de moteur de type facteur pour explorer votre application Rails api's. Nous traiterons de l'intégration des pierres précieuses à la section 3.3.
    % TODO keep it?

  \section{Mettre en place l'API}\label{section:setup_api}

    Une API est définie par \href{https://fr.wikipedia.org/wiki/Interface_de_programmation}{wikipedia} comme une interface de programmation d'application (API) qui  est un ensemble normalisé de composants qui sert de façade par laquelle un logiciel offre des services à d'autres logiciels. En d'autres termes, il s'agit d'une façon dont les systèmes interagissent les uns avec les autres via une interface (dans notre cas un service web construit avec JSON)\footnote{Il existe d'autres types de protocoles de communication comme SOAP, mais nous n'en parlons pas ici.}.

    JSON est devenu incontournable en tant sur média Internet en raison de sa lisibilité, de son extensibilité et sa facilité à mettre en œuvre. Beaucoup de frameworks Javascript l'utilisent comme protocole par défault comme \href{https://angularjs.org/}{Angular} ou \href{http://emberjs.com/}{EmberJS}. D'autres grandes bibliothèques en Objective-C l'utilisent  comme \href{https://github.com/AFNetworking/AFNetworking}{AFNetworking} ou \href{http://restkit.org/}{RESTKit}. Il existe probablement de bonnes solutions pour Android, mais en raison de mon manque d'expérience sur cette plate-forme de développement je ne suis peut-être pas la bonne personne pour vous recommander quelque chose.

    Très bien, donc nous allons construire notre API avec JSON. La première chose qui pourrait vous venir à l'esprit serait de commencer à créer des routes en vrac. Le problème est qu'elles ne seraient pas normalisées. Un utilisateur ne pourrait pas deviner qu'elle ressource est renvoyée par une route.

    C'est pourquoi une norme existe: REST \textit{(Representational State Transfer)}. REST impose une norme pour les routes qui crée, lise, mette à jour ou supprime des informations sur un serveur en utilisant de simples appels HTTP. C'est une alternative aux mécanismes plus complexes comme SOAP(Listing \ref{lst:soap_example}), CORBA et RPC. Un appel REST est simplement une requête GET HTTP vers le serveur.

    \begin{scriptsize}
      \begin{lstlisting}[label={lst:soap_example}, caption={Un exemple d'appel SOAP}]
      aService.getUser("1")
      \end{lstlisting}
    \end{scriptsize}

    Et avec REST, vous pouvez appeler une URL avec une requête HTTP spécifique. Dans ce cas avec une requête GET (Listing \ref{lst:rest_example}):

    \begin{scriptsize}
    \begin{lstlisting}[label={lst:rest_example}, caption={Un exemple d'appel REST}]
    http://domain.com/resources_name/uri_pattern
    \end{lstlisting}
    \end{scriptsize}

    Les API RESTful doivent suivre aux minimum trois règles:

    \begin{itemize}
      \item Une URI de base comme \href{http://example.com/resources/}{http://example.com/resources/}
      \item Un type de média Internet pour représenter les données, il est communément JSON et est communément défini par l'échange d'en-têtes.
      \item Suivez les méthodes \href{https://fr.wikipedia.org/wiki/Hypertext_Transfer_Protocol}{HTTP} standard telles que GET, POST, PUT, PUT, DELETE.
    \end{itemize}

    \begin{description}\label{desc:http_verbs}
      \item[GET] Lit la ou les ressources définies par le modèle URI
      \item[POST] Crée une nouvelle entrée dans la collection de ressources
      \item[PUT] Mise à jour d'une collection ou d'un membre des ressources
      \item[DELETE] Détruit une collection ou un membre des ressources
    \end{description}

    Cela n'est peut-être pas assez clair ou peut sembler compliqué. Mais à mesure que nous avancerons dans le tutoriel, cela deviendra beaucoup plus facile à comprendre.

    \subsection{Routes, Constraints and Namespaces}\label{subsec:routes_constraints_namespaces}

      Avant de commencer à taper du code, nous allons préparer le répertoire Git. Le \textit{workflow} que nous allons suivre est le suivant:

      \begin{itemize}
        \item Nous allons créer une branche par chapitre
        \item Une fois terminé, nous le pousserons la branche sur github
        \item Nous la fusionnerons avec master
      \end{itemize}

      Commençons donc par ouvrir le terminal dans le répertoire \verb|market_place_api| et tapez la commande suivante pour créer la branche:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ git checkout -b setting-api
        Switched to a new branch 'setting-api'
        \end{lstlisting}
      \end{scriptsize}

      Nous allons seulement travailler sur le fichier \verb|config/routes.rb| (Listing \ref{lst:default_routes}), car nous allons simplement définir les contraintes et le format de réponse par défaut pour chaque requête.

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Le fichier routes.rb par défault}, label={lst:default_routes}]
        # config/routes.rb
        Rails.application.routes.draw do
          # ...
        end
        \end{lstlisting}
      \end{scriptsize}

      Effacez tout le code commenté qui se trouve dans le fichier. Nous n'en aurons pas besoin. Ensuite, faites un \verb|commit|, juste pour s'échauffer:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ git add config/routes.rb
        $ git commit -m "Removes comments from the routes file"
        \end{lstlisting}
      \end{scriptsize}

      Nous allons isoler les contrôleurs API dans des \verb|Namespace|. Avec Rails, c'est assez simple. Il suffit de créer un dossier sous \verb|app/controllers| nommé \verb|api|. Le nom est important car c'est le \verb|Namespace| que nous allons utiliser pour gérer les contrôleurs pour les points d'entrée de l'API (Listing \ref{lst:mkdir_controllers_api})

      \begin{scriptsize}
      \begin{lstlisting}[language=bash, caption={Commande pour créer le dossier controllers/api}, label={lst:mkdir_controllers_api}]
      $ mkdir app/controllers/api
      \end{lstlisting}
      \end{scriptsize}

      Nous ajoutons ensuite ce \verb|Namespace| dans notre fichier \verb|routes.rb| (Listing \ref{lst:routes_create_namespace}):

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Création d'un Namespace}, label={lst:routes_create_namespace}]
        # config/routes.rb
        Rails.application.routes.draw do
          # Api definition
          namespace :api do
            # We are going to list our resources here
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      En définissant un \verb|Namespace| dans le fichier \verb|routes.rb|, Rails mappera automatiquement ce \verb|Namespace| à un répertoire correspondant au nom sous le dossier controllers (dans notre cas le répertoire \verb|api/|).

      Rails supporte jusqu'à 35 types de médias différents, vous pouvez les lister en accédant à la classe \verb|SET| sous le module de \verb|Mime|:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ rails c
        Loading development environment (Rails 5.2.1)
        irb(main):001:0> Mime::SET.collect(&:to_s)
        => ["text/html", "text/plain", "text/javascript", "text/css", "text/calendar", "text/csv", "text/vcard", "text/vtt", "image/png", "image/jpeg", "image/gif", "image/bmp", "image/tiff", "image/svg+xml", "video/mpeg", "audio/mpeg", "audio/ogg", "audio/aac", "video/webm", "video/mp4", "font/otf", "font/ttf", "font/woff", "font/woff2", "application/xml", "application/rss+xml", "application/atom+xml", "application/x-yaml", "multipart/form-data", "application/x-www-form-urlencoded", "application/json", "application/pdf", "application/zip", "application/gzip", "application/vnd.web-console.v2"]
        \end{lstlisting}
      \end{scriptsize}

      C'est important parce que nous allons travailler avec JSON, l'un des types MIME intégrés par Rails. Ainsi nous avons juste besoin de spécifier ce format comme format par défaut (Listing \ref{lst:routes_create_namespace_with_format}) :

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Création d'un Namespace avec un format par défault}, label={lst:routes_create_namespace_with_format}]
        # config/routes.rb
        Rails.application.routes.draw do
          # Api definition
          namespace :api, defaults: { format: :json }  do
            # We are going to list our resources here
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      Jusqu'à présent, nous n'avons rien fait de compliqué. Nous voulons maintenant générer une \verb|base_uri| sous un sous-domaine. C'est-à-dire quelque chose comme \verb|api.market_place_api.dev|. Définir l'API sous un sous-domaine est une bonne pratique car cela permet d'adapter l'application à un niveau DNS. Alors, comment y parvenir? (Listing \ref{lst:routes_create_namespace_with_subdomain})

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Création d'un Namespace avec un format par défault}, label={lst:routes_create_namespace_with_subdomain}]
        # config/routes.rb
        Rails.application.routes.draw do
          # Api definition
          namespace :api, defaults: { format: :json }, constraints: { subdomain: 'api' }, path: '/'  do
            # We are going to list our resources here
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      Vous voyez la différence? Nous n'avons pas seulement ajouté un \verb|Hash| de contraintes pour spécifier le sous-domaine, nous avons aussi ajouté l'option chemin d'accès et lui avons donné un \textit{backslash}. Cel indique à Rails que le chemin de départ pour chaque requête est la racine par rapport au sous-domaine (Encadré \ref{box:setup_api}).

      \begin{tcolorbox}{Les conventions des API}\label{box:setup_api}
        Vous pouvez trouver de nombreuses approches pour configurer la \verb|base_uri| d'une API. En supposant que nous versionnont notre api (Section \ref{section:api_versioning}):

        \begin{description}
          \item[api.example.com/] Je suis d'avis que c'est la voie à suivre, vous donne une meilleure interface et l'isolement, et à long terme peut vous aider à mettre rapidement à l'échelle \url{http://www.makeuseof.com/tag/optimize-your-dns-for-faster-internet/}
          \item[example.com/api/] Ce modèle est très commun. C'est un bon moyen de commencer quand vous ne voulez pas de Namespace de votre API avec sous un sous-domaine
          \item[example.com/api/v1] Cela semble être une bonne idée. En définissant la version de l'API par l'URL semble être un modèle plus descriptif. Cependant, vous forcez à inclure la version àl'URL sur chaque demande. Cela devient un problème Si vous décidez de changer ce modèle
        \end{description}

        Ne vous inquiétez pas, nous rentrerons plus en détails à propos du versionnement lors de la section \ref{section:api_versioning}

      \end{tcolorbox}

      Il est temps de \textit{commiter}:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ git add config/routes.rb
        $ git commit -m "Set the routes contraints for the api"
        \end{lstlisting}
      \end{scriptsize}

  \section{Versionnement de l'API}\label{section:api_versioning}

    A ce stade, nous devrions avoir un bon mappage des routes utilisant un sous-domaine pour l'espacement des noms des requêtes. Votre fichier \verb|routes.rb| devrait ressembler à ceci:

    \begin{scriptsize}
    \begin{lstlisting}[language=ruby]
    # config/routes.rb
    Rails.application.routes.draw do
      # Api definition
      namespace :api, defaults: { format: :json }, constraints: { subdomain: 'api' }, path: '/'  do
        # We are going to list our resources here
      end
    end
    \end{lstlisting}
    \end{scriptsize}

    Il est maintenant temps de mettre en place d'autres contraintes pour le versioning. Vous devriez vous soucier de versionner votre application dès le début car cela donnera une meilleure structure à votre API. Lorsque des changements interviendrons sur votre API, vous pouvez ainsi proposer aux développeurs de s'adapter aux nouvelles fonctionnalités pendant que les anciennes sont dépréciées\footnote{Il y a un excellent \href{http://railscasts.com/episodes/350-rest-api-versioning}{railscast} qui explique cela}.

    Afin de définir la version de l'API, nous devons d'abord ajouter un autre répertoire sous le dossier \verb|api/| que nous avons créé (Section \ref{section:setup_api}):

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ mkdir app/controllers/api/v1
      \end{lstlisting}
    \end{scriptsize}

    De cette façon, nous pouvons très facilement définir la portée de notre API dans différentes versions. Il ne nous reste plus qu'à ajouter le code nécessaire dans le fichier \verb|routes.rb| (Listing \ref{lst:add_scope_to_toutes})

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Spécification de la version de l'API}, label={lst:add_scope_to_toutes}]
      # config/routes.rb
      Rails.application.routes.draw do
        # Api definition
        namespace :api, defaults: { format: :json }, constraints: { subdomain: 'api' }, path: '/'  do
          scope module: :v1 do
            # We are going to list our resources here
          end
        end
      end
      \end{lstlisting}
    \end{scriptsize}

    L'API est désormais \textit{scopée} via l'URL. Par exemple, avec la configuration actuelle, la récupération d'un produit via l'API se ferait avec cette url:

    \begin{scriptsize}
      \begin{lstlisting}
      http://api.marketplace.dev/v1/products/1
      \end{lstlisting}
    \end{scriptsize}

  \section{Améliorer le versionning}\label{section:improve_api_versioning}

    Jusqu'à présent, l'API est versionnée via l'URL. Mais quelque chose ne va pas. De mon point de vue, le développeur ne devrait pas être au courant de la version qu'il utilise. Par défaut, il devrait utiliser la dernière version. Mais comment pouvons-nous y parvenir?

    Tout d'abord, nous devons améliorer l'accès à la version de l'API via les \href{http://en.wikipedia.org/wiki/List_of_HTTP_header_fields}{en-têtes HTTP}. Cela présente deux avantages:

    \begin{itemize}
      \item supprimer la version de l'API situé dans l'URL
      \item The API description is handle through request headers (Box \ref{box:http_headers})
    \end{itemize}


    \begin{tcolorbox}{Description des en-têtes de requête}\label{box:http_headers}
      Les champs d'en-tête HTTP sont des composants de l'en-tête de demandes et de réponses dans le protocole HTTP. Ils définissent les paramètres de fonctionnement d'une transaction HTTP.

      Une liste commune des en-têtes utilisés est présentée ci-dessous:

      \begin{description}
        \item[Accept] Types de contenu acceptables pour la réponse. Exemple: \verb|Accept: text/plain|
        \item[Authorization] Identifiants d'authentification pour l'authentification HTTP. Exemple: \verb|Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==|
        \item[Content-Type] Le type MIME du corps de la requête (utilisé avec les requêtes POST et PUT). Exemple: \verb|Content-Type: application/x-www-form-urlencoded|
        \item[Origin] Lance une demande de partage de ressources d'origine croisée (demande au serveur un en-tête de réponse \verb|Accès-Contrôle-Autorisation-Autorisation-Origin|) .. Exemple: \verb|Origin: http://www.example-social-network.com|
        \item[User-Agent] La chaîne d'agent utilisateur de l'agent utilisateur. Exemple: \verb|User-Agent: Mozilla/5.0|
      \end{description}

      Il est important que vous vous sentiez à l'aise et que vous les compreniez ces en-tête HTTP\footnote{Il en existe beaucoup d'autres. La liste complète est disponnible \href{https://en.wikipedia.org/wiki/List_of_HTTP_header_fields}{sur Wikipedia}.}.

    \end{tcolorbox}

    Avec Rails, il est très facile d'ajouter ce type de versionnement par le biais d'un en-tête HTTP \verb|Accept|. Nous allons créer une classe sous le répertoire \verb|lib|. N'oubliez pas que nous faisons du TDD\footnote{Développement Dirrigé par les tests} donc nous allons commencer par un test. (Liste \ref{lst:create_api_constraints_spec}).

    Tout d'abord, nous devons ajouter notre suite de tests, qui dans notre cas sera \href{http://rspec.info/}{Rspec} (Listing \ref{lst:add_rspect_to_gemfile}):

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Gemfile avec la suite de test}, label={lst:add_rspect_to_gemfile}]
      # Gemfile
      group :test do
        gem 'rspec-rails', '~> 3.8'
        gem 'factory_bot_rails', '~> 4.9'
        gem 'ffaker', '~> 2.10'
      end
      \end{lstlisting}
    \end{scriptsize}

    Ensuite nous lançons la commande \verb|bundle| pour installer les gemmes:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ bundle install
      \end{lstlisting}
    \end{scriptsize}

    Enfin, nous installons \verb|rspec| et ajoutons de la configuration pour éviter que des \textit{views} et des \textit{helpers} ne soient générés:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rails generate rspec:install
      \end{lstlisting}
    \end{scriptsize}

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Configuration de notre suite de test avec respec}, label={lst:setup_rspec}]
      # config/application.rb
      # ...
      module MarketPlaceApi
        class Application < Rails::Application
          # Initialize configuration defaults for originally generated Rails version.
          config.load_defaults 5.2

          config.generators do |g|
            g.test_framework :rspec, fixture: true
            g.fixture_replacement :factory_bot, dir: 'spec/factories'
            g.view_specs false
            g.helper_specs false
            g.stylesheets = false
            g.javascripts = false
            g.helper = false
          end

          config.autoload_paths += %W(\#{config.root}/lib)

          # Don't generate system test files.
          config.generators.system_tests = nil
        end
      end
      \end{lstlisting}
    \end{scriptsize}

    Si tout s'est bien passé, il est maintenant temps d'ajouter un répertoire \verb|spec| sous \verb|lib| et d'ajouter le fichier \verb|api_constraints_spec.rb|:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ mkdir lib/spec
      $ touch lib/spec/api_constraints_spec.rb
      \end{lstlisting}
    \end{scriptsize}

    Nous ajoutons ensuite une série de spécifications décrivant notre classe:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Test de ApiConstraints}, label={lst:create_api_constraints_spec}]
      # lib/spec/api_constraints_spec.rb
      require 'spec_helper'
      require './lib/api_constraints'

      describe ApiConstraints do
        let(:api_constraints_v1) { ApiConstraints.new(version: 1) }
        let(:api_constraints_v2) { ApiConstraints.new(version: 2, default: true) }

        describe 'matches?' do
          it "returns true when the version matches the 'Accept' header" do
            request = double(host: 'api.marketplace.dev',
                             headers: { 'Accept' => 'application/vnd.marketplace.v1' })
            expect(api_constraints_v1.matches?(request)).to be_truthy
          end

          it "returns the default version when 'default' option is specified" do
            request = double(host: 'api.marketplace.dev')
            expect(api_constraints_v2.matches?(request)).to be_truthy
          end
        end
      end
      \end{lstlisting}
    \end{scriptsize}

    Laissez-moi vous expliquer le code. Nous initialisons la classe avec un \verb|Hash| d'options qui contiendra:

    \begin{itemize}
      \item la version de l'API
      \item une valeur par défaut pour gérer la version par défaut
    \end{itemize}

    Nous fournissons une méthode \verb|match?| afin que le routeur devine si la version par défaut est requise ou si l'en-tête \verb|Accept| correspond à la chaîne donnée.

    L'implémentation ressemble à ceci (Listing \ref{lst:create_api_constraints})

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={La classe ApiConstraints}, label={lst:create_api_constraints}]
      # lib/api_constraints.rb
      class ApiConstraints
        def initialize(options)
          @version = options[:version]
          @default = options[:default]
        end

        def matches?(req)
          @default || req.headers['Accept'].include?("application/vnd.marketplace.v#{@version}")
        end
      end
      \end{lstlisting}
    \end{scriptsize}

    Comme vous l'imaginez, nous devons ajouter la classe à notre fichier \verb|routes.rb| et la définir comme option de portée de contrainte (Listing \ref{lst:add_api_constraints_to_toutes}):

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Ajout de la contrainte à la route}, label={lst:add_api_constraints_to_toutes}]
      # config/routes.rb
      require 'api_constraints'

      Rails.application.routes.draw do
        # Api definition
        namespace :api, defaults: { format: :json }, constraints: { subdomain: 'api' }, path: '/' do
          scope module: :v1, constraints: ApiConstraints.new(version: 1, default: true) do
            # We are going to list our resources here
          end
        end
      end
      \end{lstlisting}
    \end{scriptsize}

    La configuration ci-dessus gère maintenant le versioning par le biais des en-têtes HTTP. Pour l'instant la version 1 est la version par défaut. Chaque requête sera redirigée vers cette version, peu importe si l'en-tête avec la version est présent ou non.

    Avant de nous dire au revoir, faisons nos premiers tests et assurons-nous que notre test fonctionne:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ bundle exec rspec lib/spec/api_constraints_spec.rb
      ..

      Finished in 0.00294 seconds (files took 0.06292 seconds to load)
      2 examples, 0 failures
      \end{lstlisting}
    \end{scriptsize}

    \section{Conclusion}

      Ça a été un long, je sais, mais vous avez réussi! N'abandonnez pas, c'est juste notre petite fondation pour quelque chose de grand, alors continuez comme ça. Sachez qu'il y a des gemmes qui gèrent ce genre de configuration pour nous:

    \begin{itemize}
      \item \href{https://github.com/Sutto/rocket_pants}{RocketPants}
      \item \href{https://github.com/bploetz/versionist}{Versionist}
    \end{itemize}

    Je n'en parle pas ici puisque nous essayons d'apprendre comment mettre en œuvre ce genre de fonctionnalité. Le code jusqu'ici est disponnible \href{https://github.com/madeindjs/market_place_api/commit/124873774b578af3df21136df5ee80f4d50da3bd}{ici}.

\chapter{Présentation des utilisateurs}\label{chapter:3}

  Dans le dernier chapitre, nous avons réussi à mettre en place les bases de la configuration de notre application. Nous avons même ajouté le \textit{versioning} par le biais des en-têtes HTTP. Dans le chapitre \ref{chapter:5}, nous traiterons l'authentification des utilisateurs à l'aide de jetons d'authentification ainsi que la définition de permissions pour limiter l'accès aux utilisateurs  connectés. Dans les chapitres à venir, nous relierons les produits aux utilisateurs et leur donnerons la possibilité de passer des commandes.

  Vous pouvez cloner le projet jusqu'à ce point avec:

  \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ git clone https://github.com/madeindjs/market_place_api/tree/chapitre_2
    \end{lstlisting}
  \end{scriptsize}

  Comme vous pouvez déjà l'imaginer, il existe de nombreuses solutions d'authentification pour Rails comme \href{https://github.com/binarylogic/authlogic}{AuthLogic}, \href{https://github.com/thoughtbot/clearance}{Clearance} et \href{https://github.com/plataformatec/devise}{Devise}. Nous utiliserons le dernier (Encadré \ref{box:devise_for_authentification}), qui offre un excellent moyen d'intégrer non seulement l'authentification de base, mais de nombreux autres modules pour une utilisation ultérieure.

  \begin{tcolorbox}{Devise pour l'authentification}\label{box:devise_for_authentification}
    Devise est livré avec jusqu'à 10 modules pour la gestion de l'authentification :

    \begin{itemize}
      \item Database Authenticable
      \item Omniauthable
      \item Confirmable
      \item Recoverable
      \item Registerable
      \item Rememberable
      \item Trackable
      \item Timeoutable
      \item Validatable
      \item Lockable
    \end{itemize}

    Si vous n'avez jamais travaillé avec devise auparavant, je vous recommande de visiter \href{https://github.com/plataformatec/devise}{le répertoire Github} et de lire la documentation. Vous y trouverez beaucoup de bons exemples.
  \end{tcolorbox}

  Ce chapitre sera complet. Il sera peut-être long mais j'essaie d'aborder autant de sujets que possible et d'aborder les meilleures pratiques. N'hésitez pas à vous prendre un café et allons-y. A la fin de ce chapitre, vous aurez construit toute la logique des utilisateurs ainsi que la validations et la gestion des erreurs.

  Nous voulons suivre ce chapitre, c'est donc un bon moment pour créer une nouvelle branche:

  \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ git checkout -b chapter3
    \end{lstlisting}
  \end{scriptsize}

  Assurez-vous simplement d'être sur la branche \verb|master| avant.

  \section{Modèle d'utilisateur}

    Nous devons d'abord ajouter la gemme Devise au \verb|Gemfile| (Listing \ref{lst:add_devise_to_gemfile})

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Le Gemfile avec l'ajout de Devise}, label={lst:add_devise_to_gemfile}]
      # Gemfile
      source 'https://rubygems.org'
      git_source(:github) { |repo| "https://github.com/#{repo}.git" }

      ruby '2.5.3'

      # Bundle edge Rails instead: gem 'rails', github: 'rails/rails'
      gem 'rails', '~> 5.2.0'
      # Use sqlite3 as the database for Active Record
      gem 'sqlite3'
      # Use Puma as the app server
      gem 'puma', '~> 3.11'
      # Use SCSS for stylesheets
      gem 'sass-rails', '~> 5.0'
      # Use Uglifier as compressor for JavaScript assets
      gem 'uglifier', '>= 1.3.0'

      # Api gems
      gem 'active_model_serializers'

      # Reduces boot times through caching; required in config/boot.rb
      gem 'bootsnap', '>= 1.1.0', require: false

      group :development, :test do
        # Call 'byebug' anywhere in the code to stop execution and get a debugger console
        gem 'byebug', platforms: %i[mri mingw x64_mingw]
      end

      group :development do
        # Access an interactive console on exception pages or by calling 'console' anywhere in the code.
        gem 'listen', '>= 3.0.5', '< 3.2'
        gem 'web-console', '>= 3.3.0'
        # Spring speeds up development by keeping your application running in the background. Read more: https://github.com/rails/spring
        gem 'spring'
        gem 'spring-watcher-listen', '~> 2.0.0'
      end

      group :test do
        gem 'factory_bot_rails', '~> 4.9'
        gem 'ffaker', '~> 2.10'
        gem 'rspec-rails', '~> 3.8'
      end

      # Windows does not include zoneinfo files, so bundle the tzinfo-data gem
      gem 'tzinfo-data', platforms: %i[mingw mswin x64_mingw jruby]

      gem 'devise'
      \end{lstlisting}
    \end{scriptsize}

    Lancez ensuite la commande \verb|bundle install| pour installer la Gem. Une fois que la commande est terminée, nous devons lancer le générateur d'installation de Devise:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rails g devise:install
        create  config/initializers/devise.rb
        create  config/locales/devise.en.yml
        ...
      \end{lstlisting}
    \end{scriptsize}

    Maintenant et si tout s'est bien passé, nous serons en mesure de générer le modèle \verb|user| à l'aide du générateur de Devise:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rails g devise User
          invoke  active_record
          create    db/migrate/20181113070805_devise_create_users.rb
          create    app/models/user.rb
          invoke    rspec
          create      spec/models/user_spec.rb
          invoke      factory_bot
          create        spec/factories/users.rb
          insert    app/models/user.rb
          route  devise_for :users
      \end{lstlisting}
    \end{scriptsize}

    A partir de maintenant, chaque fois que nous créons un modèle, le générateur va également créer un fichier d'usine pour ce modèle (Listing \ref{lst:create_factories_users}). Cela nous aidera à créer facilement des utilisateurs de tests et facilitera la rédaction de nos tests.

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Usine d'utilsateurs}, label={lst:create_factories_users}]
      # spec/factories/users.rb
      FactoryBot.define do
        factory :user do

        end
      end
      \end{lstlisting}
    \end{scriptsize}

    Ensuite, nous allons migrer la base de données et préparer la base de données de test.

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rake db:migrate
      == 20181113070805 DeviseCreateUsers: migrating ================================
      -- create_table(:users)
         -> 0.0008s
      -- add_index(:users, :email, {:unique=>true})
         -> 0.0005s
      -- add_index(:users, :reset_password_token, {:unique=>true})
         -> 0.0007s
      == 20181113070805 DeviseCreateUsers: migrated (0.0023s) =======================
      \end{lstlisting}
    \end{scriptsize}

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rake db:test:prepare
      \end{lstlisting}
    \end{scriptsize}

    Faisons maintenant un \verb|commit| afin de garder un historique concis:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ git add .
      $ git commit -m "Adds devise user model"
      \end{lstlisting}
    \end{scriptsize}

  \section{Notre premier test sur le modèle User}

    Nous allons ajouter quelques spécifications pour nous assurer que le modèle utilisateur répond aux attributs \verb|email|, \verb|password| et \verb|password_confirmation| fournis par Devise (Listing \ref{lst:user_spec_with_attrs}). Pour des raisons de commodité, nous allons modifier le fichier d'usine des utilisateurs pour ajouter les attributs correspondants (Listing \ref{lst:user_factory_with_attrs}).

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Usine d'utilisateurs avec les attributs}, label={lst:user_factory_with_attrs}]
      # spec/factories/users.rb
      FactoryBot.define do
        factory :user do
          email { FFaker::Internet.email }
          password { '12345678' }
          password_confirmation { '12345678' }
        end
      end
      \end{lstlisting}
    \end{scriptsize}

    Une fois les attributs ajoutés, il est temps de tester notre modèle \verb|User| (Listing \ref{lst:user_spec_with_attrs})).

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Test pour les attributs Devise}, label={lst:user_spec_with_attrs}]
      # spec/models/user_spec.rb
      # ...

      RSpec.describe User, type: :model do
        before { @user = FactoryBot.build(:user) }

        subject { @user }

        it { should respond_to(:email) }
        it { should respond_to(:password) }
        it { should respond_to(:password_confirmation) }

        it { should be_valid }
      end
      \end{lstlisting}
    \end{scriptsize}

    Vue que nous avons préparé la base de données de test avec \verb|rake db:test:prepare|, nous pouvons exécuter les tests:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ bundle exec rspec spec/models/user_spec.rb
      ....

      Finished in 0.03231 seconds (files took 0.81624 seconds to load)
      4 examples, 0 failures
      \end{lstlisting}
    \end{scriptsize}

    C'était facile! Nous devrions maintenant faire un \verb|commit|:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ git add .
      $ git commit -am 'Adds user firsts specs'
      \end{lstlisting}
    \end{scriptsize}

  \section{Construire les utilisateurs}

    Il est temps de faire notre premier point d'entrée. Nous allons juste commencer à construire l'action \verb|show| pour l'utilisateur qui va afficher un utilisateur en JSON. Nous devons d'abord générer le \verb|users_controller|, ajouter les tests correspondants et ensuite construire le code réel.

    Tout d'abord, nous générons le contrôleur utilisateur:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rails generate controller users
      \end{lstlisting}
    \end{scriptsize}

    Cette commande var créer le fichier \verb|users_controller_spec.rb| (Listing \ref{lst:add_show_test_to_users_controller_spec}). Avant d'entrer dans le vif du sujet, il y a deux choses que nous voulons tester pour une API:

    \begin{itemize}
      \item La structure du JSON renvoyée par le serveur
      \item Le code de réponse HTTP renvoyée par le serveur (encadré 3.2).
    \end{itemize}

    \begin{tcolorbox}{Les codes HTTP courants}\label{box:common_http_code}
      Le premier chiffre du code d'état spécifie l'une des cinq classes de réponse. Le strict minimum pour un client HTTP est qu'il utilise une ces cinq classes. Voici une liste des codes HTTP courrament utilisés:

      \begin{description}
        \item[200] Réponse standard pour les requêtes HTTP réussies. C'est généralement sur les requêtes GET
        \item[201] La demande a été satisfaite et a donné lieu à la création d'une nouvelle ressource. Après les demandes de POST
        \item[204] Le serveur a traité la requête avec succès, mais ne renvoie aucun contenu. Il s'agit généralement d'une requête DELETE réussie.
        \item[400] La requête ne peut pas être exécutée en raison d'une mauvaise syntaxe. Peut arriver pour tout type de requête.
        \item[401] Similaire au 403 Interdit, mais spécifiquement pour une utilisation lorsque l'authentification est requise et qu'elle a échoué ou n'a pas encore été fournie. Peut arriver pour tout type de requête.
        \item[404] La ressource demandée n'a pas pu être trouvée mais peut être à nouveau disponible à l'avenir. Habituellement, concerne les requêtes GET
        \item[500] Un message d'erreur générique, donné lorsqu'une condition inattendue a été rencontrée et qu'aucun autre message spécifique ne convient. Peut arriver pour tout type de requête.
      \end{description}

      Pour une liste complète des codes de réponse HTTP, consultez l'\href{https://fr.wikipedia.org/wiki/Liste_des_codes_HTTP}{article sur Wikipedia}.
    \end{tcolorbox}

    Pour garder notre code bien découpé, nous allons créer quelques répertoires sous le répertoire des tests des contrôleurs afin d'être cohérent la configuration (Listing \ref{lst:mkdir_controllers_api}). Il existe aussi une autre convention qui utilise à la place du répertoire \verb|controllers| un répertoire de \verb|request| ou \verb|integration|. Dans notre cas, je préfère rester cohérent avec le répertoire \verb|app/controllers|.

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ mkdir -p spec/controllers/api/v1
      $ mv spec/controllers/users_controller_spec.rb spec/controllers/api/v1
      \end{lstlisting}
    \end{scriptsize}

    Après avoir créé les répertoires, nous devons changer le nom de la classe \verb|UsersController| en \verb|Api::V1::UsersController|. Le fichier doit ressembler à ça:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # ...

      RSpec.describe Api::V1::UsersController, type: :controller do

      end
      \end{lstlisting}
    \end{scriptsize}

    Maintenant, voici le fichier avec les tests crée:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Le test du contrôlleur des utilisateur  (spec/controllers/api/v1/users\_controller\_spec.rb)}, label={lst:add_show_test_to_users_controller_spec}]
      # ...

      RSpec.describe Api::V1::UsersController, type: :controller do
        before(:each) { request.headers['Accept'] = "application/vnd.marketplace.v1" }

          describe "GET #show" do
            before(:each) do
              @user = FactoryBot.create :user
              get :show, params: { id: @user.id, format: :json}
            end

            it "returns the information about a reporter on a hash" do
              user_response = JSON.parse(response.body, symbolize_names: true)
              expect(user_response[:email]).to eql @user.email
            end

            it { expect(response).to be_success }
          end
      end
      \end{lstlisting}
    \end{scriptsize}

    Il suffit ensuite d'ajouter l'action à notre contrôlleur (Listing \ref{lst:add_show_to_users_controller_spec}). C'est extrêmement simple:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Le contrôlleur des utilisateurs avec l'action' 'show'}, label={lst:add_show_to_users_controller_spec}]
      # app/controllers/api/v1/users\_controller.rb
      class  Api::V1::UsersController < ApplicationController
        def show
          render json: User.find(params[:id])
        end
      end
      \end{lstlisting}
    \end{scriptsize}

    \begin{tcolorbox}{Les codes HTTP courants}
      Il est possible qu'il faille activer le module \verb|Devise::Test::ControllerHelpers| au fichier \verb|spec/rails_helper.rb| afin de charger les utilitaires Devise aux test. Si c'est le cas, ajouter la ligne suivante

      \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      #  ...
      RSpec.configure do |config|
        #  ...
        config.include Devise::Test::ControllerHelpers, type: :controller
        #  ...
      end
      \end{lstlisting}
      \end{scriptsize}
    \end{tcolorbox}

    Si vous exécutez les tests avec \verb|bundle exec rspec spec/controllers| vous obtenez l'erreur suivante:

    \begin{scriptsize}
      \begin{lstlisting}
      $ bundle exec rspec spec/controllers
      FF

      Failures:

        1) Api::V1::UsersController GET #show returns the information about a reporter on a hash
          Failure/Error: get :show, params: { id: @user.id, format: :json}

          ActionController::UrlGenerationError:
          No route matches {:action=>"show", :controller=>"api/v1/users", :format=>:json, :id=>1}
            ...

        2) Api::V1::UsersController GET #show
          Failure/Error: get :show, params: { id: @user.id, format: :json}

          ActionController::UrlGenerationError:
          No route matches {:action=>"show", :controller=>"api/v1/users", :format=>:json, :id=>1}
            ...

      Finished in 0.01632 seconds (files took 0.47675 seconds to load)
        2 examples, 2 failures
      \end{lstlisting}
    \end{scriptsize}

    Ce type d'erreur est très courant lorsque vous générer vos ressources à la main! En effet, nous vons totalement oublié les routes. Alors ajoutons-les (Figure \ref{lst:add_route_users_show}):

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Ajoute de la route Users\#Show}, label={lst:add_route_users_show}]
      # config/routes.rb

      require 'api_constraints'

      Rails.application.routes.draw do
        devise_for :usersto
        # Api definition
        namespace :api, defaults: { format: :json }, constraints: { subdomain: 'api' }, path: '/' do
          scope module: :v1, constraints: ApiConstraints.new(version: 1, default: true) do
            resources :users, only: [:show]
          end
        end
      end
      \end{lstlisting}
    \end{scriptsize}

    % -- END RELECTURE ALEX

    Vos tests devraient désormais passer:

    \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ bundle exec rspec spec/controllers
    ..

    Finished in 0.02652 seconds (files took 0.47291 seconds to load)
    2 examples, 0 failures
    \end{lstlisting}
    \end{scriptsize}

    Comme d'habitude, après avoir ajouté un des fonctionnalités dont nous sommes satisfaits, nous faisons un \verb|commit|:

    \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ git add .
    $ git commit -m "Adds show action the users controller"
    \end{lstlisting}
    \end{scriptsize}

    \subsection{Tester notre ressource avec cURL}

      Nous avons donc enfin une ressource à tester. Nous avons plusieurs solutions pour la tester. La première qui me vient à l'esprit est l'utilisation de cURL qui est intégré dans presque toutes les distributions Linux. Alors, essayons:

      Rappelez-vous que notre URI de base est \verb|api.market_place_api.dev| (Section \ref{subsec:routes_constraints_namespaces}).

      \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ curl -H 'Accept: application/vnd.marketplace.v1' http://api.market_place_api.dev/users/1
      \end{lstlisting}
      \end{scriptsize}

      En faisant cela nous obtenons une erreur et c'est normal: l'utilisateur n'existe pas. Créons-le avec le terminal:

      \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rails console
      Loading development environment (Rails 5.2.1)
      2.5.3 :001 >  User.create email: "example@marketplace.com", password: "12345678", password_confirmation: "12345678"
      \end{lstlisting}
      \end{scriptsize}

      Après avoir créé l'utilisateur, notre appel cURL devrait fonctionner:

      \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ curl -H 'Accept: application/vnd.marketplace.v1' \
      http://api.market_place_api.dev/users/1
      {"id":1,"email":"example@marketplace.com", ...
      \end{lstlisting}
      \end{scriptsize}

      Et voilà! Vous avez maintenant une entrée d'API d'enregistrement d'utilisateur. Si vous avez des problèmes avec la réponse, vous devrez peut-être modifier le fichier \verb|application_controller.rb| et ajouter la ligne suivante (Listing \ref{lst:add_protect_from_forgery}):

      \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Correction de la réponde de l'API}, label={lst:add_protect_from_forgery}]
      # app/controllers/application_controller.rb

      class ApplicationController < ActionController::Base
        # Prevent CSRF attacks by raising an exception.
        # For APIs, you may want to use :null_session instead.
        protect_from_forgery with: :null_session
      end
      \end{lstlisting}
      \end{scriptsize}

      Comme suggéré même par Rails, nous devrions utiliser \verb|null_session| pour empêcher les attaques CSFR. Je vous recommande fortement de le faire sinon les requêtes POST et PUT ne fonctionnerons pas. Après avoir mis à jour le fichier \verb|application_controller.rb| c'est le moment de faire un \verb|commit|:

      \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ git add .
      $ git commit -m "Updates application controller to prevent CSRF exception from being raised"
      \end{lstlisting}
      \end{scriptsize}

    \subsection{Créer les utilisateurs}\label{subsec:create_users}

      Maintenant que nous avons une meilleure compréhension de la façon de construire des points d'entrée, il est temps d'étendre notre API. Une des fonctionnalités les plus importante est de laisser les utilisateurs créer un profil sur notre application. Comme d'habitude, nous allons écrire des tests avant d'implémenter notre code pour étendre notre suite de tests.

      Assurez-vous que votre répertoire Git est propre et que vous n'avez pas de fichier en \verb|staging|. Si c'est le cas, \textit{committez}-les pour que nous puissions recommencer à zéro.

      Commençons donc par écrire notre test tests en ajoutant une entrée pour créer un utilisateur sur le fichier \verb|users_controller_spec.rb| (Listing \ref{lst:add_spec_users_controller_create}):

      \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Ajout les tests de création des utilisateurs}, label={lst:add_spec_users_controller_create}]
      # spec/controllers/api/v1/users_controller_spec.rb

      # ...

      RSpec.describe Api::V1::UsersController, type: :controller do

        # ...

        describe 'POST #create' do
          context 'when is successfully created' do
            before(:each) do
              @user_attributes = FactoryBot.attributes_for :user
              post :create, params: { user: @user_attributes }, format: :json
            end

            it 'renders the json representation for the user record just created' do
              user_response = JSON.parse(response.body, symbolize_names: true)
              expect(user_response[:email]).to eql @user_attributes[:email]
            end

            it { expect(response.response_code).to eq(201) }
          end

          context 'when is not created' do
            before(:each) do
              # notice I'm not including the email
              @invalid_user_attributes = { password: '12345678',
                                           password_confirmation: '12345678' }
              post :create, params: { user: @invalid_user_attributes }, format: :json
            end

            it 'renders an errors json' do
              user_response = JSON.parse(response.body, symbolize_names: true)
              expect(user_response).to have_key(:errors)
            end

            it 'renders the json errors on why the user could not be created' do
              user_response = JSON.parse(response.body, symbolize_names: true)
              expect(user_response[:errors][:email]).to include "can't be blank"
            end

            it {  expect(response.response_code).to eq(422) }
          end
        end
      end
      \end{lstlisting}
      \end{scriptsize}

      Cela fait beaucoup de code (Listing \ref{lst:add_spec_users_controller_create}). Ne vous inquiétez pas, je vous explique tout:

      \begin{itemize}
        \item Nous devons valider les états sur lesquels l'enregistrement peut être valide ou invalide. Dans ce cas, nous utilisons les \verb|context| pour réaliser ces scénarios.
        \item  Au cas où tout se passe bien, nous devrions retourner un code HTTP 201\footnote{signifie qu'un enregistrement vient d'être créé} ainsi que la représentation JSON de cet objet.
        \item En cas d'erreur, nous devons renvoyer un code HTTP 422\footnote{signifie Unprocessable Entity c'est à dire que le serveur ne peut pas sauvegarder l'enregistrement}. Nous retournons également un JSON représentant la raison pour laquelle la ressource n'a pas pu être sauvegardée.
      \end{itemize}

      A ce moment là, Les tests doivent échouer:

      \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ bundle exec rspec spec/controllers/api/v1/users_controller_spec.rb
      .FFFFFF
      \end{lstlisting}
      \end{scriptsize}

      Il est donc temps d'implémenter le code pour que nos tests reussissent (Listing \ref{lst:add_users_controller_create})

      \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Implémentation du contrôlleur utilisateurs afin que les tests de création passent}, label={lst:add_users_controller_create}]
      # app/controllers/api/v1/users_controller.rb

      class Api::V1::UsersController < ApplicationController

        # ...

        def create
          user = User.new user_params
          if user.save
            render json: user, status: 201, location: [:api, user]
          else
            render json: { errors: user.errors }, status: 422
          end
        end

        private

        def user_params
          params.require(:user).permit(:email, :password, :password_confirmation)
        end
      end
      \end{lstlisting}
      \end{scriptsize}

      Rappelez-vous qu'à chaque fois que nous ajoutons une entrée dans notre API il faut aussi ajouter cette action dans notre fichier \verb|routes.rb|.

      \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # config/routes.rb

      Rails.application.routes.draw do
        # ...
        resources :users, only: [:show, :create]
        # ...
      end
      \end{lstlisting}
      \end{scriptsize}

      Comme vous pouvez le constater, l'implémentation est assez simple. Nous avons également ajouté la méthode privée \verb|user_params| pour protéger les assignation d'attributs en masse. Maintenant, nos tests devraient passer:

      \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ bundle exec rspec spec/controllers/api/v1/users_controller_spec.rb
      .......

      Finished in 0.05967 seconds (files took 0.4673 seconds to load)
      7 examples, 0 failures
      \end{lstlisting}
      \end{scriptsize}

      Oura! \textit{Committons} les changements et continuons à construire notre application:

      \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ git add .
      $ git commit -m "Adds the user create endpoint"
      \end{lstlisting}
      \end{scriptsize}


    \subsection{Mettre à jour les utilisateurs}

      Le schéma de mise à jour des utilisateurs est très similaire à celui de la création (Section \ref{subsec:create_users}). Si vous êtes un développeur de Rails expérimenté, vous connaissez peut-être déjà les différences entre ces deux actions:

      \begin{itemize}
        \item L'action de mise à jour répond à une requête PUT/PATCH (Section \ref{section:setup_api}).
        \item Seul un utilisateur connecté devrait être en mesure de mettre à jour ses informations. Ce qui signifie que nous devrons forcer un utilisateur à s'authentifier. Nous en parlerons au chapitre \ref{chapter:5}.
      \end{itemize}

      Comme d'habitude, nous commençons par écrire nos tests (Listing \ref{lst:add_spec_users_controller_update}):

      \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Les tests du contrôlleur utilisateur avec les test de mise à jour}, label={lst:add_spec_users_controller_update}]
      # spec/controllers/api/v1/users_controller_spec.rb

      RSpec.describe Api::V1::UsersController, type: :controller do

        # ...

        describe "PUT/PATCH #update" do

         context "when is successfully updated" do
           before(:each) do
             @user = FactoryBot.create :user
             patch :update, params: {
               id: @user.id,
               user: { email: "newmail@example.com" } },
               format: :json
           end

           it "renders the json representation for the updated user" do
             user_response = JSON.parse(response.body, symbolize_names: true)
             expect(user_response[:email]).to eql "newmail@example.com"
           end

           it {  expect(response.response_code).to eq(200) }
         end

         context "when is not created" do
           before(:each) do
             @user = FactoryBot.create :user
             patch :update, params: {
               id: @user.id,
               user: { email: "bademail.com" } },
               format: :json
           end

           it "renders an errors json" do
             user_response = JSON.parse(response.body, symbolize_names: true)
             expect(user_response).to have_key(:errors)
           end

           it "renders the json errors on whye the user could not be created" do
             user_response = JSON.parse(response.body, symbolize_names: true)
             expect(user_response[:errors][:email]).to include "is invalid"
           end

           it {  expect(response.response_code).to eq(422) }
         end
       end
      end
      \end{lstlisting}
      \end{scriptsize}

      Pour que les tests réussissent, nous devons construire l'action de mise à jour sur le fichier \verb|users_controller.rb| et ajouter la route au fichier \verb|routes.rb|. Comme vous pouvez le voir, nous avons trop de code dupliqué, nous remanierons nos tests au chapitre 4.

      Tout d'abord nous ajoutons l'action le fichier routes.rb:

      \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # config/routes.rb

      Rails.application.routes.draw do
        # ...
        resources :users, only: [:show, :create, :update]
        # ...
      end
      \end{lstlisting}
      \end{scriptsize}

      Ensuite nous implémentons l'action de mise à jour sur le contrôleur utilisateur et faisons passer nos tests:

      \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # app/controllers/api/v1/users_controller.rb
      class Api::V1::UsersController < ApplicationController
        # ...

        def update
          user = User.find(params[:id])

          if user.update(user_params)
            render json: user, status: 200, location: [:api, user]
          else
            render json: { errors: user.errors }, status: 422
          end
        end

        # ...
      end
      \end{lstlisting}
      \end{scriptsize}

      Tous nos tests devraient maintenant passer:

      \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ bundle exec rspec spec/controllers/api/v1/users_controller_spec.rb
      ............

      Finished in 0.08826 seconds (files took 0.47286 seconds to load)
      12 examples, 0 failures
      \end{lstlisting}
      \end{scriptsize}

      Vue que tout fonctionne, on effecte un \verb|commit|:

      \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ git add .
      $ git commit -m "Adds update action the users controller"
      \end{lstlisting}
      \end{scriptsize}

    \subsection{Supprimer l'utilisateur}

      Jusqu'à présent, nous avons construit un tas d'actions sur le contrôleur des utilisateurs avec leurs tests mais ce n'est terminé. Il nous en manque juste une dernière qui est l'action de destruction. Créons donc le test (liste \ref{lst:add_spec_users_controller_destroy}):

      \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Les tests du contrôlleur utilisateur avec les test de destruction}, label={lst:add_spec_users_controller_destroy}]
      # spec/controllers/api/v1/users_controller_spec.rb

      # ...

      RSpec.describe Api::V1::UsersController, type: :controller do
        before(:each) { request.headers['Accept'] = 'application/vnd.marketplace.v1' }

        # ...

        describe "DELETE #destroy" do
          before(:each) do
            @user = FactoryBot.create :user
            delete :destroy, params: { id: @user.id }, format: :json
          end

          it { expect(response.response_code).to eq(204) }
        end
      end
      \end{lstlisting}
      \end{scriptsize}

      Comme vous pouvez le voir, le test est très simple. Nous ne répondons qu'avec un statut de 204 qui signifie \verb|No Content|\footnote{Cela qui signifie que le serveur a traité la demande avec succès, mais ne renvoie aucun contenu}. Nous pourrions aussi retourner un code d'état de 200, mais je trouve plus naturel de répondre sans rien dans ce cas car nous supprimons une ressource et une réponse réussie peut suffire.

      La mise en œuvre de l'action de destruction est également assez simple:

      \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # app/controllers/api/v1/users_controller.rb
      class Api::V1::UsersController < ApplicationController
        # ...

        def destroy
          user = User.find(params[:id])
          user.destroy
          head 204
        end

        # ...
      end
      \end{lstlisting}
      \end{scriptsize}

      N'oubliez pas d'ajouter l'action \verb|destroy| dans le fichier \verb|routes.rb|:

      \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # config/routes.rb

      Rails.application.routes.draw do
        # ...
        resources :users, only: [:show, :create, :update, :destroy]
        # ...
      end
      \end{lstlisting}
      \end{scriptsize}

      Si tout est correct, vos tests devraient passer:

      \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ bundle exec rspec spec/controllers/api/v1/users_controller_spec.rb
      .............

      Finished in 0.09255 seconds (files took 0.4618 seconds to load)
      13 examples, 0 failures
      \end{lstlisting}
      \end{scriptsize}

      Rappelez-vous qu'après avoir apporté quelques modifications à notre code, il est de bonne pratique de les commettre afin que nous gardions un bon histoirique.

      \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ git add .
      $ git commit -m "Adds destroy action to the users controller"
      \end{lstlisting}
      \end{scriptsize}

  \section{Integrating Sabisu}

    % TODO ?

  \section{Conclusion}

    Oh vous êtes là! Bien joué! Je sais que c'était probablement  long mais n'abandonnez pas! Assurez-vous que vous comprenez chaque morceau de code, les choses vont s'améliorer, dans le chapitre 4, nous remanierons nos tests pour rendre le code plus lisible et plus maintenable. Alors restez avec moi!

\chapter{Refactoriser les tests}\label{chapter:4}

  Dans le chapitre \ref{chapter:3} nous avons mis en place des entrée de ressources utilisateur. Si vous avez sauté ce chapitre ou si vous n'avez pas tout compris, je vous recommande vivement de le regarder. Il couvre les premières bases des tests et c'est une introduction aux réponses JSON.

  Vous pouvez cloner le projet à cette étape avec:

  \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ git clone --branch chapitre_3 https://github.com/madeindjs/market_place_api
    \end{lstlisting}
  \end{scriptsize}

  Dans ce chapitre, nous allons refactoriser nos spécifications de test en ajoutant des méthodes d'aide, supprimer le paramètre de format envoyé sur chaque requête et le faire à travers les en-têtes, et nous espérons construire une suite de test plus cohérente et évolutive.

  Jetons donc un coup d'oeil au fichier \verb|users_controller_spec.rb| (Listing \ref{lst:users_controller_spec_before_factorization}):

  \begin{scriptsize}
    \begin{lstlisting}[language=ruby, caption={Le fichier de test du contrôlleur avant la refactorisation}, label={lst:users_controller_spec_before_factorization}]
    # spec/controllers/api/v1/users_controller_spec.rb

    # ...

    RSpec.describe Api::V1::UsersController, type: :controller do
      before(:each) { request.headers['Accept'] = 'application/vnd.marketplace.v1' }

      describe 'GET #show' do
        before(:each) do
          @user = FactoryBot.create :user
          get :show, params: { id: @user.id, format: :json }
        end

        it 'returns the information about a reporter on a hash' do
          user_response = JSON.parse(response.body, symbolize_names: true)
          expect(user_response[:email]).to eql @user.email
        end

        it { expect(response.response_code).to eq(200) }
      end

      describe 'POST #create' do
        context 'when is successfully created' do
          before(:each) do
            @user_attributes = FactoryBot.attributes_for :user
            post :create, params: { user: @user_attributes }, format: :json
          end

          it 'renders the json representation for the user record just created' do
            user_response = JSON.parse(response.body, symbolize_names: true)
            expect(user_response[:email]).to eql @user_attributes[:email]
          end

          it { expect(response.response_code).to eq(201) }
        end

        context 'when is not created' do
          before(:each) do
            # notice I'm not including the email
            @invalid_user_attributes = { password: '12345678',
                                         password_confirmation: '12345678' }
            post :create, params: { user: @invalid_user_attributes }, format: :json
          end

          it 'renders an errors json' do
            user_response = JSON.parse(response.body, symbolize_names: true)
            expect(user_response).to have_key(:errors)
          end

          it 'renders the json errors on why the user could not be created' do
            user_response = JSON.parse(response.body, symbolize_names: true)
            expect(user_response[:errors][:email]).to include "can't be blank"
          end

          it {  expect(response.response_code).to eq(422) }
        end
      end


      describe "PUT/PATCH #update" do

       context "when is successfully updated" do
         before(:each) do
           @user = FactoryBot.create :user
           patch :update, params: {
             id: @user.id,
             user: { email: "newmail@example.com" } },
             format: :json
         end

         it "renders the json representation for the updated user" do
           user_response = JSON.parse(response.body, symbolize_names: true)
           expect(user_response[:email]).to eql "newmail@example.com"
         end

         it {  expect(response.response_code).to eq(200) }
       end

       context "when is not created" do
         before(:each) do
           @user = FactoryBot.create :user
           patch :update, params: {
             id: @user.id,
             user: { email: "bademail.com" } },
             format: :json
         end

         it "renders an errors json" do
           user_response = JSON.parse(response.body, symbolize_names: true)
           expect(user_response).to have_key(:errors)
         end

         it "renders the json errors on whye the user could not be created" do
           user_response = JSON.parse(response.body, symbolize_names: true)
           expect(user_response[:errors][:email]).to include "is invalid"
         end

         it {  expect(response.response_code).to eq(422) }
       end
      end

      describe "DELETE #destroy" do
        before(:each) do
          @user = FactoryBot.create :user
          delete :destroy, params: { id: @user.id }, format: :json
        end

        it { expect(response.response_code).to eq(204) }
      end
    end
    \end{lstlisting}
  \end{scriptsize}

  Comme vous pouvez le voir, il y a beaucoup de code dupliqué. Deux possibilité de factorisation sont:


  \begin{itemize}
    \item La méthode JSON.parse peut être encapsulée sur une méthode (Section \ref{sec:refactoring_json_response}).
    \item Le paramètre format est envoyé à chaque demande (Section 4.2). Bien que ce ne soit pas une mauvaise pratique, il est préférable de gérer le type de réponse à l'aide des en-têtes.
  \end{itemize}

  Ajoutons donc une méthode pour gérer la réponse JSON. Mais avant de continuer, et si vous avez suivi le tutoriel, vous savez peut-être que nous créons une branche pour chaque chapitre. Alors faisons-le:

  \begin{scriptsize}
  \begin{lstlisting}[language=bash]
  $ git checkout -b chapter4
  \end{lstlisting}
  \end{scriptsize}

  \section{Refactorisation de la réponse JSON}\label{sec:refactoring_json_response}

    De retour à notre refactorisation, nous allons créer un fichier sous le répertoire \verb|spec/support|. Actuellement, nous n'avons pas ce répertoire, alors créons-le:

    \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ mkdir spec/support
    \end{lstlisting}
    \end{scriptsize}

    Ensuite, nous créons un fichier \verb|request_helpers.rb| sous le répertoire \verb|support| que nous venons de créer:

    \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ touch spec/support/request_helpers.rb
    \end{lstlisting}
    \end{scriptsize}

    Il est temps d'extraire la méthode \verb|JSON.parse| dans notre propre méthode de support (Listing \ref{lst:create_request_helpers}):

    \begin{scriptsize}
    \begin{lstlisting}[language=ruby, caption={Extraction de la méthode JSON.parse}, label={lst:create_request_helpers}]
    # spec/support/request_helpers.rb
    module Request
      module JsonHelpers
        def json_response
          @json_response ||= JSON.parse(response.body, symbolize_names: true)
        end
      end
    end
    \end{lstlisting}
    \end{scriptsize}

    Nous allons intégrer la méthode dans certains \verb|modules| afin de garder notre code bien organisé. L'étape suivante consiste à mettre à jour le fichier \verb|users_controller_spec.rb| pour utiliser la méthode. Un exemple rapide est présenté ci-dessous:


    \begin{scriptsize}
    \begin{lstlisting}[language=ruby]
    # spec/controllers/api/v1/users_controller_spec.rb

    # ...
    it 'returns the information about a reporter on a hash' do
      user_response = json_response # c'est cette ligne qui est maj
      expect(user_response[:email]).to eql @user.email
    end
    # ...
    \end{lstlisting}
    \end{scriptsize}

    C'est maintenant à votre tour de mettre à jour l'ensemble du fichier!

    Si vous essayez maintenant d'exécuter vos tests avec \verb|bundle exec rspec spec/controllers| vous allez avoir une erreur. C'est normal. La méthode \verb|json_response| n'est pas chargée dans le fichier \verb|rails_helper.rb|. Il faut donc modifier un peu notre \verb|rails_helper| qui s'occuppe de configurer nos tests:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Ajout des méthodes de request\_helpers.rb}]
      # spec/rails_helper.rb

      # chargement de tous les fichiers Ruby dans le dossier spec/support
      Dir[Rails.root.join('spec', 'support', '**', '*.rb')].each do |f|
        require f
      end

      RSpec.configure do |config|
        #  ...
        # Nous devons aussi inclure ces methodes dans rspec en tant
        # qu'aides de type controleur
        config.include Request::JsonHelpers, :type => :controller
        #  ...
      end
      \end{lstlisting}
    \end{scriptsize}

    Une fois le fichier modifié, nos tests devraient passer à nouveau! \textit{Commitons} donc ceci avant d'aller plus loin:

    \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ git add .
    $ git commit -m "Refactors the json parse method"
    \end{lstlisting}
    \end{scriptsize}

  \section{Factoriser le paramètre du format}

    Nous voulons supprimer les paramètres \verb|format: :json| envoyé sur chaque requête. Pour le faire c'est extrêmement facile. Il suffit simplement d'ajouter une ligne à notre fichier \verb|users_controller_spec.rb|:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # spec/controllers/api/v1/users_controller_spec.rb

      RSpec.describe Api::V1::UsersController, type: :controller do
        before(:each) { request.headers['Accept'] = "application/vnd.marketplace.v1, application/json" }
      \end{lstlisting}
    \end{scriptsize}

    En ajoutant cette ligne, vous pouvez maintenant supprimer tous les paramètres de \verb|format| que nous envoyions sur chaque requête!

    Attendez, ce n'est pas encore fini! Nous pouvons ajouter un autre en-tête à notre demande qui nous aidera à décrire les données que nous attendons du serveur à livrer. Nous pouvons y parvenir assez facilement en ajoutant une ligne supplémentaire spécifiant l'en-tête \verb|Content-Type|:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # spec/controllers/api/v1/users_controller_spec.rb

      RSpec.describe Api::V1::UsersController, type: :controller do
        before(:each) { request.headers['Accept'] = "application/vnd.marketplace.v1, application/json" }
        before(:each) { request.headers['Content-Type'] = 'application/json' }
      \end{lstlisting}
    \end{scriptsize}

    Et encore une fois,nous lançons nos tests pour voir si tout est bon:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ bundle exec rspec spec/controllers/api/v1/users_controller_spec.rb
      .............

      Finished in 1.44 seconds (files took 0.4734 seconds to load)
      13 examples, 0 failures
      \end{lstlisting}
    \end{scriptsize}

    Et comme à chaque fois, c'est le bon moment pour \verb|commit|:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ git commit -am "Factorize format for unit tests"
      \end{lstlisting}
    \end{scriptsize}

  \section{Factoriser le paramètre du format}

    Je suis vraiment satisfait du code que nous avons obtenu, mais nous pouvons faire encore mieux. La première chose qui me vient à l'esprit est de regrouper les 3 en-têtes personnalisés ajoutés avant chaque requête:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # spec/controllers/api/v1/users_controller_spec.rb
      #...

      before(:each) { request.headers['Accept'] = "application/vnd.marketplace.v1, application/json" }
      before(:each) { request.headers['Content-Type'] = 'application/json' }
      \end{lstlisting}
    \end{scriptsize}

    C'est bien mais on peut mieux faire. En effet, nous devrons ajouter ces cinq lignes de code pour chaque fichier. Si pour une raison quelconque, nous changeons le type de réponse en XML, nous devrions modifier les cinq fichiers manuellement. Ne vous inquiétez pas, je vais vous proposer une solution qui résoudra tous ces problèmes.

    Tout d'abord, nous devons étendre notre fichier \verb|request_helpers.rb| pour inclure un autre module que j'ai nommé \verb|HeadersHelpers| et qui aura les méthodes nécessaires pour gérer ces headers personnalisés (Listing \ref{lst:add_headers_to_request_helpers})

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Ajout d'un helper pour spécifier les headers des tests}, label={lst:add_headers_to_request_helpers}]
      # spec/support/request_helpers.rb

      module Request
        # ...

        module HeadersHelpers
          def api_header(version = 1)
            request.headers['Accept'] = "application/vnd.marketplace.v#{version}"
          end

          def api_response_format(format ='application/json')
            request.headers['Accept'] = "#{request.headers['Accept']}, #{format}"
            request.headers['Content-Type'] = format
          end

          def include_default_accept_headers
            api_header
            api_response_format
          end
        end
      end
      \end{lstlisting}
    \end{scriptsize}

    Comme vous pouvez le voir, j'ai divisé les appels en deux méthodes: une pour définir l'en-tête API et l'autre pour définir le format de réponse. J'ai aussi écrit une méthode (\verb|include_default_accept_headers|) pour appeler les deux.

    Et maintenant, pour appeler cette méthode avant chacun de nos test, nous pouvons ajouter le \verb|before| dans le bloc \verb|Rspec.configure| du fichier \verb|rails_helper.rb| (Listing \ref{lst:complete_spec_rails_helper}), et nous assurer de spécifier le type au \verb|:controller| car nous ne le faisons que pour les tests unitaires concernant les controlleurs.

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # spec/rails_helper.rb

      # ...

      RSpec.configure do |config|
        # ...
        config.include Request::HeadersHelpers, :type => :controller
        config.before(:each, type: :controller) do
          include_default_accept_headers
        end

        # ...
      end
      \end{lstlisting}
    \end{scriptsize}

    Après avoir ajouté ces lignes, nous pouvons supprimer les \verb|before| avant sur le fichier \verb|users_controller_spec.rb| et vérifier que nos tests passent toujours.

    Vous pouvez consulter la version complète du fichier \verb|spec_helper.rb| ci-dessous (Listing \ref{lst:complete_spec_rails_helper}):

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={La version complète de la configuration de Rspec après la factorisation}, label={lst:complete_spec_rails_helper}]
      # spec/rails_helper.rb

      require 'spec_helper'
      ENV['RAILS_ENV'] ||= 'test'
      require File.expand_path('../../config/environment', __FILE__)
      # Prevent database truncation if the environment is production
      abort("The Rails environment is running in production mode!") if Rails.env.production?
      require 'rspec/rails'

      Dir[Rails.root.join('spec', 'support', '**', '*.rb')].each { |f| require f }

      begin
        ActiveRecord::Migration.maintain_test_schema!
      rescue ActiveRecord::PendingMigrationError => e
        puts e.to_s.strip
        exit 1
      end

      RSpec.configure do |config|
        config.fixture_path = "#{::Rails.root}/spec/fixtures"

        config.use_transactional_fixtures = true

        config.include Devise::Test::ControllerHelpers, type: :controller
        config.include Request::JsonHelpers, :type => :controller
        config.include Request::HeadersHelpers, :type => :controller
        config.before(:each, type: :controller) do
          include_default_accept_headers
        end


        config.infer_spec_type_from_file_location!

        config.filter_rails_from_backtrace!
      end
      \end{lstlisting}
    \end{scriptsize}

    Et bien maintenant je suis satisfait du code. \textit{Comittons} nos changements:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ git commit -am "Refactors test headers for each request"
      \end{lstlisting}
    \end{scriptsize}


    Rappelez-vous que vous pouvez revoir le code jusqu'à ce point dans le \href{https://github.com/madeindjs/market_place_api}{dépôt github}.

  \section{Conclusion}

    Pour finir ce chapitre, bien qu'il ait été court, c'était une étape cruciale car cela nous aidera à écrire des tests plus rapides. Au chapitre \ref{chapter:5}, nous ajouterons le mécanisme d'authentification que nous utiliserons à travers l'application ainsi que la restriction de l'accès à certaines actions.

\chapter{Authentification des utilisateurs}\label{chapter:5}

  Cela fait longtemps que vous avez commencé. J'espère que vous appréciez ce voyage autant que moi. Au chapitre 4, nous avons refactorisé notre suite de tests et, comme nous n'avons pas ajouté beaucoup de code, cela n'a pas pris trop de temps. Si vous avez sauté ce chapitre, je vous recommande de le lire, car nous allons utiliser certaines méthodes dans les chapitres à venir.

  Vous pouvez cloner le projet jusqu'ici:

  \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ git clone --branch chapitre_4 https://github.com/madeindjs/market_place_api
    \end{lstlisting}
  \end{scriptsize}

  Dans ce chapitre, les choses vont devenir très intéressantes. Nous allons mettre en place notre mécanisme d'authentification. À mon avis, ce sera l'un des chapitres les plus intéressants car nous allons introduire beaucoup de nouveaux concepts. A la fin, vous aurez un système d'authentification simple mais puissant. Ne paniquez pas, nous y arriverons.

  Commençons par le commencement. Comme d'habitude quand nous commençons un nouveau chapitre, nous allons créer une nouvelle branche:

  \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ git checkout -b chapter5
    \end{lstlisting}
  \end{scriptsize}

  \section{Session sans état and sign in failure}

    Avant d'aller plus loin, quelque chose doit être clair: une API ne gère pas les sessions. Si vous n'avez pas d'expérience dans la création de ce genre d'applications, cela peut paraître un peu fou. Une API doit être sans état. Ce qui signifie par définition qu'il s'agit d'une API qui fournit une réponse après votre demande et qui ne nécessite aucune autre attention. Cela à pour conséquence qu'aucun état antérieur ou futur n'est nécessaire pour que le système fonctionne.

    Le processus d'authentification de l'utilisateur via une API est très simple:

    \begin{itemize}
      \item Le client demande une ressource de sessions avec les informations d'identification correspondantes (généralement un e-mail et un mot de passe).
      \item Le serveur renvoie la ressource utilisateur avec son jeton d'authentification correspondant.
      \item Pour chaque page qui nécessite une authentification, le client doit envoyer ce jeton d'authentification.
    \end{itemize}

    Dans cette section et la suivante, nous nous concentrerons sur la construction d'un contrôleur de sessions avec ses actions correspondantes. Nous compléterons ensuite le flux de demandes en ajoutant l'accès d'autorisation nécessaire.

    \subsection{Le jeton d'authentification}

      Avant de procéder à la logique sur le contrôleur de sessions, nous devons d'abord ajouter le champ du jeton d'authentification au modèle utilisateur. Ensuite, il faudra  ajouter une méthode pour définir ce jeton.

      Nous començons donc par générer un fichier de migration:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ rails generate migration add_authentification_token_to_users auth_token:string
        \end{lstlisting}
      \end{scriptsize}

      Comme une bonne pratique, j'aime configurer les valeurs \verb|String| à une chaîne vide. Et dans ce cas, nous allons ajouter un index avec une condition d'unicité. Ainsi, nous garantissons qu'il n'y a pas d'utilisateurs avec le même jeton. Alors faisons-le:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby]
        # db/migrate/20181114134521_add_authentification_token_to_users.rb
        class AddauthentificationTokenToUsers < ActiveRecord::Migration[5.2]
          def change
            add_column :users, :auth_token, :string, default: ''
            add_index :users, :auth_token, unique: true
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      Ensuite, nous exécutons les migrations pour ajouter le champ et préparer la base de données de test:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ rake db:migrate
        == 20181114134521 AddauthentificationTokenToUsers: migrating ====================
        -- add_column(:users, :auth_token, :string, {:default=>""})
           -> 0.0004s
        -- add_index(:users, :auth_token, {:unique=>true})
           -> 0.0010s
        == 20181114134521 AddauthentificationTokenToUsers: migrated (0.0016s) ===========
        \end{lstlisting}
      \end{scriptsize}

      Il est maintenant temps d'ajouter quelques tests de réponse et d'unicité à nos spécifications de modèle utilisateur (Listing \ref{lst:add_uniq_test_to_user_spec}).

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Ajout des tests de réponse et d'unicité}, label={lst:add_uniq_test_to_user_spec}]
        # spec/models/user_spec.rb

        RSpec.describe User, type: :model do
          # ...

          it { should respond_to(:auth_token) }
          it { should validate_uniqueness_of(:auth_token)}
        end
        \end{lstlisting}
      \end{scriptsize}

      Nous passons ensuite au fichier \verb|user.rb| et ajoutons le code nécessaire pour faire passer nos tests:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby]
        # app/models/user.rb

        class User < ApplicationRecord
          validates :auth_token, uniqueness: true
          # ...
        end
        \end{lstlisting}
      \end{scriptsize}

      Maintenant nous allons implémenter une méthode qui générera un jeton d'authentification unique pour chaque utilisateur afin de les authentifier plus tard via l'API. Construisons donc d'abord les tests (Listing \ref{lst:test_token_to_user_spec}).

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Test de la génération automatique du jeton d'authentification}, label={lst:test_token_to_user_spec}]
        # spec/models/user_spec.rb

        RSpec.describe User, type: :model do
          # ...

          describe "#generate_authentification_token!" do
            it "generates a unique token" do
              @user.generate_authentification_token!
              expect(@user.auth_token).not_to be_nil
            end

            it "generates another token when one already has been taken" do
              existing_user = FactoryBot.create(:user, auth_token: "auniquetoken123")
              @user.generate_authentification_token!
              expect(@user.auth_token).not_to eql existing_user.auth_token
            end
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      \begin{tcolorbox}
        Afin d'utilliser la méthode \verb|validate_uniqueness_of|, il faut installer la gem \verb|shoulda-matchers|. Pour cela, nous rajoutons la gem dans le \verb|Gemfile|:

        \begin{scriptsize}
          \begin{lstlisting}[language=ruby]
          # Gemfile

          # ...
          group :test do
            # ...
            gem 'shoulda-matchers'
          end
          \end{lstlisting}
        \end{scriptsize}

        Et nous la chargeons dans le fichier \verb|rails_helper.rb|:

        \begin{scriptsize}
          \begin{lstlisting}[language=ruby]
          # spec/rails_helper.rb

          # ...
          RSpec.configure do |config|
            # ...
            RSpec.configure do |config|
              config.include(Shoulda::Matchers::ActiveModel, type: :model)
              config.include(Shoulda::Matchers::ActiveRecord, type: :model)
            end
          end
          \end{lstlisting}
        \end{scriptsize}
      \end{tcolorbox}

      Les tests échouent comme prévu:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ bundle exec rspec spec/models/user_spec.rb
        .......FF

        Failures:

          1) User#generate_authentification_token! generates a unique token
             Failure/Error: @user.generate_authentification_token!

             NoMethodError:
               undefined method `generate_authentification_token!' for #<User:0x0000558948d23760>
             # ./spec/models/user_spec.rb:23:in `block (3 levels) in <top (required)>'

          2) User#generate_authentification_token! generates another token when one already has been taken
             Failure/Error: @user.generate_authentification_token!

             NoMethodError:
               undefined method `generate_authentification_token!' for #<User:0x0000558948d18720>
             # ./spec/models/user_spec.rb:29:in `block (3 levels) in <top (required)>'
        \end{lstlisting}
      \end{scriptsize}

      C'est normal, la méthode \verb|generate_authentification_token| n'existe pas encore. Nous allons l'implémenter et l'accrocher à l'appel \verb|before_create|  pour garantir que chaque utilisateur a un jeton d'authentification. Pour créer le token il y a beaucoup de solutions. Je vais utiliser la méthode \verb|friendly_token| qui conçoit déjà des jetons mais je pourrais aussi le faire avec la méthode \verb|hex| de la classe \verb|SecureRandom|.

      Le code pour générer le jeton est assez simple:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby]
        # app/models/user.rb
        class User < ApplicationRecord
          before_create :generate_authentification_token!
          # ...

          def generate_authentification_token!
            begin
              self.auth_token = Devise.friendly_token
            end while self.class.exists?(auth_token: auth_token)
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      Après avoir fait cela, nous tests devraient passer:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ bundle exec rspec spec/models/user_spec.rb
        .........

        Finished in 0.05079 seconds (files took 0.49029 seconds to load)
        9 examples, 0 failures
        \end{lstlisting}
      \end{scriptsize}

      Comme d'habitude, nous \textit{commitons} nos modifications:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ git add .
        $ git commit -m "Adds user authentification token"
        \end{lstlisting}
      \end{scriptsize}

    \subsection{Le contrôlleur de session}

      De retour au contrôleur de sessions. Les actions que nous allons implémenter seront gérées en tant que services RESTful: la connexion sera gérée par une demande POST à l'action \verb|create| (Section 5.1.2.1) et la déconnexion par une demande DELETE à l'action \verb|destroy| (Rappel pour la liste \ref{desc:http_verbs} des verbes HTTP).

      Pour commencer, nous allons commencer par créer le contrôleur de sessions:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ rails generate controller sessions
        \end{lstlisting}
      \end{scriptsize}

      Ensuite, nous devons déplacer les fichiers dans le répertoire \verb|api/v1|, à la fois pour le dossier \verb|app| mais aussi pour le dossier \verb|spec|:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ mv app/controllers/sessions_controller.rb app/controllers/api/v1
        $ mv spec/controllers/sessions_controller_spec.rb spec/controllers/api/v1
        \end{lstlisting}
      \end{scriptsize}

      Après avoir déplacé les fichiers, nous devons les mettre à jour pour qu'ils correspondent à la structure des répertoires que nous avons actuellement. Comme le montrent les listes \ref{lst:add_namespace_for_sessions_controller} et \ref{lst:add_namespace_for_sessions_controller_spec}.

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Ajout des Namespaces pour le contrôlleur de sessions}, label={lst:add_namespace_for_sessions_controller}]
        # app/controllers/api/v1/sessions_controller.rb
        class Api::V1::SessionsController < ApplicationController
        end
        \end{lstlisting}
      \end{scriptsize}

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Ajout des Namespaces pour le test du contrôlleur de sessions}, label={lst:add_namespace_for_sessions_controller_spec}]
        # spec/controllers/api/v1/sessions_controller_spec.rb
        # ...

        RSpec.describe Api::V1::SessionsController, type: :controller do
        end
        \end{lstlisting}
      \end{scriptsize}

      \subsubsection{Connexion réussie}

        Notre premier arrêt sera l'action de création. Mais d'abord, et comme d'habitude, générons nos tests (Listing 5.5).

        \begin{scriptsize}
          \begin{lstlisting}[language=ruby, caption={Création des tests du contrôlleur de sessions}, label={lst:add_sessions_controller_spec_for_create}]
          # spec/controllers/api/v1/sessions_controller_spec.rb
          # ...

          RSpec.describe Api::V1::SessionsController, type: :controller do
            describe 'POST #create' do
              before(:each) do
                @user = FactoryBot.create :user
              end

              context 'when the credentials are correct' do
                before(:each) do
                  post :create, params: {
                    session: { email: @user.email, password: '12345678' }
                  }
                end

                it 'returns the user record corresponding to the given credentials' do
                  @user.reload
                  expect(json_response[:auth_token]).to eql @user.auth_token
                end

                it { expect(response.response_code).to eq(200) }
              end

              context 'when the credentials are incorrect' do
                before(:each) do
                  post :create, params: {
                    session: { email: @user.email, password: 'invalidpassword' }
                  }
                end

                it 'returns a json with an error' do
                  expect(json_response[:errors]).to eql 'Invalid email or password'
                end

                it { expect(response.response_code).to eq(422) }
              end
            end
          end
          \end{lstlisting}
        \end{scriptsize}

        Les tests sont assez simples. Nous renvoyons simplement l'utilisateur au format JSON si les informations d'identification sont correctes, sinon nous envoyons simplement un JSON avec le message d'erreur.

        Nous devons maintenant implémenter le code pour que nos tests passent (Listing \ref{lst:sessions_controller_create}). Mais avant cela, nous ajouterons les routes à notre fichier \verb|route.rb| (Listing \ref{lst:add_sessions_routes}).

        \begin{scriptsize}
          \begin{lstlisting}[language=ruby, caption={Ajout des routes pour les sessions}, label={lst:add_sessions_routes}]
          # config/routes.rb
          require 'api_constraints'

          Rails.application.routes.draw do
            # ...
            resources :sessions, :only => [:create, :destroy]
          end
          \end{lstlisting}
        \end{scriptsize}

        \begin{scriptsize}
          \begin{lstlisting}[language=ruby, caption={Implémentation de la méthode SessionsController\#create}, label={lst:sessions_controller_create}]
          # app/controllers/api/v1/sessions_controller.rb
          class Api::V1::SessionsController < ApplicationController
            def create
              user_password = params[:session][:password]
              user_email = params[:session][:email]
              user = user_email.present? && User.find_by(email: user_email)

              if user.valid_password? user_password
                sign_in user
                user.generate_authentification_token!
                user.save
                render json: user, status: 200, location: [:api, user]
              else
                render json: { errors: 'Invalid email or password' }, status: 422
              end
            end
          end
          \end{lstlisting}
        \end{scriptsize}

        Avant d'exécuter nos tests, il est nécessaire d'ajouter les \verb|helpers| dans le fichier \verb|rails_helper.rb|:

        \begin{scriptsize}
          \begin{lstlisting}[language=ruby]
          # spec/rails_helper.rb
          require 'api_constraints'

          RSpec.configure do |config|
            # ...
            config.include Devise::Test::ControllerHelpers, :type => :controller
          end
          \end{lstlisting}
        \end{scriptsize}

        Et maintenant nous pouvons lancer nos tests:

        \begin{scriptsize}
          \begin{lstlisting}[language=bash]
          $ bundle exec rspec spec/controllers/api/v1/sessions_controller_spec.rb
          ....

          Finished in 0.06515 seconds (files took 0.49218 seconds to load)
          4 examples, 0 failures
          \end{lstlisting}
        \end{scriptsize}

        Ourah! Faisons un \verb|commit|:

        \begin{scriptsize}
          \begin{lstlisting}[language=bash]
          $ git add .
          $ git commit -m "Adds sessions controller create action"
          \end{lstlisting}
        \end{scriptsize}

      \subsubsection{Déconnexion}

        Nous avons maintenant l'entrée de l'API. Il est temps de construire un point de sortie. Vous vous demandez peut-être pourquoi, puisque nous ne gérons pas les sessions et qu'il n'y a rien à détruire. Et c'est bien vrai! Lors d'une destruction, nous devons mettre à jour le jeton d'authentification pour que ce dernier devienne inutile et ne puisse plus être utilisé.

        Il n'est en fait pas nécessaire d'inclure ce point final, mais j'aime l'inclure pour expirer les jetons d'authentification.

        Comme d'habitude, nous commençons par les tests (Listing \ref{lst:add_sessions_controller_spec_for_destroy}):

        \begin{scriptsize}
          \begin{lstlisting}[language=ruby, caption={Création des test de destruction des jetons d'authentification}, label={lst:add_sessions_controller_spec_for_destroy}]
          # spec/controllers/api/v1/sessions_controller_spec.rb
          # ...

          RSpec.describe Api::V1::SessionsController, type: :controller do
            # ...

            describe "DELETE #destroy" do

              before(:each) do
                @user = FactoryBot.create :user
                sign_in @user, store: false
                delete :destroy, params: { id: @user.auth_token }
              end

              it { expect(response.response_code).to eq(204) }

            end
          end
          \end{lstlisting}
        \end{scriptsize}

        Comme vous pouvez le voir le test est super simple! Maintenant nous avons juste besoin d'implémenter le code nécessaire pour faire passer nos tests (Listing \ref{lst:add_sessions_controller_for_destroy})

        \begin{scriptsize}
          \begin{lstlisting}[language=ruby, caption={Création de la méthode de destruction des jetons d'authentification}, label={lst:add_sessions_controller_for_destroy}]
          # app/controllers/api/v1/sessions_controller.rb
          class Api::V1::SessionsController < ApplicationController
            # ...
            def destroy
              user = User.find_by(auth_token: params[:id])
              user.generate_authentication_token!
              user.save
              head 204
            end
          end
          \end{lstlisting}
        \end{scriptsize}

        Ici, nous nous attendons à ce qu'un identifiant soit envoyé sur la requête (qui doit correspondre au jeton d'authentification de l'utilisateur).,Nous ajouterons une méthode \verb|current_user| pour gérer cela plus facilement lors de la section 5. Pour l'instant, \textit{commitons} notre avancée:

        \begin{scriptsize}
          \begin{lstlisting}[language=bash]
          $ git add .
          $ git commit -m "Adds destroy session action added"
          \end{lstlisting}
        \end{scriptsize}

  \section{Utilisateur connecté}

    Si vous avez déjà travaillé avec \href{https://github.com/plataformatec/devise}{devise}, vous connaissez sûrement déjà les méthodes générées pour gérer l'authentification ou bien pour obtenir l'utilisateur connecté (voir la \href{https://github.com/plataformatec/devise#getting-started}{documentation}).

    Dans notre cas, nous allons remplacer la méthode \verb|current_user| pour répondre à nos besoins. C'est-à-dire retrouver l'utilisateur gràce à son  jeton d'authentification qui envoyé sur chaque requête. Laissez moi clarifier ce point.

    Une fois que le client se connecte, l'API lui retourne son jeton d'authentification. A chaque fois que ce client demande une page protégée, nous devrons retrouver l'utilisateur à partir de ce jeton d'authentification que l'utilisateur aura passé en paramètre ou dans l'en-tête HTTP.

    Dans notre cas, nous utiliserons l'en-tête HTTP \verb|Authorization| qui est souvent utilisé pour ça. Personnellement, je le trouve que c'est la meilleur manière parce que cela donne un contexte à la requête sans polluer l'URL avec des paramètres supplémentaires.

    Quand il s'agit de l'authentification, j'aime ajouter toutes les méthodes associées dans un fichier séparé. Il suffit ensuite d'inclure le fichier dans le \verb|ApplicationController|. De cette façon, il est très facile à tester de manière isolée.

    Créeons-donc le fichier dans le répertoire \verb|controllers/concerns|:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ touch app/controllers/concerns/authenticable.rb
      \end{lstlisting}
    \end{scriptsize}

    Ensuite, créons un répertoire \verb|concerns| sous \verb|spec/controllers/| et un fichier \verb|authenticable_spec.rb| pour nos tests d'authentification:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ mkdir spec/controllers/concerns
      $ touch spec/controllers/concerns/authenticable_spec.rb
      \end{lstlisting}
    \end{scriptsize}

    Comme d'habitude, nous commençons par écrire nos tests. Dans ce cas, notre méthode \verb|current_user|, va chercher un utilisateur par le jeton d'authentification dans l'en-tête HTTP \verb|Authorization|.

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # spec/controllers/concerns/authenticable_spec.rb
      # ...

      class Authentication < ActionController::Base
        include Authenticable
      end


      RSpec.describe Authenticable do
        let(:authentication) { Authentication.new }
        subject { authentication }

        describe "#current_user" do
          before do
            @user = FactoryBot.create :user
            request.headers["Authorization"] = @user.auth_token
            authentication.stub(:request).and_return(request)
          end
          it "returns the user from the authorization header" do
            expect(authentication.current_user.auth_token).to eql @user.auth_token
          end
        end
      end
      \end{lstlisting}
    \end{scriptsize}
    \footnote{Si vous vous demandez \textquote{pourquoi diable avons-nous créé une classe d'authentification dans le fichier spec?}, La réponse est simple. Quand il s'agit de tester des modules, je trouve facile de les inclure dans une classe temporaire et de stub toutes les autres méthodes dont j'ai besoin plus tard, comme la requête montrée ci-dessus.}

    Notre test doit échouer. Implémentons donc le code pour qu'il passe (Listing \ref{lst:create_authenticable}):

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Implémentation de la méthode current\_user}, label={lst:create_authenticable}]
      # app/controllers/concerns/authenticable.rb
      module Authenticable
        # Devise methods overwrites
        def current_user
          @current_user ||= User.find_by(auth_token: request.headers['Authorization'])
        end
      end
      \end{lstlisting}
    \end{scriptsize}

    Maintenant notre test devrait passer:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ bundle exec rspec spec/controllers/concerns/authenticable_spec.rb
      .

      Finished in 0.0149 seconds (files took 0.49496 seconds to load)
      1 example, 0 failures
      \end{lstlisting}
    \end{scriptsize}

    Nous n'avons plus qu'à inclure le module \verb|Authenticable| dans la classe \verb|ApplicationController|:


    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # app/controllers/application_controller.rb
      class ApplicationController < ActionController::Base
        # Prevent CSRF attacks by raising an exception.
        # For APIs, you may want to use :null_session instead.
        protect_from_forgery with: :null_session

        include Authenticable
      end
      \end{lstlisting}
    \end{scriptsize}

    Et maintenant il est temps de \textit{commiter} nos changements:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ git add .
      $ git commit -m "Adds authenticable module for managing authentication methods"
      \end{lstlisting}
    \end{scriptsize}

  \section{Authentification avec le jeton}

    L'autorisation joue un rôle important dans la construction des applications car, contrairement à l'authentification qui permet d'identifier l'utilisateur, l'autorisation nous aide à définir ce qu'il a le droit de faire.

    Nous avons une route pour mettre à jour l'utilisateur mais il y a un problème: n'importe qui peut mettre à jour n'importe quel utilisateur. Dans cette section, nous allons mettre en œuvre une méthode qui exigera que l'utilisateur soit connecté afin d'empêcher tout accès non autorisé. Nous retournerons un message d'erreur JSON avec un code HTTP correspondant.

    Tout d'abord, nous allons ajouter quelques tests sur le fichier \verb|authenticable_spec.rb| pour la méthode \verb|authenticate_with_token| (Listing \ref{lst:add_authenticate_with_token_test}).

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, label={lst:add_authenticate_with_token_test}, caption={Test de l'authentification par la méthode de jeton}]
      # spec/controllers/concerns/authenticable_spec.rb
      # ...

      class Authentication < ActionController::Base
        include Authenticable
      end

      RSpec.describe Authenticable do

        # ...

        describe '#authenticate_with_token' do
          before do
            @user = FactoryBot.create :user
            authentication.stub(:current_user).and_return(nil)
            response.stub(:response_code).and_return(401)
            response.stub(:body).and_return({ 'errors' => 'Not authenticated' }.to_json)
            authentication.stub(:response).and_return(response)
          end

          it 'render a json error message' do
            expect(json_response[:errors]).to eql 'Not authenticated'
          end

          it { expect(response.response_code).to eq(401) }
        end
      end
      \end{lstlisting}
    \end{scriptsize}


    Comme vous pouvez le voir, nous utilisons à nouveau la classe Authentification et nous écrasons la requête et la réponse pour traiter la réponse attendue du serveur. Il est maintenant temps d'implémenter le code pour faire passer nos tests (Listing \ref{lst:add_authenticate_with_token}).

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, label={lst:add_authenticate_with_token}, caption={Ajout de l'authentification par la méthode de jeton}]
      # app/controllers/concerns/authenticable.rb
      module Authenticable

        # ...

        def authenticate_with_token!
          unless current_user.present?
            render json: { errors: 'Not authenticated' },
                   status: :unauthorized
          end
        end
      end
      \end{lstlisting}
    \end{scriptsize}

    A ce stade, nous venons de construire un mécanisme d'autorisation très simple pour empêcher les utilisateurs non signés d'accéder à l'API. Il suffit de mettre à jour le fichier \verb|users\_controller.rb| avec la méthode \verb|current_user| et d'empêcher l'accès avec la commande \verb|authenticate_with_token!|!

    \textit{Comitons} ces changements et continuons d'avancer:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ git commit -m "Adds the authenticate with token method to handle access to actions"
      \end{lstlisting}
    \end{scriptsize}

  \section{Autoriser les actions}

    Il est maintenant temps de mettre à jour notre fichier \verb|users_controller.rb| pour refuser l'accès à certaines actions. Nous allons aussi implémenter la méthode \verb|current_user| sur l'action \verb|update| et \verb|destroy| afin de s'assurer que l'utilisateur qui est connecté ne sera capable que de mettre à jour que ses données et qu'il ne pourra supprimer que (et uniquement) son compte.

    Nous allons commencer par l'action \verb|update| (Listing \ref{lst:use_current_user_on_users_update}). Nous n'irons plus chercher l'utilisateur par son identifiant mais par l' \verb|auth_token| sur l'en-tête \verb|Authorization| fourni par la méthode \verb|current_user|.

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, label={lst:use_current_user_on_users_update}, caption={Utilisation de la méthode current\_user pour l'action update}]
      # app/controllers/api/v1/users_controller.rb
      class Api::V1::UsersController < ApplicationController

        # ...

        def update
          # on change juste la methode ici
          user = current_user

          if user.update(user_params)
            render json: user, status: 200, location: [:api, user]
          else
            render json: { errors: user.errors }, status: 422
          end
        end

        # ...

      end
      \end{lstlisting}
    \end{scriptsize}

    Et comme vous pouvez vous y attendre, si nous exécutons les tests de notre \textit{controller} utilisateurs, ils devraient échouer:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rspec spec/controllers/api/v1/users_controller_spec.rb
      .......FFFFF.

      Failures:

        1) Api::V1::UsersController PUT/PATCH #update when is successfully updated renders the json representation for the updated user
           Failure/Error: if user.update(user_params)

           NoMethodError:
             undefined method `update' for nil:NilClass

         ...
      \end{lstlisting}
    \end{scriptsize}

    La solution est assez simple, il suffit d'ajouter l'en-tête \verb|Authorization| à la requête:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # spec/controllers/api/v1/users_controller_spec.rb

      # ...

      RSpec.describe Api::V1::UsersController, type: :controller do

        # ...

        describe 'PUT/PATCH #update' do
          context 'when is successfully updated' do
            before(:each) do
              @user = FactoryBot.create :user
              request.headers['Authorization'] = @user.auth_token
              patch :update, params: { id: @user.id, user: { email: 'newmail@example.com' } }, format: :json
            end

            # ...
          end

          context 'when is not created' do
            before(:each) do
              @user = FactoryBot.create :user
              request.headers['Authorization'] = @user.auth_token
              patch :update, params: { id: @user.id, user: { email: 'bademail.com' } }, format: :json
            end

            # ...
          end
        end

        # ...
      end
      \end{lstlisting}
    \end{scriptsize}

    Maintenant, les tests devraient passer. Mais attendez, quelque chose ne va pas, n'est-ce pas? Nous pouvons refactoriser la ligne que nous venons d'ajouter et la mettre dans le module \verb|HeadersHelpers| que nous construisons au chapitre \ref{chapter:4} (Listing \ref{lst:add_api_authorization_helper}):

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, label={lst:add_api_authorization_helper}, caption={Factorisation de l'initialisation de l'en-tête Authorization}]
      # spec/support/request_helpers.rb

      module Request
        # ...

        module HeadersHelpers
          # ...

          def api_authorization_header(token)
            request.headers['Authorization'] = token
          end
        end
      end
      \end{lstlisting}
    \end{scriptsize}

    Maintenant, chaque fois que nous avons besoin d'avoir l'utilisateur courant sur nos tests, nous appelons simplement la méthode \verb|api_authorization_header|. Je vous laisse le faire avec \verb|users_controller_spec.rb| pour la spécification de mise à jour:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # spec/controllers/api/v1/users_controller_spec.rb

      # ...

      RSpec.describe Api::V1::UsersController, type: :controller do

        # ...

        describe 'PUT/PATCH #update' do
          context 'when is successfully updated' do
            before(:each) do
              @user = FactoryBot.create :user
              api_authorization_header @user.auth_token
              patch :update, params: { id: @user.id, user: { email: 'newmail@example.com' } }, format: :json
            end

            # ...
          end

          context 'when is not created' do
            before(:each) do
              @user = FactoryBot.create :user
              api_authorization_header @user.auth_token
              patch :update, params: { id: @user.id, user: { email: 'bademail.com' } }, format: :json
            end

            # ...
          end
        end

        # ...
      end
      \end{lstlisting}
    \end{scriptsize}

    Pour l'action \verb|destroy|, nous ferons la même chose car nous devons juste nous assurer qu'un utilisateur est capable de se supprimer (Listing \ref{lst:add_current_user_to_users_destroy}):

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, label={lst:add_current_user_to_users_destroy}, caption={Mise à jour de l'action Users\#Destroy}]
      # app/controllers/api/v1/users_controller.rb
      class Api::V1::UsersController < ApplicationController

        # ...

        def destroy
          current_user.destroy
          head 204
        end

        # ...
      end
      \end{lstlisting}
    \end{scriptsize}

    Maintenant, pour le fichier de spécification et comme mentionné précédemment, nous avons juste besoin d'ajouter l'en-tête \verb|api_authorization_header|:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # spec/controllers/api/v1/users_controller_spec.rb

      # ...

      RSpec.describe Api::V1::UsersController, type: :controller do
        # ...

        describe 'DELETE #destroy' do
          before(:each) do
            @user = FactoryBot.create :user
            api_authorization_header @user.auth_token
            delete :destroy, params: { id: @user.id }
          end

          it { expect(response.response_code).to eq(204) }
        end
      end
      \end{lstlisting}
    \end{scriptsize}

    Tout nos tests devraient passer. La dernière étape de cette section consiste à ajouter les droits d'accès correspondants pour ces deux dernières actions.

    Il est courant de simplement empêcher les actions sur lesquelles l'utilisateur effectue des actions sur le modèle lui-même. Dans ce cas l'action \verb|update| et \verb|destroy|.

    Sur le \verb|users_controller.rb| nous devons filtrer certaines de ces actions pour empêcher l'accès (Listing \ref{lst:add_before_action_to_users}).

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Utilisation de la méthode before\_action pour le controlleur des utilisateurs}, label={lst:add_before_action_to_users}]
      # app/controllers/api/v1/users_controller.rb
      class Api::V1::UsersController < ApplicationController
        before_action :authenticate_with_token!, only: %i[update destroy]
        respond_to :json

        # ...
      end
      \end{lstlisting}
    \end{scriptsize}

    Nos tests devraient être encore bons. Et à partir de maintenant, chaque fois que nous voulons éviter qu'une action ne soit déclenchée, nous ajoutons simplement la méthode \verb|authenticate_with_token!| sur un hook \verb|before_action|.

    \textit{Comitons} tout ça:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ git add .
      $ git commit -m "Adds authorization for the users controller"
      \end{lstlisting}
    \end{scriptsize}

    Enfin, nous terminerons le chapitre en remaniant la méthode \verb|authenticate_with_token!|, C'est une petite amélioration mais cela rendra la méthode plus parlante. Vous comprendrez ce que je veux dire dans une minute (Listing \ref{lst:add_user_signed_in}), mais avant tout, ajoutons quelques tests.

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Création du test user\_signed\_in?}, label={lst:add_user_signed_in_test}]
      # spec/controllers/concerns/authenticable_spec.rb
      # ...

      # ...

      RSpec.describe Authenticable do
        # ...

        describe '#user_signed_in?' do
          context "when there is a user on 'session'" do
            before do
              @user = FactoryBot.create :user
              authentication.stub(:current_user).and_return(@user)
            end

            it { should be_user_signed_in }
          end

          context "when there is no user on 'session'" do
            before do
              @user = FactoryBot.create :user
              authentication.stub(:current_user).and_return(nil)
            end

            it { should_not be_user_signed_in }
          end
        end
      end
      \end{lstlisting}
    \end{scriptsize}

    Comme vous pouvez le voir, nous avons ajouté deux simples tests pour savoir si l'utilisateur est connecté ou non. Et comme je l'ai déjà dis, c'est juste pour la clarté visuelle. Mais continuons et ajoutons l'implémentation. (Liste \ref{lst:add_user_signed_in}):

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Implémetation de  user\_signed\_in?}, label={lst:add_user_signed_in}]
      # app/controllers/concerns/authenticable.rb
      module Authenticable
        # ...

        def authenticate_with_token!
          unless user_signed_in?
            render json: { errors: 'Not authenticated' },
                   status: :unauthorized
          end
        end

        def user_signed_in?
          current_user.present?
        end
      end
      \end{lstlisting}
    \end{scriptsize}

    Comme vous pouvez le voir, maintenant \verb|authenticate_with_token!| est plus facile à lire non seulement pour vous mais pour aussi pour les autres développeurs qui rejoignerons le projet. Cette approche a également un avantage secondaire: si vous voulez modifier ou améliorer la façon de valider, vous pouvez simplement le faire sur la méthode \verb|user_signed_in?|.

    Maintenant, nos tests devraient être tous verts:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rspec spec/controllers/concerns/authenticable_spec.rb
      .....

      Finished in 0.07415 seconds (files took 0.702 seconds to load)
      5 examples, 0 failures
      \end{lstlisting}
    \end{scriptsize}

    \textit{Comitons} tout ça:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ git add .
      $ git commit -m "Adds user_signed_in? method to know whether the user is logged in or not"
      \end{lstlisting}
    \end{scriptsize}

  \section{Conclusion}

    Vous l'avez fait! Vous êtes à mi-chemin! Ce chapitre a été long et difficile, mais c'est un grand pas en avant sur la mise en place d'un mécanisme solide pour gérer l'authentification utilisateur et nous grattons même la surface pour de simples règles d'autorisation.

    Dans le prochain chapitre, nous nous concentrerons sur la personnalisation de la sortie JSON pour l'utilisateur avec \verb|active_model_serializers| et l'ajout d'un modèle de produit en donnant à l'utilisateur la possibilité de créer un produit et le publier pour la vente.

\chapter{Produits des utilisateurs}\label{chapter:6}

  Au chapitre \ref{chapter:5}, nous avons implémenté le mécanisme d'authentification que nous allons utiliser tout au long de l'application. Pour l'instant, nous avons une implémentation très simple du modèle \verb|User|, mais le moment de vérité est venu où nous allons personnaliser la sortie JSON et ajouter une deuxième ressource : les produits utilisateurs. Ce sont les éléments que l'utilisateur vendra dans l'application, et par conséquent sera directement associé. Si vous êtes familier avec Rails, vous savez peut-être déjà de quoi je parle. Mais pour ceux qui ne le savent pas, nous allons associer le modèle \verb|User| au modèle \verb|Product| en utilisant les méthodes \verb|has_many| et \verb|belongs_to| de \textit{Active Record}.  (voir figure \ref{fig:data_model}).

  Dans ce chapitre, nous allons construire le modèle de \verb|Product| à partir de zéro, l'associer à l'utilisateur et créer les entrées nécessaires pour que tout client puisse accéder aux informations.

  Vous pouvez cloner le projet jusqu'à ce point:

  \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ git clone --branch chapter6 https://github.com/madeindjs/market_place_api
    \end{lstlisting}
  \end{scriptsize}

  Avant de commencer,et comme d'habitude quand nous commençons de nouvelles fonctionnalités, nous créons une nouvelle branche:

  \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ git checkout -b chapter6
    \end{lstlisting}
  \end{scriptsize}

  \section{Le modèle du produit}

    Nous commencerons d'abord par créer un modèle de \verb|Product| puis nous y ajouterons quelques validations et enfin nous l'associons au modèle \verb|User|. Comme le modèle \verb|User|, le \verb|Product| sera entièrement testé et sera automatiquement supprimé si l'utilisateur est supprimé.

    \subsection{Les foncdements du produit}

      Le modèle \verb|Product| aura besoin de plusieurs champs: un attribut \verb|price| pour le prix du produit, un booléen \verb|published| pour savoir si le produit est prêt à être vendu ou non, un \verb|title| pour définir un titre de produit sexy, et enfin et surtout un \verb|user_id| pour associer ce produit particulier à un utilisateur. Comme vous le savez peut-être déjà, nous le générons avec la commande \verb|rails generate|:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ rails generate model Product title:string price:decimal published:boolean user_id:integer:index
          invoke  active_record
          create    db/migrate/20181218064350_create_products.rb
          create    app/models/product.rb
          invoke    rspec
          create      spec/models/product_spec.rb
          invoke      factory_bot
          create        spec/factories/products.rb
        \end{lstlisting}
      \end{scriptsize}

      Comme vous pouvez le remarquer, nous avons également ajouté un \verb|index| à l'attribut \verb|user_id|. C'est une bonne pratique pour les clés d'association car cela optimise les requêtes de la base de données. Ce n'est pas obligatoire, mais je vous le recommande vivement.

      Le fichier de migration devrait ressembler à ceci:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby]
        # db/migrate/20181218064350_create_products.rb
        class CreateProducts < ActiveRecord::Migration[5.2]
          def change
            create_table :products do |t|
              t.string :title
              t.decimal :price
              t.boolean :published
              t.integer :user_id

              t.timestamps
            end
            add_index :products, :user_id
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      Notez que nous avons défini des valeurs par défaut pour tous les attributs à l'exception de \verb|user_id|, de cette façon nous gardons un haut niveau de cohérence dans notre base de données car nous ne traitons pas beaucoup de valeurs NULL.

      Ensuite, nous ajouterons quelques tests de base au modèle de produit. Nous nous assurerons simplement que l'objet répond aux champs que nous avons ajoutés, comme indiqué dans le listing \ref{lst:create_product_spec}:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Le premier test de notre modèle de produit}, label={lst:create_product_spec}]
        # spec/models/product_spec.rb
        # ...

        RSpec.describe Product, type: :model do
          let(:product) { FactoryBot.build :product }
          subject { product }

          it { should respond_to(:title) }
          it { should respond_to(:price) }
          it { should respond_to(:published) }
          it { should respond_to(:user_id) }
        end
        \end{lstlisting}
      \end{scriptsize}

      Il suffit ensuite de lancer les migrations:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ rake db:migrate
        \end{lstlisting}
      \end{scriptsize}

      Et maintenant nous pouvons nous assurer que les tests passent:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ rspec spec/models/product_spec.rb
        \end{lstlisting}
      \end{scriptsize}

      Bien que nos tests réussissent, nous avons besoin de faire un peu de travail au niveau de la \textit{factory} des produits. Pour l'instant, tout est codé en dur. Comme vous vous en souvenez, nous avons utilisé un \verb|Faker| pour falsifier les valeurs de nos modèles de tests (Listing \ref{lst:user_factory_with_attrs}). Il est donc temps de faire de même avec le modèle de \verb|Product|. Voir le listing \ref{lst:create_factories_products}:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Création de la factory pour le modèle produit}, label={lst:create_factories_products}]
        # spec/factories/products.rb
        FactoryBot.define do
          factory :product do
            title { FFaker::Product.product_name }
            price { rand * 100 }
            published { false }
            user_id { 1 }
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      Maintenant, chaque produit que nous créons ressemblera un peu plus à un vrai produit. Nous devons encore travailler sur le \verb|user_id| tel quel, mais nous y reviendrons à la section \ref{subsec:user_has_products}.

    \subsection{Validations des produits}

      Comme nous l'avons vu avec l'utilisateur, les validations sont une partie importante lors de la construction de tout type d'application. Cela nous permet d'empêcher toute donnée indésirable d'être enregistrée dans la base de données. Pour le produit, nous devons nous assurer, par exemple, que le prix est un nombre et qu'il n'est pas négatif.

      Une autre chose importante à propos de la validation, lorsque l'on travaille avec des associations, est de valider que chaque \verb|Product| a un \verb|User|. Donc, dans ce cas, nous devons valider la présence de l'\verb|user_id|. Dans Listing \ref{lst:add_presence_to_product_test} vous pouvez voir de quoi je parle.

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Ajout de tests de présences pour les produits}, label={lst:add_presence_to_product_test}]
        # spec/models/product_spec.rb
        # ...

        RSpec.describe Product, type: :model do
          # ...

          it { should validate_presence_of :title }
          it { should validate_presence_of :price }
          it { should validate_numericality_of(:price).is_greater_than_or_equal_to(0) }
          it { should validate_presence_of :user_id }
        end
        \end{lstlisting}
      \end{scriptsize}

      Il nous faut maintenant ajouter l'implémentation pour faire passer les tests:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby]
        # app/models/product.rb
        class Product < ApplicationRecord
          validates :title, :user_id, presence: true
          validates :price, numericality: { greater_than_or_equal_to: 0 }, presence: true
        end
        \end{lstlisting}
      \end{scriptsize}

      Les tests passent désormais:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ rspec spec/models/product_spec.rb
        ........

        Finished in 0.04173 seconds (files took 0.74322 seconds to load)
        8 examples, 0 failures
        \end{lstlisting}
      \end{scriptsize}

      \textit{Comitons} ces changements et continuons d'avancer:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ git add .
        $ git commit -m "Adds product model bare bones along with some validations"
        \end{lstlisting}
      \end{scriptsize}

    \subsection{Liaison des produits et des utilisateurs}\label{subsec:user_has_products}

      Dans cette section, nous allons construire l'association entre le produit et le modèle utilisateur. Nous avons déjà les champs nécessaires, nous avons donc juste besoin de mettre à jour quelques fichiers et nous serons prêts à commencer. Tout d'abord, nous devons modifier la \textit{factory} de \verb|Product| pour la relier à l'utilisateur. Alors comment faire?

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby]
        # spec/factories/products.rb
        FactoryBot.define do
          factory :product do
            title { FFaker::Product.product_name }
            price { rand * 100 }
            published { false }
            user
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      Comme vous pouvez le voir, nous venons de renommer l'attribut \verb|user_id| en \verb|user| et nous n'avons pas spécifié de valeur. FactoryBot est assez intelligent pour créer un objet \verb|user| pour chaque produit et les associer automatiquement. Maintenant nous devons ajouter quelques tests pour l'association (Listing \ref{lst:add_should_belong_to_user}):

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Ajout du test de l'association utilisateur au model du produit}, label={lst:add_should_belong_to_user}]
        # spec/models/product_spec.rb
        # ...

        RSpec.describe Product, type: :model do
          # ...

          it { should belong_to :user }
        end
        \end{lstlisting}
      \end{scriptsize}

      Comme vous pouvez le voir, le test que nous avons ajouté est très simple, grâce à la puissance des \textit{shoulda-matchers}. Nous poursuivons la mise en œuvre maintenant:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby]
        # app/models/product.rb
        class Product < ApplicationRecord
          belongs_to :user
          #...
        end
        \end{lstlisting}
      \end{scriptsize}

      N'oubliez pas de faire le test que nous avons ajouté juste pour vous assurer que tout va bien:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ rspec spec/models/product_spec.rb
        .........

        Finished in 0.08815 seconds (files took 0.75134 seconds to load)
        9 examples, 0 failures
        \end{lstlisting}
      \end{scriptsize}

      Actuellement, nous n'avons qu'une partie de l'association.  Mais comme vous vous en doutez peut-être déjà, nous devons ajouter une association \verb|has_many| au modèle \verb|User|.

      Tout d'abord, nous ajoutons le test sur le fichier \verb|user_spec.rb|:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby]
        # spec/models/user_spec.rb
        # ...

        RSpec.describe User, type: :model do
          # ...
          it { should have_many(:products) }
          # ...
        end
        \end{lstlisting}
      \end{scriptsize}

      L'implémentation sur le modèle utilisateur est extrêmement simple:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby]
        # app/models/user.rb
        class User < ApplicationRecord
          has_many :products
          # ...
        end
        \end{lstlisting}
      \end{scriptsize}

      Maintenant, si nous exécutons les tests de l'utilisateur, elles devraient toutes être correctes:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ rspec spec/models/user_spec.rb
        ..........

        Finished in 0.08411 seconds (files took 0.74624 seconds to load)
        10 examples, 0 failures
        \end{lstlisting}
      \end{scriptsize}

    \subsection{Supression en cascade}

      Ce que j'ai vu dans le code d'autres développeurs, lorsqu'ils travaillent avec des associations, c'est qu'ils oublient la destruction des dépendances entre les modèles. Ce que je veux dire par là, c'est que si un utilisateur est supprimé, les produits de l'utilisateur devraient l'être aussi.

      Donc pour tester cette interaction entre les modèles, nous avons besoin d'un utilisateur avec un des produits. Puis, nous supprimerons cet utilisateur en espérant que les produits disparaissent avec lui. Une implémentation simple ressemblerait à ceci:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby]
        products = user.products
        user.destroy
        products.each do |product|
          expect(Product.find(product.id)).to raise_error ActiveRecord::RecordNotFound
        end
        \end{lstlisting}
      \end{scriptsize}

      Nous sauvegardons d'abord les produits dans une variable pour un accès ultérieur, puis nous détruisons l'utilisateur et bouclons la variable des produits en nous attendant à ce que chacun des produits lance une exception. Tout mettre ensemble devrait ressembler au code dans Listing \ref{lst:create_destroy_user_spec}:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Test de suppression des produits liés aux utilisateurs}, label={lst:create_destroy_user_spec}]
        # spec/models/user_spec.rb
        # ...

        RSpec.describe User, type: :model do
          # ...

          describe '#products association' do
            before do
              @user.save
              3.times { FactoryBot.create :product, user: @user }
            end

            it 'destroys the associated products on self destruct' do
              products = @user.products
              @user.destroy
              products.each do |product|
                expect { Product.find(product.id) }.to raise_error ActiveRecord::RecordNotFound
              end
            end
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      Le code nécessaire pour rendre le code sur Listing \ref{lst:create_destroy_user_spec} à passer est juste une option sur la méthode d'association \verb|has_many|:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby]
        # app/models/user.rb
        class User < ApplicationRecord
          has_many :products, dependent: :destroy
          # ...
        end
        \end{lstlisting}
      \end{scriptsize}

      Avec ce code ajouté, tous nos tests devraient passer:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ rspec spec/
        ...........................................

        Finished in 0.44188 seconds (files took 0.8351 seconds to load)
        43 examples, 0 failures
        \end{lstlisting}
      \end{scriptsize}

      \textit{Comitons} ces changements et continuons d'avancer:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ git add .
        $ git commit -m "Finishes modeling the product model along with user associations"
        \end{lstlisting}
      \end{scriptsize}

  \section{Point d'entrée pour nos produits}

    Il est maintenant temps de commencer à construire les points d'entrée des produits. Pour l'instant, nous allons juste construire cinq actions REST et certaines d'entre elles seront imbriquées dans la ressource utilisateur. Dans le prochain chapitre, nous allons personnaliser la sortie JSON en implémentant la gemme \verb|active_model_serializers|.

    Nous devons d'abord créer le \verb|products_controller|, et nous pouvons facilement y parvenir avec la commande ci-dessous:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rails generate controller api/v1/products
      \end{lstlisting}
    \end{scriptsize}

    La commande ci-dessus va générer pas mal de fichiers qui nous permettre de commencer à travailler rapidement. Ce que je veux dire par là, c'est qu'il va générer le contrôleur et les fichiers de test déjà \textit{scopés} à la version 1 de l'API (Listing \ref{lst:generate_products_controller} et \ref{lst:generate_products_controller_spec}).

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Le controlleur des produits généré automatqiuement}, label={lst:generate_products_controller}]
      # app/controllers/api/v1/products_controller.rb
      class Api::V1::ProductsController < ApplicationController
      end
      \end{lstlisting}
    \end{scriptsize}

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Les test du controlleur des produits généré automatqiuement}, label={lst:generate_products_controller_spec}]
      # spec/controllers/api/v1/products_controller_spec.rb
      # ...

      RSpec.describe Api::V1::ProductsController, type: :controller do
      end
      \end{lstlisting}
    \end{scriptsize}

    En guise d'échauffement, nous allons commencer par construire l'action du \verb|show| pour le produit.

    \subsection{Action d'affichage d'un produit}

      Comme d'habitude, nous commençons par ajouter quelques test du contrôleur des produits (Listing \ref{lst:products_controller_spec_show}). La stratégie ici est très simple, il suffit de créer un seul produit et de s'assurer que la réponse du serveur est celle que nous attendons.

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Test d'affichage d'un produit}, label={lst:products_controller_spec_show}]
        # spec/controllers/api/v1/products_controller_spec.rb
        # ...

        RSpec.describe Api::V1::ProductsController, type: :controller do
          describe 'GET #show' do
            before(:each) do
              @product = FactoryBot.create :product
              get :show, params: { id: @product.id }
            end

            it 'returns the information about a reporter on a hash' do
              product_response = json_response
              expect(product_response[:title]).to eql @product.title
            end

            it { expect(response.response_code).to eq(200) }
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      Nous ajoutons ensuite le code pour faire passer le test:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby]
        # app/controllers/api/v1/products_controller.rb
        class Api::V1::ProductsController < ApplicationController
          def show
            render json: Product.find(params[:id])
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      Attendez! N'exécutez pas encore les tests. N'oubliez pas que nous devons ajouter la route au fichier \verb|routes.rb|:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby]
        # config/routes.rb
        require 'api_constraints'

        Rails.application.routes.draw do
          # ...
          namespace :api, defaults: { format: :json }, constraints: { subdomain: 'api' }, path: '/' do
            scope module: :v1, constraints: ApiConstraints.new(version: 1, default: true) do
              # ...
              resources :products, only: [:show]
            end
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      Maintenant, on s'assure que les tests passent:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ rspec spec/controllers/api/v1/products_controller_spec.rb
        ..

        Finished in 0.05474 seconds (files took 0.75052 seconds to load)
        2 examples, 0 failures
        \end{lstlisting}
      \end{scriptsize}

      Comme vous pouvez déjà le constater, les tests et l'implémentation sont très simples. En fait, cela ressemble beaucoup à ce que nous avons fait pour les utilisateurs.

    \subsection{Liste des produits}

      Il est maintenant temps de créer une entrée pour liste de produits, qui pourrait permettre d'afficher le catalogue de produits d'un marché par exemple. Pour ce point d'accès, nous n'exigeons pas que l'utilisateur soit connecté. Comme d'habitude, nous allons commencer à écrire quelques tests (Listing \ref{lst:create_index_products_controller_spec}):

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Test de l'affichage des produits}, label={lst:create_index_products_controller_spec}]
        # spec/controllers/api/v1/products_controller_spec.rb
        # ...

        RSpec.describe Api::V1::ProductsController, type: :controller do

          # ...

          describe 'GET #index' do
            before(:each) do
              4.times { FactoryBot.create :product }
              get :index
            end

            it 'returns 4 records from the database' do
              products_response = json_response
              expect(products_response).to have(4).items
            end

            it { expect(response.response_code).to eq(200) }
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      \begin{tcolorbox}
        Attention, la méthode \verb|have| que nous utilisons dance ce test par exemple:

        \begin{scriptsize}
          \begin{lstlisting}[language=ruby]
          expect(products_response[:products]).to have(4).items
          \end{lstlisting}
        \end{scriptsize}

        n'est plus disponnible depuis Rspec 3.0. Il faut donc installer une librairie supplémentaire:

        \begin{scriptsize}
          \begin{lstlisting}[language=ruby]
          # Gemfile
          # ...
          group :test do
            # ...
            gem 'rspec-collection_matchers', '~> 1.1'
          end
          \end{lstlisting}
        \end{scriptsize}


      \end{tcolorbox}

      Passons maintenant à la mise en œuvre, qui, pour l'instant, va être une triste méthode toutes classes (Listing \ref{lst:create_index_products_controller}):

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Méthode d'affichage des produits}, label={lst:create_index_products_controller}]
        # app/controllers/api/v1/products_controller.rb
        class Api::V1::ProductsController < ApplicationController
          def index
            render json: Product.all
          end

          #...
        end
        \end{lstlisting}
      \end{scriptsize}

      Et n'oubliez pas, vous devez ajouter la route correspondante dans le fichier \verb|config/routes.rb|:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby]
        resources :products, only: %i[show index]
        \end{lstlisting}
      \end{scriptsize}

      Dans les chapitres suivants, nous allons améliorer ce point d'entré et donner la possibilité de recevoir des paramètres pour les filtrer.

      \textit{Comitons} ces changements et continuons d'avancer:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ git add .
        $ git commit -m "Finishes modeling the product model along with user associations"
        \end{lstlisting}
      \end{scriptsize}

    \subsection{Création des produits}\label{subsec:create_products}

      Créer des produits est un peu plus délicat parce que nous aurons besoin d'une configuration supplémentaire pour donner une meilleure structure à ce point d'entré. La stratégie que nous suivrons est d'imbriquer les produits, dans les actions des utilisateurs. Ceci nous permettra d'avoir  un point d'entrée plus descriptif comme \verb|/users/:user_id/products|.

      Notre premier arrêt sera donc le fichier \verb|products_controller_spec.rb| (Listing \ref{lst:create_create_products_controller_spec}).

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Test de la création d'un produit}, label={lst:create_create_products_controller_spec}]
        # spec/controllers/api/v1/products_controller_spec.rb
        # ...

        RSpec.describe Api::V1::ProductsController, type: :controller do

          # ...

          describe 'POST #create' do
            context 'when is successfully created' do
              before(:each) do
                user = FactoryBot.create :user
                @product_attributes = FactoryBot.attributes_for :product
                api_authorization_header user.auth_token
                post :create, params: { user_id: user.id, product: @product_attributes }
              end

              it 'renders the json representation for the product record just created' do
                product_response = json_response
                expect(product_response[:title]).to eql @product_attributes[:title]
              end

              it { expect(response.response_code).to eq(201) }
            end

            context 'when is not created' do
              before(:each) do
                user = FactoryBot.create :user
                @invalid_product_attributes = { title: 'Smart TV', price: 'Twelve dollars' }
                api_authorization_header user.auth_token
                post :create, params: { user_id: user.id, product: @invalid_product_attributes }
              end

              it 'renders an errors json' do
                product_response = json_response
                expect(product_response).to have_key(:errors)
              end

              it 'renders the json errors on whye the user could not be created' do
                product_response = json_response
                expect(product_response[:errors][:price]).to include 'is not a number'
              end

              it { expect(response.response_code).to eq(422) }
            end
          end
        end
        \end{lstlisting}
      \end{scriptsize}


      Wow! Nous avons ajouté beaucoup de code. Si vous vous souvenez de la Section \ref{subsec:create_users}, les tests sont en fait les mêmes que ceux de la création de l'utilisateur exépté quelques changements mineurs. Rappelez-vous que nous avons cette route imbriquée, nous devons donc nous assurer d'envoyer le paramètre \verb|user_id| à chaque requête, comme vous pouvez le voir sur:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby]
        post :create, params: { user_id: user.id, product: @product_attributes }
        \end{lstlisting}
      \end{scriptsize}

      De cette façon, nous pouvons voir l'utilisateur et lui créer un produit qui lui est associé. Mais attendez il y a mieux, si nous adoptons cette approche, nous pouvons augmenter la portée de notre mécanisme d'autorisation. Dans ce cas, si vous vous souvenez, nous avons construit la logique pour obtenir l'utilisateur à partir de l'en-tête \verb|Authorization| et lui avons assigné une méthode \verb|current_user|. C'est donc assez facile à mettre en place en ajoutant simplement l'en-tête d'autorisation dans la requête et en récupérant l'utilisateur à partir de celui-ci. Alors faisons-le (Listing \ref{lst:create_create_products_controller}):

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Méthode de création des produits}, label={lst:create_create_products_controller}]
        # app/controllers/api/v1/products_controller.rb
        class Api::V1::ProductsController < ApplicationController
          before_action :authenticate_with_token!, only: [:create]

          # ...

          def create
            product = current_user.products.build(product_params)
            if product.save
              render json: product, status: 201, location: [:api, product]
            else
              render json: { errors: product.errors }, status: 422
            end
          end

          private

          def product_params
            params.require(:product).permit(:title, :price, :published)
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      Comme vous pouvez le voir, nous protégeons l'action de création avec la méthode \verb|authenticate_with_token!|, et sur l'action \verb|create| nous construisons le produit en associant  l'utilisateur courant.

      A ce stade, vous vous demandez peut-être s'il est vraiment nécessaire d'imbriquer l'action? Parce qu'en fait, nous n'utilisons pas vraiment le paramètre \verb|user_id| fournis de l'URL. Vous avez tout à fait raison, mon seul argument ici est qu'avec cette approche, la route est beaucoup plus descriptive de l'extérieur, car nous disons aux développeurs que pour créer un produit, il nous faut un utilisateur.

      Alors c'est vraiment à vous de décider comment vous voulez organiser vos routes et les exposer au monde. Ma façon n'est pas la seule et cela ne signifie pas non plus que c'est la bonne. En fait, je vous encourage à jouer avec différentes approches et choisir celle que vous trouvez le mieux.

      Une dernière chose avant de faire vos tests: la route nécessaire:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby]
        # config/routes.rb
        require 'api_constraints'

        Rails.application.routes.draw do
          devise_for :users
          # Api definition
          namespace :api, defaults: { format: :json }, constraints: { subdomain: 'api' }, path: '/' do
            scope module: :v1, constraints: ApiConstraints.new(version: 1, default: true) do
              resources :users, only: %i[show create update destroy] do
                resources :products, only: [:create]
              end
              resources :sessions, only: %i[create destroy]
              resources :products, only: %i[show index]
            end
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      Si vous faites les tests maintenant, ils devraient tous passer:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ rspec spec/controllers/api/v1/products_controller_spec.rb
        .........

        Finished in 0.21831 seconds (files took 0.75823 seconds to load)
        9 examples, 0 failures
        \end{lstlisting}
      \end{scriptsize}

    \subsection{Mise à jour des produits}

      J'espère que maintenant vous comprenez la logique pour construire les actions à venir. Dans cette section, nous nous concentrerons sur l'action de mise à jour qui fonctionnera de manière similaire à celle de création. Nous avons juste besoin d'aller chercher le produit dans la base de données et de le mettre à jour.

      Nous ajoutons d'abord l'action aux routes pour ne pas oublier plus tard:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        # config/routes.rb
        require 'api_constraints'

        Rails.application.routes.draw do
          devise_for :users
          # Api definition
          namespace :api, defaults: { format: :json }, constraints: { subdomain: 'api' }, path: '/' do
            scope module: :v1, constraints: ApiConstraints.new(version: 1, default: true) do
              resources :users, only: %i[show create update destroy] do
                resources :products, only: %i[create update]
              end
              resources :sessions, only: %i[create destroy]
              resources :products, only: %i[show index]
            end
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      Avant de commencer à coder certains tests je veux juste préciser que, de la même manière que pour l'action \verb|create|, nous allons délimiter le produit à l'utilisateur courant. Nous voulons nous assurer que le produit que nous mettons à jour appartient bien à l'utilisateur. Nous allons donc chercher ce produit dans l'association \verb|user.products| fournie par \textit{Active Record}.

      Tout d'abord, nous ajoutons quelques tests (Listing \ref{lst:update_index_products_controller_spec}):

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Test de mise à jour des produits}, label={lst:update_index_products_controller_spec}]
        # spec/controllers/api/v1/products_controller_spec.rb
        # ...

        RSpec.describe Api::V1::ProductsController, type: :controller do
          # ...

          describe 'PUT/PATCH #update' do
            before(:each) do
              @user = FactoryBot.create :user
              @product = FactoryBot.create :product, user: @user
              api_authorization_header @user.auth_token
            end

            context 'when is successfully updated' do
              before(:each) do
                patch :update, params: { user_id: @user.id, id: @product.id, product: { title: 'An expensive TV' } }
              end

              it 'renders the json representation for the updated user' do
                product_response = json_response
                expect(product_response[:title]).to eql 'An expensive TV'
              end

              it { expect(response.response_code).to eq(200) }
            end

            context 'when is not updated' do
              before(:each) do
                patch :update, params: { user_id: @user.id, id: @product.id, product: { price: 'two hundred' } }
              end

              it 'renders an errors json' do
                product_response = json_response
                expect(product_response).to have_key(:errors)
              end

              it 'renders the json errors on whye the user could not be created' do
                product_response = json_response
                expect(product_response[:errors][:price]).to include 'is not a number'
              end

              it { expect(response.response_code).to eq(422) }
            end
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      Les tests peuvent paraître complexes, mais en jetant un coup d'oeil, ils sont presque identiques à ceux des utilisateurs (Listing \ref{lst:add_spec_users_controller_update}). La seule différence ici étant que les routes sont imbriquées comme nous l'avons vu à la Section \ref{subsec:create_products}. Nous devons donc envoyer le \verb|user_id| comme paramètre.

      Maintenant implémentons le code pour faire passer nos tests avec succès (Listing \ref{lst:update_index_products_controller}):

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Implémentation de la mise à jour des produits}, label={lst:update_index_products_controller}]
        # app/controllers/api/v1/products_controller.rb
        class Api::V1::ProductsController < ApplicationController
          before_action :authenticate_with_token!, only: %i[create update]

          # ...

          def update
            product = current_user.products.find(params[:id])
            if product.update(product_params)
              render json: product, status: 200, location: [:api, product]
            else
              render json: { errors: product.errors }, status: 422
            end
          end

          # ...
        end
        \end{lstlisting}
      \end{scriptsize}

      Comme vous pouvez le constater, l'implémentation est assez simple. Nous allons simplement récuéré le produit auprès de l'utilisateur connecté et nous le mettons simplement à jour. Nous avons également ajouté cette action au \verb|before_action|, pour empêcher tout utilisateur non autorisé de mettre à jour un produit.

      Si on lance les tests, ils devraient passer:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ rspec spec/controllers/api/v1/products_controller_spec.rb
        ..............

        Finished in 0.24404 seconds (files took 0.75973 seconds to load)
        14 examples, 0 failures
        \end{lstlisting}
      \end{scriptsize}

    \subsection{Suppression des produits}

      Notre dernier arrêt pour les route des produits, sera l'action \verb|destroy|. Vous pouvez maintenant imaginer à quoi cela ressemblerait. La stratégie ici sera assez similaire à l'action de \verb|create| et \verb|update|. Ce qui signifie que nous allons imbriquer la route dans les ressources des utilisateurs, puis récupérer le produit auprès de l'association \verb|user.products| et enfin le supprimer en retournant un code 204.

      Recommençons par ajouter la route:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby]
        # config/routes.rb
        require 'api_constraints'

        Rails.application.routes.draw do
          # ...
          namespace :api, defaults: { format: :json }, constraints: { subdomain: 'api' }, path: '/' do
            scope module: :v1, constraints: ApiConstraints.new(version: 1, default: true) do
              resources :users, only: %i[show create update destroy] do
                resources :products, only: %i[create update destroy]
              end
              # ...
            end
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      Après cela, nous devons ajouter quelques tests comme indiqué dans le listing \ref{lst:create_destroy_products_controller_spec}:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Test de suppression des produits}, label={lst:create_destroy_products_controller_spec}]
        # spec/controllers/api/v1/products_controller_spec.rb
        # ...

        RSpec.describe Api::V1::ProductsController, type: :controller do
          # ...

          describe 'DELETE #destroy' do
            before(:each) do
              @user = FactoryBot.create :user
              @product = FactoryBot.create :product, user: @user
              api_authorization_header @user.auth_token
              delete :destroy, params: { user_id: @user.id, id: @product.id }
            end

            it { expect(response.response_code).to eq(204) }
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      Maintenant, ajoutons simplement le code nécessaire pour faire passer les tests (Listing \ref{lst:create_destroy_products_controller}):


      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Implémentation de suppression des produits}, label={lst:create_destroy_products_controller}]
        # app/controllers/api/v1/products_controller.rb
        class Api::V1::ProductsController < ApplicationController
          before_action :authenticate_with_token!, only: %i[create update destroy]

          # ...

          def destroy
            product = current_user.products.find(params[:id])
            product.destroy
            head 204
          end

          # ...
        end
        \end{lstlisting}
      \end{scriptsize}

      Comme vous pouvez le voir, l'implémentation fait le travail en trois lignes. Nous pouvons lancer les tests pour nous assurer que tout est bon.

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ rspec spec/controllers/api/v1/products_controller_spec.rb
        ...............

        Finished in 0.25959 seconds (files took 0.80248 seconds to load)
        15 examples, 0 failures
        \end{lstlisting}
      \end{scriptsize}

      Après cela, nous \textit{commitons} les changements.

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ git add .
        $ git commit -m "Adds the products create, update and destroy action nested on the user resources"
        \end{lstlisting}
      \end{scriptsize}

  \section{Remplir la base de données}

    Avant de continuer avec plus de code, remplissons la base de données avec de fausses données. Nous avons des usines qui devraient faire le travail à notre place. Alors utilisons-les.

    Tout d'abord, nous exécutons la commande de la console Rails à partir du Terminal:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rails console
      \end{lstlisting}
    \end{scriptsize}

    Nous créons ensuite un tas d'objets produits avec la gemme FactoryBot:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      Loading development environment (Rails 5.2.1)
      2.5.3 :001 > 20.times { FactoryBot.create :product }
      \end{lstlisting}
    \end{scriptsize}

    Oups, vous avez probablement des erreurs qui se sont produites:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      Traceback (most recent call last):
              3: from (irb):1
              2: from (irb):1:in `times'
              1: from (irb):1:in `block in irb_binding'
      NameError (uninitialized constant FactoryBot)
      \end{lstlisting}
    \end{scriptsize}

    C'est parce que nous utilisons la console sur l'environnement de développement. Mais ça n'a pas de sens avec notre Gemfile qui ressemble actuellement à ceci:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # Gemfile

      # ...
      group :test do
        gem 'factory_bot_rails'
        gem 'ffaker', '~> 2.10'
        gem 'rspec-collection_matchers', '~> 1.1'
        gem 'rspec-rails', '~> 3.8'
        gem 'shoulda-matchers'
      end
      \end{lstlisting}
    \end{scriptsize}

    Vous voyez où est le problème? Si vous faites attention, vous remarquerez que la gemme \verb|factory_bot_rails| n'est disponible que pour l'environnement de test et non pour le développement. Cela peut être corrigé très rapidement:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # Gemfile

      # ...
      group :development, :test do
        gem 'factory_bot_rails'
        gem 'ffaker', '~> 2.10'
      end

      group :test do
        # ...
      end
      \end{lstlisting}
    \end{scriptsize}

    Notez que nous avons déplacé la gemme \verb|ffaker| vers le groupe partagé comme nous l'utilisons à l'intérieur des usines que nous décrivons plus haut. Lancez maintenant la commande \verb|bundle| pour mettre à jour les bibliothèques. Alors construisez les produits que vous voulez comme ça:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rails console
      Loading development environment (Rails 5.2.1)
      2.5.3 :001 > 20.times { FactoryBot.create :product }
      \end{lstlisting}
    \end{scriptsize}

    Désormais, vous pourrez créer n'importe quel objet à partir d'usines, comme les utilisateurs, les produits, les commandes, etc.

    \textit{commitons} les changements!

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ git add .
      $ git commit -m "Updates test environment factory gems to work on development"
      \end{lstlisting}
    \end{scriptsize}

  \section{Conlusion}

    Dans le chapitre suivant, nous allons nous concentrer sur la personnalisation de la sortie des modèles utilisateur et produit à l'aide de la gemme \textit{active model serializers}. Elle nous permettra de filtrer facilement les attributs à afficher et à gérer les associations comme des objets embarqués par exemple.

\chapter{Modélisation du JSON}\label{chapter:7}

  Dans le chapitre \ref{chapter:6}, nous avons ajouté les produits à l'application et construit tous les routes nécessaires. Nous avons également associé un produit à un utilisateur et restreint certaines des actions de \verb|products_controller|.

  Maintenant, vous devriez être satisfait de tout ce travail. Mais nous avons encore du pain sur la planche. Actuellement, nous avons une sortie JSON qui n'est pas parfaite. La sortie JSON ressemble au Listing \ref{lst:products_json} or nous voulons un sortie correspondante au Listing \ref{lst:wanted_products_json}.

  \begin{scriptsize}
    \begin{lstlisting}[caption={Exemple de la sortie JSON actuelle pour la route products}, label={lst:products_json}]
    {
      "products": [
          {
              "id": 1,
              "title": "Tag Case",
              "price": "98.7761933800815",
              "published": false,
              "user_id": 1,
              "created_at": "2018-12-20T12:47:26.686Z",
              "updated_at": "2018-12-20T12:47:26.686Z"
          },
    \end{lstlisting}
  \end{scriptsize}

  \begin{scriptsize}
    \begin{lstlisting}[caption={Exemple d'une belle sortie JSON pour la route products}, label={lst:wanted_products_json}]
    {
      "products": [
          {
              "id": 1,
              "title": "Tag Case",
          },
    \end{lstlisting}
  \end{scriptsize}

  Dans ce chapitre, nous allons personnaliser la sortie JSON en utilisant la gemme \verb|active_model_serializers|. Pour plus d'informations vous pouvez consulter le \href{https://github.com/rails-api/active_model_serializers}{répertoire sur github}. Je vais couvrir quelques points ici, de l'installation à l'implémentation, mais je vous recommande de jetter un oeuil à la documentation.

  Vous pouvez cloner le projet jusqu'à ce point avec:

  \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ git clone https://github.com/madeindjs/market_place_api.git -b chapter6
    \end{lstlisting}
  \end{scriptsize}

  Commençons une nouvelle branche pour ce chapitre:

  \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ git checkout -b chapter7
    \end{lstlisting}
  \end{scriptsize}

  \section{Mise en place de la gemme}

    Si vous avez suivi le tutoriel depuis le début, vous devriez déjà avoir la gemme installée. Mais au cas où vous auriez atterri ici, je vais vous guider dans l'installation.

    Ajoutez la ligne suivante à votre \verb|Gemfile|:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # Gemfile
      # ...
      gem 'active_model_serializers', '~> 0.10.8'
      \end{lstlisting}
    \end{scriptsize}

    Exécutez la commande d'installation du paquet pour installer la gemme ... et c'est tout! Vous devriez être prêt à continuer avec ce tutoriel.

  \section{Serialiser l'utilisateur}\label{sec:serialize_user}

    Nous devons d'abord ajouter un fichier \verb|user_serializer|. Nous pouvons le faire manuellement, mais la gemme fournit une interface en ligne de commande pour le faire:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rails generate serializer user
          create  app/serializers/user_serializer.rb
      \end{lstlisting}
    \end{scriptsize}

    Ceci a créé un fichier appelé \verb|user_serializer.rb| sous le répertoire \verb|app/serializers|, qui devrait ressembler à celui de Listing \ref{lst:generated_user_serializer}:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Sérialsateur d'utilisateurs généré}, label={lst:generated_user_serializer}]
      # app/serializers/user_serializer.rb
      class UserSerializer < ActiveModel::Serializer
        attributes :id
      end
      \end{lstlisting}
    \end{scriptsize}

    Nous devrions avoir des tests qui échouent. Essayez par vous même:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rspec spec/controllers/api/v1/users_controller_spec.rb
      F.F....F.....
      \end{lstlisting}
    \end{scriptsize}

    Si vous jetez un coup d'oeil rapide au \verb|users_controller|, vous devez avoir quelque chose correspondant au listing \ref{lst:add_show_to_users_controller_spec} pour l'action \verb|show|. La documentation de la gemme explique ce qui vient de ce passer:

    \begin{displayquote}
      Rails recherchera automatiquement un sérialiseur nommé \verb|PostSerializer|, et s'il existe, l'utilisera pour sérialiser un \verb|Post|.

      Cela fonctionne aussi avec \verb|respond_with|, qui utilise \verb|to_json| sous le capot. Notez également que toutes les options passées pour rendre \verb|:json| seront passées à votre sérialiseur et disponibles comme \verb|@options| à l'intérieur.

      Cela signifie que peu importe si nous utilisons la méthode \verb|render json| ou \verb|respond_with|. A partir de maintenant, Rails recherchera le sérialiseur correspondant en premier.
    \end{displayquote}

    Maintenant, de retour aux tests, vous pouvez voir que pour une raison quelconque, la réponse n'est pas tout à fait ce que nous attendons. C'est parce que la gemme réduit la réponse que nous avions précedement définie. Donc pour faire passer les tests, il suffit d'ajouter les attributs à sérialiser dans le \verb|user_serializer.rb| et de mettre à jour le fichier \verb|users_controller_spec.rb|:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      # app/serializers/user_serializer.rb
      class UserSerializer < ActiveModel::Serializer
        attributes :id, :email, :created_at, :updated_at, :auth_token
      end
      \end{lstlisting}
    \end{scriptsize}

    Si vous faites les tests maintenant, ils devraient passer:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rspec spec/controllers/api/v1/users_controller_spec.rb
      .............

      Finished in 0.16712 seconds (files took 0.80637 seconds to load)
      13 examples, 0 failures
      \end{lstlisting}
    \end{scriptsize}

    \textit{Comitons} ces changements et continuons d'avancer:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ git add .
      $ git commit -am "Adds user serializer for customizing the json output"
      \end{lstlisting}
    \end{scriptsize}

    Nous pouvons également tester les objets du sérialiseur, comme indiqué dans la documentation, mais je vous laisse le soin de décider si vous voulez tester ou non.

  \section{Sérialiser les produits}

    Maintenant que nous comprenons comment fonctionne la gemme de sérialisation, il est temps de personnaliser la sortie des produits. La première étape et comme pour l'utilisateur, nous avons besoin d'un sérialiseur de produit, alors faisons-le:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rails generate serializer product
              create  app/serializers/product_serializer.rb
      \end{lstlisting}
    \end{scriptsize}

    Ajoutons maintenant les attributs à sérialiser pour le produit, comme nous l'avons fait avec l'utilisateur dans la Section \ref{sec:serialize_user}:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # app/serializers/product_serializer.rb
      class ProductSerializer < ActiveModel::Serializer
        attributes :id, :title, :price, :published
      end
      \end{lstlisting}
    \end{scriptsize}

    Et voilà. Ce n'est pas plus compliqué que ça. Vous pouvez lancer les tests pour vérifier mais ils devraient encore être bons.

    \textit{Comitons} ces petits changements:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ git add .
      $ git commit -a "Adds product serializer for custom json output"
      \end{lstlisting}
    \end{scriptsize}

  \section{Sérialiser les associations}

    Nous avons travaillé avec des sérialiseurs et vous remarquerez peut-être que c'est très simple. Dans certains cas, la décision difficile est de savoir comment nommer vos routes ou comment structurer la sortie JSON afin que votre solution soit pérenne.

    Lorsque vous travaillez avec des associations entre les modèles sur une API, il existe de nombreuses approches que vous pouvez prendre. Ici, je vais expliquer ce que j'ai trouvé et ce fonctionne pour moi. Ce n'est pas la seule manière de faire, je vous laisse juger si elle vous convient. Dans cette section, nous allons étendre notre API pour gérer l'association produit/utilisateur. Je vais aussi vous expliquer certaines des erreurs courantes dans lesquels vous pouvez tomber.

    Pour résumer, nous avons une association de type \verb|has_many| entre l'utilisateur et le modèle de produit. Regardez le Listing \ref{lst:user_assocations} et Listing \ref{lst:product_assocations}.

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Associations des utilisateurs}, label={lst:user_assocations}]
      # app/models/user.rb
      class User < ApplicationRecord
        has_many :products, dependent: :destroy
        # ...
      end
      \end{lstlisting}
    \end{scriptsize}

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Associations des produits}, label={lst:product_assocations}]
      # app/models/product.rb
      class Product < ApplicationRecord
        belongs_to :user
        # ...
      end
      \end{lstlisting}
    \end{scriptsize}

    C'est une bonne idée d'intégrer des modèles dans d'autres modèles dans d'autres modèle car cela évite au client de l'API d'executer plusieurs requêtes. Cela rendra la sortie un peu plus lourde mais lorsque vous récupérez de nombreux enregistrements, cela peut vous éviter un énorme goulet d'étranglement. Permettez-moi d'expliquer, à l'aide d'un cas d'utilisation, l'application réelle telle qu'elle est illustrée dans l'encadré \ref{box:association_embeded}.

    \begin{tcolorbox}{Cas d'utilisation d'un objet incorporé dans une association}\label{box:association_embeded}

      Imaginez un scénario où vous allez chercher les produits dans l'API, mais dans ce cas, vous devez afficher une partie des informations de l'utilisateur.

      Une solution possible serait d'ajouter l'attribut \verb|user_id| au \verb|product_serializer| pour que nous puissions récupérer l'utilisateur correspondant plus tard. Cela peut sembler être une bonne idée, mais si vous vous souciez de la performance, ou si les transactions de votre base de données ne sont pas assez rapides, vous devriez reconsidérer cette approche. Vous devez comprendre que pour chaque produit que vous récupérez, vous allez devoir récupérer son utilisateur correspondant.

      Face à ce problème, je suis venu avec deux alternatives possibles:

      \begin{itemize}
        \item Une bonne solution à mon avis est d'intégrer les identifiants des utilisateurs liés aux produits dans un attribut meta, donc nous avons une sortie JSON comme:
          \begin{scriptsize}
            \begin{lstlisting}
            {
              "meta": { "user_ids": [1,2,3] },
              "products": [
                ...
              ]
            }
            \end{lstlisting}
          \end{scriptsize}
          Cela peut nécessiter une configuration supplémentaire sur le terminal de l'utilisateur, afin que le client puisse récupérer ces utilisateurs à partir de ces \verb|user_ids|.
        \item Une autre solution, et celle que j'utiliserai ici, est d'incorporer l'objet \verb|user| dans l'objet \verb|product|. Ce qui peut rendre la première requête un peu plus lente, mais de cette façon le client n'a pas besoin de faire une autre requête supplémentaire. Un exemple des résultats escomptés est présenté ci-dessous:
          \begin{scriptsize}
            \begin{lstlisting}
            {
              "products":
              [
                  {
                     "id": 1,
                     "title": "Digital Portable System",
                     "price": "25.0277354166289",
                     "published": false,
                     "user": {
                        "id": 2,
                        "email": "stephany@lind.co.uk",
                        "created_at": "2014-07-29T03:52:07.432Z",
                        "updated_at": "2014-07-29T03:52:07.432Z",
                        "auth_token": "Xbnzbf3YkquUrF_1bNkZ"
                      }
                  }
                  ...
               ]
            }
            \end{lstlisting}
          \end{scriptsize}
      \end{itemize}

    \end{tcolorbox}

    Donc, selon l'encadré \ref{box:association_embeded}, nous allons incorporer l'objet utilisateur dans le produit. Commençons par ajouter quelques tests. Nous allons simplement modifier les tests des routes \verb|Products#index| et \verb|Products#show| Listing \ref{lst:spec_product_assocations}.

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Test de l'associations des produits pour l'API}, label={lst:spec_product_assocations}]
      # spec/controllers/api/v1/products_controller_spec.rb
      # ...

      RSpec.describe Api::V1::ProductsController, type: :controller do
        describe 'GET #show' do
          # ...

          it 'has the user as a embeded object' do
            expect(json_response[:user][:email]).to eql @product.user.email
          end
        end

        describe 'GET #index' do
          # ...

          it 'returns the user object into each product' do
            json_response.each do |product_response|
              expect(product_response[:user]).to be_present
            end
          end
        end

        # ...
      end
      \end{lstlisting}
    \end{scriptsize}

    L'implémentation est très simple, il suffit d'ajouter une ligne au sérialiseur du produit:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # app/serializers/product_serializer.rb
      class ProductSerializer < ActiveModel::Serializer
        attributes :id, :title, :price, :published
        has_one :user
      end
      \end{lstlisting}
    \end{scriptsize}

    Maintenant, tous les tests devraient passer:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      $ rspec spec/
      ............................................................

      Finished in 0.57068 seconds (files took 0.67788 seconds to load)
      60 examples, 0 failures
      \end{lstlisting}
    \end{scriptsize}

    \subsection{Récupérer les produits pour des utilisateurs}

      Maintenant, vous vous demandez peut-être si vous devriez intégrer les produits dans l'utilisateur (comme dans la section précédente). Même si cela peut sembler bien, cela peut entraîner de graves problèmes d'optimisation. Vous pourriez être en train de charger d'énormes quantités d'informations et il est vraiment facile de tomber dans le problème des \textbf{dépendances circulaires} qui boucle le programme jusqu'à épuiser la mémoire.

      Mais ne vous inquiétez pas, tout n'est pas perdu, nous pouvons facilement résoudre ce problème en intégrant seulement les identifiants des produits dans l'utilisateur. Cela donnera à votre API une meilleure performance et cela évitera de charger des données supplémentaires. Dans cette section, nous allons donc étendre notre route de l'index des produits pour traiter un paramètre \verb|product_ids| et formater la sortie JSON en conséquence.

      Tout d'abord, nous nous assurons que le \verb|product_ids| qu'il fait partie de l'objet sérialisé de l'utilisateur:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Test de présence des identifiants des produits dans l'objet de l'utilisateur}, label={lst:product_ids_users_controller_spec}]
        # spec/controllers/api/v1/users_controller_spec.rb
        # ...

        RSpec.describe Api::V1::UsersController, type: :controller do
          describe 'GET #show' do
            # ...

            it 'has the product ids as an embeded object' do
              expect(json_response[:product_ids]).to eql []
            end
          end

          # ...
        end
        \end{lstlisting}
      \end{scriptsize}

      L'implémentation est très simple, comme décrit dans \href{https://github.com/rails-api/active_model_serializers/blob/0-10-stable/docs/howto/add_relationship_links.md#links-as-an-attribute-of-a-resource}{la documentation} de la gemme \verb|active_model_serializers|:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Implémentation pour inclures les identifiants des produits dans l'objet de l'utilisateur}, label={lst:product_ids_users_controller}]
        # app/serializers/user_serializer.rb
        class UserSerializer < ActiveModel::Serializer
        attribute :product_ids do
          object.products.map(&:id)
        end
          # ...
        end
        \end{lstlisting}
      \end{scriptsize}

      Nos tests devraient passer:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ rspec spec/controllers/api/v1/users_controller_spec.rb
        ..............

        Finished in 0.16791 seconds (files took 0.65902 seconds to load)
        14 examples, 0 failures
        \end{lstlisting}
      \end{scriptsize}

      Nous devons maintenant étendre l'action \verb|index| depuis le \verb|products_controller| pour qu'il puisse gérer le paramètre \verb|product_ids| et afficher les enregistrements scopés. Commençons par ajouter quelques tests (Listing \ref{lst:parameter_products_controller_spec}):

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Tests du paramètre d'identifiants des produits pour l'affichage de l'index des produits}, label={lst:parameter_products_controller_spec}]
        # spec/controllers/api/v1/products_controller_spec.rb
        # ...

        RSpec.describe Api::V1::ProductsController, type: :controller do
          # ...

          describe 'GET #index' do
            before(:each) do
              4.times { FactoryBot.create :product }
              get :index
            end

            context 'when is not receiving any product_ids parameter' do
              before(:each) do
                get :index
              end

              it 'returns 4 records from the database' do
                expect(json_response).to have(4).items
              end

              it 'returns the user object into each product' do
                json_response.each do |product_response|
                  expect(product_response[:user]).to be_present
                end
              end

              it { expect(response.response_code).to eq(200) }
            end

            context 'when product_ids parameter is sent' do
              before(:each) do
                @user = FactoryBot.create :user
                3.times { FactoryBot.create :product, user: @user }
                get :index, params: { product_ids: @user.product_ids }
              end

              it 'returns just the products that belong to the user' do
                json_response.each do |product_response|
                  expect(product_response[:user][:email]).to eql @user.email
                end
              end
            end
          end

          # ...
        end
        \end{lstlisting}
      \end{scriptsize}

      Comme vous pouvez le voir dans Listing \ref{lst:parameter_products_controller_spec}, nous venons d'envelopper l'action index dans deux contextes séparés: l'un qui recevra les \verb|product_ids| et l'autre l'ancien que nous avions écris. Ajoutons le code nécessaire pour faire passer les tests:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby]
        # app/controllers/api/v1/products_controller.rb
        class Api::V1::ProductsController < ApplicationController
          before_action :authenticate_with_token!, only: %i[create update destroy]

          def index
            products = params[:product_ids].present? ? Product.find(params[:product_ids]) : Product.all
            render json: products
          end

          # ...
        end
        \end{lstlisting}
      \end{scriptsize}

      Comme vous pouvez le voir l'implémentation est super simple. Nous allons simplement chercher les produits avec le paramètre \verb|product_ids| au cas où ils seraient présents, sinon nous les cherchons tous. Assurons-nous que les tests sont bons:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ rspec spec/controllers/api/v1/products_controller_spec.rb
        ..................

        Finished in 0.35027 seconds (files took 0.65369 seconds to load)
        18 examples, 0 failures
        \end{lstlisting}
      \end{scriptsize}

      \textit{Comittons} nos changements:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ git commit -am "Embeds the products_ids into the user serialiser and fetches the correct products from the index action endpoint"
        \end{lstlisting}
      \end{scriptsize}

  \section{Rechercher les produits}

    Dans cette dernière section, nous continuerons à renforcer l'action d'\verb|Products#index| en mettant en place un mécanisme de recherche très simple pour permettre à n'importe quel client de filtrer les résultats. Cette section est facultative car elle n'aura aucun impact sur les modules de l'application. Mais si vous voulez pratiquer davantage avec le TDD, je vous recommande de compléter cette dernière étape.

    J'utilise \href{https://github.com/activerecord-hackery/ransack}{Ransack} pour construire des formulaires de recherche avancée extrêmement rapidement. Mais ici, comme le but est dapprendre et que la recherche que nous allons effectuer est très simple, je pense que nous pouvons construire un moteur de recherche à partir de zéro. Nous devons simplement considérer les critères par lesquels nous allons filtrer les attributs. Accrochez-vous bien à vos sièges, ça va être un voyage difficile.

    Nous filtrerons donc les produits selon les critères suivants:

    \begin{itemize}
      \item Par titre
      \item Par prix
      \item Trier par date de création
    \end{itemize}

    Cela peut sembler court et facile, mais croyez-moi, cela vous donnera mal à la tête si vous ne le planifiez pas.

    \subsection{Le mot-clé by}

      Nous allons créer un \textit{scope} pour trouver les enregistrements qui correspondent à un motif particulier de caractères. Appelons-le \verb|filter_by_title|. Ajoutons d'abord quelques tests (Listing \ref{lst:product_filter_by_title_spec}):

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Test du filtrage des produits par titre}, label={lst:product_filter_by_title_spec}]
        # spec/models/product_spec.rb
        # ...

        RSpec.describe Product, type: :model do
          # ...

          describe '.filter_by_title' do
            before(:each) do
              @product1 = FactoryBot.create :product, title: 'A plasma TV'
              @product2 = FactoryBot.create :product, title: 'Fastest Laptop'
              @product3 = FactoryBot.create :product, title: 'CD player'
              @product4 = FactoryBot.create :product, title: 'LCD TV'
            end

            context "when a 'TV' title pattern is sent" do
              it 'returns the 2 products matching' do
                expect(Product.filter_by_title('TV')).to have(2).items
              end

              it 'returns the products matching' do
                expect(Product.filter_by_title('TV').sort).to match_array([@product1, @product4])
              end
            end
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      Le test ici est de s'assurer que quel que soit le cas du titre envoyé, nous devons l'aseptiser afin de faire la comparaison appropriée. Dans notre cas nous utiliserons l'approche en minuscules. Implémentons le code nécessaire (Listing \ref{lst:product_filter_by_title}):

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Implémentation du filtrage des produits par titre}, label={lst:product_filter_by_title}]
        # app/models/product.rb
        class Product < ApplicationRecord
          # ...
          scope :filter_by_title, lambda { |keyword|
            where('lower(title) LIKE ?', "%#{keyword.downcase}%")
          }
        end
        \end{lstlisting}
      \end{scriptsize}

      L'implémentation est suffisante pour que nos tests passent:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ rspec spec/models/product_spec.rb
        ...........

        Finished in 0.17178 seconds (files took 3.59 seconds to load)
        11 examples, 0 failures
        \end{lstlisting}
      \end{scriptsize}

    \subsection{Par prix}

      Pour filtrer par prix, les choses peuvent devenir un peu plus délicates. Nous allons briser la logique de filtrer par prix en deux méthodes différentes: l'une qui va chercher les produits plus grands que le prix reçu et l'autre qui va chercher ceux qui sont sous ce prix. De cette façon, nous garderons une certaine flexibilité et nous pouvons facilement tester les \textit{scope}.

      Commençons par construire les tests du \textit{scope} \verb|above_or_equal_to_price| (Listing \ref{lst:product_above_or_equal_to_price_spec}):

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Test du filtrage des produits par prix supérieur ou égal}, label={lst:product_above_or_equal_to_price_spec}]
        # spec/models/product_spec.rb
        # ...

        RSpec.describe Product, type: :model do
          # ...

          describe '.above_or_equal_to_price' do
            before(:each) do
              @product1 = FactoryBot.create :product, price: 100
              @product2 = FactoryBot.create :product, price: 50
              @product3 = FactoryBot.create :product, price: 150
              @product4 = FactoryBot.create :product, price: 99
            end

            it 'returns the products which are above or equal to the price' do
              expect(Product.above_or_equal_to_price(100).sort).to match_array([@product1, @product3])
            end
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      L'implémentation est très très simple (Listing \ref{lst:product_above_or_equal_to_price}):

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Implémentation du filtrage des produits par prix supérieur ou égal}, label={lst:product_above_or_equal_to_price}]
        # app/models/product.rb
        class Product < ApplicationRecord
          # ...
          scope :above_or_equal_to_price, lambda { |price|
            where('price >= ?', price)
          }
        end
        \end{lstlisting}
      \end{scriptsize}

      L'implémentation est suffisante pour que nos tests passent:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ rspec spec/models/product_spec.rb
        ............

        Finished in 0.1566 seconds (files took 0.64782 seconds to load)
        12 examples, 0 failures
        \end{lstlisting}
      \end{scriptsize}

      Vous pouvez maintenant imaginer le comportement de la méthode opposée. Voici les tests:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Test du filtrage des produits par prix inférieur ou égal}, label={lst:product_below_or_equal_to_price_spec}]
        # spec/models/product_spec.rb
        # ...

        RSpec.describe Product, type: :model do
          # ...

          describe '.below_or_equal_to_price' do
            before(:each) do
              @product1 = FactoryBot.create :product, price: 100
              @product2 = FactoryBot.create :product, price: 50
              @product3 = FactoryBot.create :product, price: 150
              @product4 = FactoryBot.create :product, price: 99
            end

            it 'returns the products which are above or equal to the price' do
              expect(Product.below_or_equal_to_price(99).sort).to match_array([@product2, @product4])
            end
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      Et l'implémentation (Listing \ref{lst:product_below_or_equal_to_price}):

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Implémentation du filtrage des produits par prix supérieur ou égal}, label={lst:product_below_or_equal_to_price}]
        # app/models/product.rb
        class Product < ApplicationRecord
          # ...
          scope :below_or_equal_to_price, lambda { |price|
            where('price <= ?', price)
          }
        end
        \end{lstlisting}
      \end{scriptsize}

      Pour notre bien, faisons les tests et vérifions que tout est beau et vert:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ rspec spec/models/product_spec.rb
        .............

        Finished in 0.18008 seconds (files took 0.6544 seconds to load)
        13 examples, 0 failures
        \end{lstlisting}
      \end{scriptsize}

      Comme vous pouvez le voir, nous n'avons pas eu beaucoup de problèmes. Ajoutons simplement une autre \textit{scope} pour trier les enregistrements par date de dernière mise à jour. Dans le cas où le propriétaire des produits décide de mettre à jour certaines données, il veut toujours les trier par enregistrements les plus récents.

    \subsection{Tri par date de création}

      Ce \textit{scope} est très facile. Ajoutons d'abord quelques tests (Listing \ref{lst:product_recent_spec}):

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Test du filtrage des produits par date de création}, label={lst:product_recent_spec}]
        # spec/models/product_spec.rb
        # ...

        RSpec.describe Product, type: :model do
          # ...

          describe '.recent' do
            before(:each) do
              @product1 = FactoryBot.create :product, price: 100
              @product2 = FactoryBot.create :product, price: 50
              @product3 = FactoryBot.create :product, price: 150
              @product4 = FactoryBot.create :product, price: 99

              # we will touch some products to update them
              @product2.touch
              @product3.touch
            end

            it 'returns the most updated records' do
              expect(Product.recent).to match_array([@product3, @product2, @product4, @product1])
            end
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      Et l'implémentation (Listing \ref{lst:product_recent}):

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Implémentation du filtrage des produits par date de création}, label={lst:product_recent}]
        # app/models/product.rb
        class Product < ApplicationRecord
          # ...

          scope :recent, lambda {
            order(:updated_at)
          }
        end
        \end{lstlisting}
      \end{scriptsize}

      Tous nos tests devraient passer:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ rspec spec/models/product_spec.rb
        .............

        Finished in 0.18008 seconds (files took 0.6544 seconds to load)
        13 examples, 0 failures
        \end{lstlisting}
      \end{scriptsize}

    \subsection{Moteur de recherche}

      Maintenant que nous avons la base pour le moteur de recherche que nous utiliserons dans l'application, il est temps de mettre en œuvre une méthode de recherche simple mais puissante. Elle s'occupera de gérer toute la logique pour récupérer les enregistrements des produits.

      La méthode consistera à enchaîner tous les \verb|scope| que nous avons construits précédemment et à retourner le résultat. Commençons par ajouter quelques tests:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Test du moteur de recherche des produits}, label={lst:product_search_spec}]
        # spec/models/product_spec.rb
        # ...

        RSpec.describe Product, type: :model do
          # ...

          describe '.search' do
            before(:each) do
              @product1 = FactoryBot.create :product, price: 100, title: 'Plasma tv'
              @product2 = FactoryBot.create :product, price: 50, title: 'Videogame console'
              @product3 = FactoryBot.create :product, price: 150, title: 'MP3'
              @product4 = FactoryBot.create :product, price: 99, title: 'Laptop'
            end

            context "when title 'videogame' and '100' a min price are set" do
              it 'returns an empty array' do
                search_hash = { keyword: 'videogame', min_price: 100 }
                expect(Product.search(search_hash)).to be_empty
              end
            end

            context "when title 'tv', '150' as max price, and '50' as min price are set" do
              it 'returns the product1' do
                search_hash = { keyword: 'tv', min_price: 50, max_price: 150 }
                expect(Product.search(search_hash)).to match_array([@product1])
              end
            end

            context 'when an empty hash is sent' do
              it 'returns all the products' do
                expect(Product.search({})).to match_array([@product1, @product2, @product3, @product4])
              end
            end

            context 'when product_ids is present' do
              it 'returns the product from the ids' do
                search_hash = { product_ids: [@product1.id, @product2.id] }
                expect(Product.search(search_hash)).to match_array([@product1, @product2])
              end
            end
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      Nous avons ajouté un tas de code mais je vous assure que l'implémentation est très facile. Vous pouvez aller plus loin et ajouter quelques tests supplémentaires mais, dans mon cas, je n'ai pas trouvé cela nécessaire.

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Implémentation du moteur de recherche des produits}, label={lst:product_search}]
        # app/models/product.rb
        class Product < ApplicationRecord
          # ...

          def self.search(params = {})
            products = params[:product_ids].present? ? Product.find(params[:product_ids]) : Product.all

            products = products.filter_by_title(params[:keyword]) if params[:keyword]
            products = products.above_or_equal_to_price(params[:min_price].to_f) if params[:min_price]
            products = products.below_or_equal_to_price(params[:max_price].to_f) if params[:max_price]
            products = products.recent(params[:recent]) if params[:recent].present?

            products
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      Il est important de noter que nous retournons les produits en tant qu'objet \verb|ActiveRelation| afin de pouvoir enchaîner d'autres méthodes en cas de besoin ou les paginer comme nous allons le voir dans les derniers chapitres. Il suffit de mettre à jour l'action \verb|Product#index| pour récupérer les produits à partir de la méthode de recherche:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby]
        # app/models/product.rb
        # app/controllers/api/v1/products_controller.rb
        class Api::V1::ProductsController < ApplicationController
          before_action :authenticate_with_token!, only: %i[create update destroy]

          def index
            render json: Product.search(params)
          end

          # ...
        end
        \end{lstlisting}
      \end{scriptsize}

      Nous pouvons exécuter l'ensemble de la suite de tests, pour nous assurer que l'application est en bonne santé jusqu'ici:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ rspec spec/
        .......................................................................

        Finished in 1.49 seconds (files took 6.53 seconds to load)
        71 examples, 0 failures
        \end{lstlisting}
      \end{scriptsize}

      \textit{Comitons} ces changements:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ git commit -am "Adds search class method to filter products"
        \end{lstlisting}
      \end{scriptsize}

  \section{Conclusion}

    Jusqu'à présent, et grâce à la gemme \href{https://github.com/rails-api/active_model_serializers}{active\_model\_serializers}, c'était facile. Sur les chapitres à venir, nous allons commencer à construire le modèle \verb|Order| qui associera les utilisateurs aux produits.

\chapter{Création des commandes}\label{chapter:8}

  Dans le chapitre \ref{chapter:7} nous avons traité les associations entre les produit et les modèles utilisateurs. Nous avons aussi vu comment bien les sérialiser en optimisant afin de pouvoir \textit{scaler}\footnote{La scalabilité désigne la capacité d'un produit à s'adapter à une forte  demande (montée en charge)} rapidement et facilement. Maintenant, il est temps de commencer à passer des commandes. Cela va être une situation plus complexe parce que nous allons gérer les associations entre 3 modèles. Nous devons être assez intelligents pour gérer la sortie JSON que nous fournissons.

  Dans ce chapitre, nous allons faire plusieurs choses que j'énumère ci-dessous:

  \begin{itemize}
    \item Créer un modèle de commande avec les spécifications correspondantes
    \item Gérer l'association de sortie json entre l'utilisateur de la commande et les modèles de produits
    \item Envoyer un email de confirmation avec le récapitulatif de la commande
  \end{itemize}

  Maintenant que tout est clair, on peut commencer à travailler. Vous pouvez cloner le projet jusqu'à ce point avec:

  \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ git clone --branch chapter7 https://github.com/madeindjs/market_place_api
    \end{lstlisting}
  \end{scriptsize}

  Créons une nouvelle branche afin de commencer à travailler:

  \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ git checkout -b chapter8
    \end{lstlisting}
  \end{scriptsize}

  \section{Modélisation de l'ordre}

    Si vous vous souvenez de la Figure \ref{fig:data_model}, le modèle \verb|Order| est associé aux \verb|User| et \verb|Product|. C'est en fait très simple de gérer cela avec Rails. La partie délicate est quand vient la sérialisation de ces objets. J'en parlerai plus en détail à la section 8.3.

    Commençons par créer le modèle de la commande:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rails generate model order user:references total:decimal
      \end{lstlisting}
    \end{scriptsize}

    La commande ci-dessus va générer le modèle \verb|Order|. Je profite de la méthode des \verb|references| pour créer la clé étrangère correspondante pour que la commande appartienne à un utilisateur. Elle ajoute aussi la directive \verb|belongs_to| dans le modèle des commandes. Migrons la base de données:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rake db:migrate
      \end{lstlisting}
    \end{scriptsize}

    Il est maintenant temps de créer quelques tests dans le fichier \verb|order_spec.rb|:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Premiers tests du modèle de commande}]
      # spec/models/order_spec.rb
      # ...

      RSpec.describe Order, type: :model do
        let(:order) { FactoryBot.build :order }
        subject { order }

        it { should respond_to(:total) }
        it { should respond_to(:user_id) }

        it { should validate_presence_of :user_id }
        it { should validate_presence_of :total }
        it { should validate_numericality_of(:total).is_greater_than_or_equal_to(0) }

        it { should belong_to :user }
      end
      \end{lstlisting}
    \end{scriptsize}

    L'implémentation est assez simple:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Validateurs du modèle de commande}]
      # app/models/order.rb
      class Order < ApplicationRecord
        belongs_to :user
        validates :total, numericality: { greater_than_or_equal_to: 0 }
        validates :total, presence: true
        validates :user_id, presence: true
      end
      \end{lstlisting}
    \end{scriptsize}

    Les tests devraient passer:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Validateurs du modèle de commande}]
      $ rspec spec/models/order_spec.rb
      ......

      Finished in 0.16229 seconds (files took 4.08 seconds to load)
      6 examples, 0 failures
      \end{lstlisting}
    \end{scriptsize}

    \subsection{Les commandes et les produits}

      Nous devons établir l'association entre la commande et le produit. Cela se fait avec une association de plusieurs à plusieurs car de nombreux produits seront placés sur plusieurs commandes et les commandes auront plusieurs produits. Dans ce cas, nous avons donc besoin d'un modèle supplémentaire qui joindra ces deux autres objets et mappera l'association appropriée. Générons ce modèle:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        rails generate model placement order:references product:references
        \end{lstlisting}
      \end{scriptsize}

      Migrons la base de données:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ rake db:migrate
        \end{lstlisting}
      \end{scriptsize}

      Ajoutons d'abord les tests de l'association des commandes aux produits:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Tests de l'association des commandes aux produits}]
        # spec/models/order_spec.rb
        # ...

        RSpec.describe Order, type: :model do
          # ...

          it { should have_many(:placements) }
          it { should have_many(:products).through(:placements) }
        end
        \end{lstlisting}
      \end{scriptsize}

      L'implémentation est la suivante:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Implémentation de l'association des commandes aux produits}]
        # app/models/order.rb
        class Order < ApplicationRecord
          has_many :placements
          has_many :products, through: :placements
          # ...
        end
        \end{lstlisting}
      \end{scriptsize}

      Il est maintenant temps de se lancer dans l'association \verb|product-placement|:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby]
        # spec/models/product_spec.rb
        # ...

        RSpec.describe Product, type: :model do
          # ...
          it { should have_many(:placements) }
          it { should have_many(:orders).through(:placements) }
          # ...
        end
        \end{lstlisting}
      \end{scriptsize}

      Ajoutons le code pour le faire passer:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby]
        # app/models/product.rb
        class Product < ApplicationRecord
          belongs_to :user
          has_many :placements
          has_many :orders, through: :placements
          # ...
        end
        \end{lstlisting}
      \end{scriptsize}

      Enfin, et ce n'est pas le moins important, les tests de placement:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby]
        # spec/models/placement_spec.rb
        # ...

        RSpec.describe Placement, type: :model do
          let(:placement) { FactoryBot.build :placement }
          subject { placement }

          it { should respond_to :order_id }
          it { should respond_to :product_id }

          it { should belong_to :order }
          it { should belong_to :product }
        end
        \end{lstlisting}
      \end{scriptsize}

      Si vous avez suivi le tutoriel jusqu'à présent, l'implémentation est déjà là, à cause du type de références que nous passons au générateur de commandes du modèle. Nous devrions ajouter l'option inverse au modèle de placement pour chaque appel aux \verb|belongs_to|. Cela donne un petit coup de pouce lors du référencement de l'objet parent.

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby]
        # app/models/placement.rb
        class Placement < ApplicationRecord
          belongs_to :order, inverse_of: :placements
          belongs_to :product, inverse_of: :placements
        end
        \end{lstlisting}
      \end{scriptsize}

      Et maintenant, lançons tous les tests des modèles afin de nous assurer que tout est bon:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ rspec spec/models
        ...........................................

        Finished in 0.53127 seconds (files took 0.73125 seconds to load)
        43 examples, 0 failures
        \end{lstlisting}
      \end{scriptsize}

      Maintenant que tout est beau et vert, \textit{commitons} les changements:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ git add .
        $ git commit -m "Associates products and orders with a placements model"
        \end{lstlisting}
      \end{scriptsize}

  \section{Commandes de l'utilisateur}

    Il nous manque juste une petite (mais très importante) partie qui est de relier l'utilisateur aux commandes. Alors faisons-le :

    Ouvrez d'abord le fichier \verb|user_model_spec.rb| pour ajouter les tests correspondants:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # spec/models/user_spec.rb
      # ...

      RSpec.describe User, type: :model do
        # ...
        it { should have_many(:orders) }
        # ...
      end
      \end{lstlisting}
    \end{scriptsize}

    Et puis il suffit d'ajouter l'implémentation qui est très simple:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # app/models/user.rb
      class User < ApplicationRecord
        # ...
        has_many :orders, dependent: :destroy
        # ...
      end
      \end{lstlisting}
    \end{scriptsize}

    Vous pouvez exécuter les tests pour les deux fichiers, et ils devraient tous passer:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      $ rspec spec/models/{order,user}_spec.rb
      ....................

      Finished in 0.14279 seconds (files took 0.72848 seconds to load)
      20 examples, 0 failures
      \end{lstlisting}
    \end{scriptsize}

    \textit{Comitons} ces changements et continuons d'avancer:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      $ git add .
      $ git commit -m 'Adds user order has many relation'
      \end{lstlisting}
    \end{scriptsize}

  \section{Exposer le modèle d'utilisateur}

    Il est maintenant temps de préparer le contrôleur de commandes à exposer la bonne commande. Si vous vous souvenez des chapitres précédents ou l'on avait utilisé \href{https://github.com/rails-api/active_model_serializers}{ActiveModelSerializers} vous devez vous rappeler que c'était vraiment facile.

    \textquote{Mais attendez, que sommes-nous censés exposer?} vous vous demandez peut-être. Vous avez raison! Définissons d'abord quelles actions nous allons mettre en place:

    \begin{itemize}
      \item Une action d'indexation pour récupérer les commandes des utilisateurs en cours
      \item Une action show pour récupérer une commande particulière de l'utilisateur courant
      \item Une action de création pour passer réellement la commande
    \end{itemize}


    Commençons par l'action \verb|index|. Nous devons d'abord créer le contrôleur de commandes:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      $ rails g controller api/v1/orders
      \end{lstlisting}
    \end{scriptsize}

    Jusqu'ici, et avant de commencer à taper du code, nous devons nous demander, \textquote{Est-ce que je dois laisser les routes de ma commande imbriqués dans le UsersController ou bien je dois les isoler?}. La réponse est vraiment simple. Je dirais que cela dépend de la quantité d'informations dans ce cas en particulier que vous voulez exposer au développeur Pas du point de vue de la sortie JSON mais au niveau de l'URI.

    Dans notre cas, je vais emboîter les routes, parce que j'aime donner ce type d'information aux développeurs. Je pense que cela donne plus de contexte à la requête elle-même.

    Commençons par quelques tests:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Test de l'affichage des commandes}]
      # spec/controllers/api/v1/orders_controller_spec.rb
      # ...

      RSpec.describe Api::V1::OrdersController, type: :controller do
        describe 'GET #index' do
          before(:each) do
            current_user = FactoryBot.create :user
            api_authorization_header current_user.auth_token
            4.times { FactoryBot.create :order, user: current_user }
            get :index, params: { user_id: current_user.id }
          end

          it 'returns 4 order records from the user' do
            expect(json_response).to have(4).items
          end

          it { expect(response.response_code).to eq(200) }
        end
      end
      \end{lstlisting}
    \end{scriptsize}

    Si nous exécutons la suite de tests maintenant, comme vous pouvez vous y attendre, les deux tests échoueront. C'est normal car nous n'avons même pas défini ni les bonnes routes ni l'action. Commençons donc par ajouter les routes:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # config/routes.rb
      # ...

      Rails.application.routes.draw do
        # ...
        namespace :api, defaults: { format: :json }, constraints: { subdomain: 'api' }, path: '/' do
          scope module: :v1, constraints: ApiConstraints.new(version: 1, default: true) do
            resources :users, only: %i[show create update destroy] do
              # ...
              resources :orders, only: [:index]
            end
            # ...
          end
        end
      end
      \end{lstlisting}
    \end{scriptsize}

    Il est maintenant temps d'implémenter le contrôleur des commandes:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # app/controllers/api/v1/orders_controller.rb
      class Api::V1::OrdersController < ApplicationController
        before_action :authenticate_with_token!

        def index
          render json: current_user.orders
        end
      end
      \end{lstlisting}
    \end{scriptsize}

    Et maintenant nos tests devraient passer:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rspec spec/controllers/api/v1/orders_controller_spec.rb
      ..

      Finished in 0.07943 seconds (files took 0.7232 seconds to load)
      2 examples, 0 failures
      \end{lstlisting}
    \end{scriptsize}

    Nous aimons nos commits très petits. Alors \textit{commitons} dès maintenant:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ git add .
      $ git commit -m "Adds the show action for order"
      \end{lstlisting}
    \end{scriptsize}

    \subsection{Afficher une seule commande}

      Comme vous pouvez déjà l'imaginer, cette route est très facile. Nous n'avons qu'à mettre en place quelques configurations (routes, action du contrôleur) et ce sera tout pour cette section.

      Commençons par ajouter quelques tests:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Test de l'affichage d'une commande}]
        # spec/controllers/api/v1/orders_controller_spec.rb
        # ...

        RSpec.describe Api::V1::OrdersController, type: :controller do
          # ...

          describe 'GET #show' do
            before(:each) do
              current_user = FactoryBot.create :user
              api_authorization_header current_user.auth_token
              @order = FactoryBot.create :order, user: current_user
              get :show, params: { user_id: current_user.id, id: @order.id }
            end

            it 'returns the user order record matching the id' do
              expect(json_response[:id]).to eql @order.id
            end

            it { expect(response.response_code).to eq(200) }
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      Ajoutons l'implémentation pour faire passer nos tests. Sur le fichier \verb|routes.rb| ajoutez l'action \verb|show| aux routes des commandes:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby]
        # config/routes.rb
        # ...

        Rails.application.routes.draw do
          # ...
          resources :orders, only: [:index, :show]
          # ...
        end
        \end{lstlisting}
      \end{scriptsize}

      Et l'implémentation devrait ressembler à ceci:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby]
        # app/controllers/api/v1/orders_controller.rb
        class Api::V1::OrdersController < ApplicationController
          # ...

          def show
            render json: current_user.orders.find(params[:id])
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      Tous nos tests passent désormais:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ rspec spec/controllers/api/v1/orders_controller_spec.rb
        ....

        Finished in 0.12767 seconds (files took 0.73322 seconds to load)
        4 examples, 0 failures
        \end{lstlisting}
      \end{scriptsize}


      \textit{Commitons} les changements et passons à l'action \verb|Product#create|.

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ git add .
        $ git commit -m "Adds the show action for order"
        \end{lstlisting}
      \end{scriptsize}

    \subsection{Placement et commandes}

      Il est maintenant temps de donner la possibilité à l'utilisateur de passer quelques commandes. Cela ajoutera de la complexité à l'application, mais ne vous inquiétez pas, nous allons faire les choses une étape à la fois.

      Avant de lancer cette fonctionnalité, prenons le temps de réfléchir aux implications de la création d'une commande dans l'application. Je ne parle pas de la mise en place d'un service de transactions comme \href{https://stripe.com/}{Stripe} ou \href{https://www.braintreepayments.com/}{Braintree} mais de choses comme:

      \begin{itemize}
        \item la gestion des produits en rupture de stock
        \item la diminution de l'inventaire de produits
        \item ajouter une certaine validation pour le placement de la commande pour s'assurer qu'il y a suffisamment de produits au moment où la commande est passée
      \end{itemize}


      On dirait qu'il reste un paquet de chose à faire mais croyez-moi: vous êtes plus près que vous ne le pensez et ce n'est pas aussi dur que ça en a l'air. Pour l'instant, gardons les choses simples et supposons que nous avons toujours assez de produits pour passer un nombre quelconque de commandes. Nous nous soucions juste de la réponse du serveur pour le moment.

      Si vous vous rappelez le modèle de commande sur la section 8.1, nous avons besoin de 3 choses: un total pour la commande, l'utilisateur qui passe la commande et les produits pour la commande. Compte tenu de cette information, nous pouvons commencer à ajouter quelques tests:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Création de tests pour la création d'une commande}]
        # spec/controllers/api/v1/orders_controller_spec.rb
        # ...

        RSpec.describe Api::V1::OrdersController, type: :controller do
          # ...

          describe 'POST #create' do
            before(:each) do
              current_user = FactoryBot.create :user
              api_authorization_header current_user.auth_token

              product_1 = FactoryBot.create :product
              product_2 = FactoryBot.create :product
              order_params = { total: 50, user_id: current_user.id, product_ids: [product_1.id, product_2.id] }
              post :create, params: { user_id: current_user.id, order: order_params }
            end

            it 'returns the just user order record' do
              expect(json_response[:id]).to be_present
            end

            it { expect(response.response_code).to eq(201) }
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      Comme vous pouvez le voir, nous sommes en train de créer une variable \verb|order_params| avec les données de la commande. Vous voyez le problème ici? Je l'expliquerai plus tard. Ajoutons simplement le code nécessaire pour faire passer ce test.

      Nous devons d'abord ajouter l'action aux routes:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby]
        # config/routes.rb
        # ...

        Rails.application.routes.draw do
          # ...
          resources :orders, only: %i[index show create]
          # ...
        end
        \end{lstlisting}
      \end{scriptsize}

      Ensuite, la mise en œuvre qui est facile:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Création de l'action de création d'une commande}, label={lst:orders_controller_create}]
        # app/controllers/api/v1/orders_controller.rb
        class Api::V1::OrdersController < ApplicationController
          # ...

          def create
            order = current_user.orders.build(order_params)

            if order.save
              render json: order, status: 201, location: [:api, current_user, order]
            else
              render json: { errors: order.errors }, status: 422
            end
          end

          private

          def order_params
            params.require(:order).permit(:total, :user_id, product_ids: [])
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      Et maintenant, nos tests devraient tous passer:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ rspec spec/controllers/api/v1/orders_controller_spec.rb
        ......

        Finished in 0.16817 seconds (files took 0.64624 seconds to load)
        6 examples, 0 failures
        \end{lstlisting}
      \end{scriptsize}

      Ok donc tout va bien. Nous devrions maintenant passer au chapitre suivant, non? Laissez-moi faire une pause avanat. Nous avons de graves erreurs sur l'application et elles ne sont pas liées au code lui-même mais sur la partie métier.

      Ce n'est pas parce que les tests passent que l'application remplit la partie métier de l'application. Je voulais en parler parce que dans de nombreux cas, c'est super facile de simplement recevoir des paramètres et de construire des objets à partir de ces paramètres. Dans notre cas, nous ne pouvons pas nous fier aux données que nous recevons. En effet, nous laissons ici le client fixer le total de la commande! Ouais, c'est fou!

      Nous devons donc ajouter quelques validations et calculer le total de la commande dans le modèle. De cette façon, nous ne recevons plus cet attribut total et nous avons un contrôle complet sur cet attribut. Alors faisons-le.

      Nous devons d'abord ajouter quelques tests pour le modèle de commande:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Test de la métode du calcul de total de la commande}]
        # spec/models/order_spec.rb
        # ...

        RSpec.describe Order, type: :model do
          # ...

          describe '#set_total!' do
            before(:each) do
              product_1 = FactoryBot.create :product, price: 100
              product_2 = FactoryBot.create :product, price: 85

              @order = FactoryBot.build :order, product_ids: [product_1.id, product_2.id]
            end

            it 'returns the total amount to pay for the products' do
              expect { @order.set_total! }.to change { @order.total }.from(0).to(185)
            end
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      Nous pouvons maintenant ajouter l'implémentation:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Implémentation de la métode du calcul de total de la commande}]
        # app/models/order.rb
        class Order < ApplicationRecord
          # ...

          def set_total!
            self.total = products.map(&:price).sum
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      Juste avant que vous ne lanciez vos tests, nous avons besoin de mettre à jour l'usine de commande:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Implémentation de la métode du calcul de total de la commande}]
        # spec/factories/orders.rb
        FactoryBot.define do
          factory :order do
            user { nil }
            total { 0.0 }
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      Nous pouvons maintenant \textit{hooker}\footnote{Je n'ai pas trouvé de traductions française correcte pour ce terme. Il s'agit de lancer une actions lorsque un évenènement est appelé.} la méthode \verb|set_total!| à un rappel \verb|before_validation| pour s'assurer qu'il a le bon total avant la validation.

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby]
        # app/models/order.rb
        class Order < ApplicationRecord
          before_validation :set_total!
          # ...
        end
        \end{lstlisting}
      \end{scriptsize}

      A ce stade, nous nous assurons que le total est toujours présent et supérieur ou égal à zéro, ce qui signifie que nous pouvons supprimer ces validations et supprimer les spécifications. Nos tests devraient passer maintenant:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ rspec spec/models/order_spec.rb
        .........

        Finished in 0.06807 seconds (files took 0.66165 seconds to load)
        9 examples, 0 failures
        \end{lstlisting}
      \end{scriptsize}

      C'est maintenant le moment de voir le fichier \verb|orders_controller_spec.rb| et de refactoriser du code. Actuellement, nous avons quelque chose comme:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        # spec/controllers/api/v1/orders_controller_spec.rb
        # ...

        RSpec.describe Api::V1::OrdersController, type: :controller do
          # ...

          describe 'POST #create' do
            before(:each) do
              current_user = FactoryBot.create :user
              api_authorization_header current_user.auth_token

              product_1 = FactoryBot.create :product
              product_2 = FactoryBot.create :product
              order_params = { total: 50, user_id: current_user.id, product_ids: [product_1.id, product_2.id] }
              post :create, params: { user_id: current_user.id, order: order_params }
            end

            it 'returns the just user order record' do
              expect(json_response[:id]).to be_present
            end

            it { expect(response.response_code).to eq(201) }
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      Il suffit de supprimer l'\verb|user_id| et les paramètres \verb|total| car l'identifiant utilisateur n'est pas vraiment nécessaire et le total est calculé par le modèle. Après avoir effectué les modifications, le code doit ressembler à ce qui suit:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby]
        # spec/controllers/api/v1/orders_controller_spec.rb
        # ...

        RSpec.describe Api::V1::OrdersController, type: :controller do
          # ...

          describe 'POST #create' do
            before(:each) do
              current_user = FactoryBot.create :user
              api_authorization_header current_user.auth_token

              product_1 = FactoryBot.create :product
              product_2 = FactoryBot.create :product
              # changes heres
              order_params = { product_ids: [product_1.id, product_2.id] }
              post :create, params: { user_id: current_user.id, order: order_params }
            end

            it 'returns the just user order record' do
              expect(json_response[:id]).to be_present
            end

            it { expect(response.response_code).to eq(201) }
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      Si vous exécutez les tests maintenant, ils passeront. Mais avant, supprimons le \verb|total| et \verb|user_id| des paramètres autorisés et évitons l'affectation en masse. La méthode \verb|order_params| devrait ressembler à ceci:

      \begin{scriptsize}
        \begin{lstlisting}[language=ruby]
        # app/controllers/api/v1/orders_controller.rb
        class Api::V1::OrdersController < ApplicationController
          # ...

          private

          def order_params
            params.require(:order).permit(product_ids: [])
          end
        end
        \end{lstlisting}
      \end{scriptsize}

      Nos tests doivent continuer à passer. \textit{Commitons} nos changements:

      \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ git commit -am "Adds the create method for the orders controller"
        \end{lstlisting}
      \end{scriptsize}

  \section{Customiser l'affichage JSON des commandes}

    Maintenant que nous avons construit les routs nécessaires pour les commandes nous pouvons personnaliser les informations que nous voulons rendre sur la sortie JSON pour chaque commande.

    Si vous vous souvenez du chaptitre \ref{chapter:7}, nous allons ici aussi utiliser \textit{Active Model Serializers}. Commençons donc par créer un séraliseur pour les commandes:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rails generate serializer order
      \end{lstlisting}
    \end{scriptsize}

    Ensuite, ouvrons le fichier \verb|order_serializer.rb| qui doit ressembler à ça:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      # app/serializers/order_serializer.rb
      class OrderSerializer < ActiveModel::Serializer
        attributes :id
      end
      \end{lstlisting}
    \end{scriptsize}


    Nous allons ajouter l'association des produits et l'attribut \verb|total| à la sortie JSON. Pour nous assurer que tout fonctionne bien, et comme d'habitude, nous ferons quelques tests. Afin d'éviter la duplication de code sur les tests, je vais juste ajouter une spécification pour le spectacle et m'assurer que les données supplémentaires sont rendues. C'est parce que j'utilise le même sérialiseur chaque fois qu'un objet d'ordre est analysé à json, donc dans ce cas, je dirais qu'il est très bien:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # spec/controllers/api/v1/orders_controller_spec.rb
      # ...

      RSpec.describe Api::V1::OrdersController, type: :controller do
        # ...

        describe 'GET #show' do
          before(:each) do
            current_user = FactoryBot.create :user
            api_authorization_header current_user.auth_token
            @order = FactoryGirl.create :order, user: current_user, product_ids: [@product.id]
            get :show, params: { user_id: current_user.id, id: @order.id }
          end

          it 'returns the user order record matching the id' do
            expect(json_response[:id]).to eql @order.id
          end

          it 'includes the total for the order' do
            expect(json_response[:total]).to eql @order.total.to_s
          end

          it 'includes the products on the order' do
            expect(json_response[:products]).to have(1).item
          end

          # ...
        end

        # ...
      end
      \end{lstlisting}
    \end{scriptsize}

    Ces tests devraient échouer mais ils sont faciles à faire passer sur le sérialiseur de commande:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      # app/serializers/order_serializer.rb
      class OrderSerializer < ActiveModel::Serializer
        attributes :id, :total
        has_many :products
      end
      \end{lstlisting}
    \end{scriptsize}

    Et désormais nos tests devraient passer:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rspec spec/controllers/api/v1/orders_controller_spec.rb
      ........

      Finished in 0.22865 seconds (files took 0.70506 seconds to load)
      8 examples, 0 failures
      \end{lstlisting}
    \end{scriptsize}

    Si vous vous souvenez du chapitre \ref{chapter:7} et de l'encadré \ref{box:association_embeded}, nous avons intégré l'utilisateur dans le produit. Mais ici, cela ne sert à rien sachant nous connaissons toujours l'utilisateur car il s'agit de l'utilisateur courant. Il n'y a pas lieu de l'ajouter car ce n'est pas efficace. Corrigeons cela en ajoutant un nouveau sérialiseur:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rails g serializer order_product
      \end{lstlisting}
    \end{scriptsize}

    Nous voulons que les informations sur les produits restent cohérentes avec celles que nous avons actuellement de sorte que nous puissions simplement en hériter le comportement comme cela:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # app/serializers/order_product_serializer.rb
      class OrderProductSerializer < OrderSerializer
      end
      \end{lstlisting}
    \end{scriptsize}

    De cette façon, les deux sérialiseurs seront maintenant lié et il suffira d'ajouter un champ à \verb|ProductSerializer| et il sera ajouté à \verb|OrderProductSerializer|. Maintenant, nous voulons supprimer l'utilisateur associé. Nous ajouterons simplement une méthode qui permet de faire cela\footnote{Pour plus d'informations, jettez un oeuil à la documentation de  ActiveModelSerializer}:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # app/serializers/order_product_serializer.rb
      class OrderProductSerializer < ProductSerializer
        def include_user?
          false
        end
      end
      \end{lstlisting}
    \end{scriptsize}

    Après avoir fait ce changement, nous devons dire au \verb|order_serializer| d'utiliser le serializer que nous venons de créer en passant simplement une option à l'association \verb|has_many| sur le \verb|order_serializer|:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # app/serializers/order_product_serializer.rb
      class OrderProductSerializer < ProductSerializer
        def include_user?
          false
        end
      end
      \end{lstlisting}
    \end{scriptsize}

    Et nos tests devraient continuer à passer:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rspec spec/controllers/api/v1/orders_controller_spec.rb
      ........

      Finished in 0.24024 seconds (files took 0.70072 seconds to load)
      8 examples, 0 failures
      \end{lstlisting}
    \end{scriptsize}

    \textit{Commitons} nos changements et passons à la section suivante:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ git add .
      $ git commit -m "Adds a custom order product serializer to remove the user association"
      \end{lstlisting}
    \end{scriptsize}

  \section{Envoyer un email de confirmation}

    La dernière section de ce chapitre sera d'envoyer un email de confirmation à l'utilisateur qui vient de créer une commande. Si vous voulez sauter cette étape et passer au chapitre \ref{chapter:9} suivant, allez-y! Cette section est plus à un échauffement.

    Vous êtes peut-être familier avec la manipulation d'email avec Rails, je vais essayer de rendre cela simple et rapide:

    Nouscommençons par créer le \verb|order_mailer|:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rails generate mailer order_mailer
      \end{lstlisting}
    \end{scriptsize}

    Pour faciliter le test de l'email, nous utiliserons une gemme appelée \href{https://github.com/email-spec/email-spec}{email\_spec}. Elle inclut un tas de méthodes utiles pour tester les emails.

    Donc d'abord ajoutons la gemme au \verb|Gemfile|:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # Gemfile
      # ...

      group :test do
        gem 'rspec-collection_matchers', '~> 1.1'
        gem 'rspec-rails', '~> 3.8'
        gem "email_spec"
        gem 'shoulda-matchers'
      end

      # ...
      \end{lstlisting}
    \end{scriptsize}

    Lancez maintenant la commande \verb|bundle install| pour installer toutes les dépendances. Je vais suivre \href{https://github.com/email-spec/email-spec#rspec-31}{les étapes de documentation} pour configurer la gemme. Lorsque vous avez terminé, votre fichier \verb|rails_helper.rb| devrait ressembler à ça:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # spec/rails_helper.rb

      require File.expand_path('../config/environment', __dir__)
      ENV['RAILS_ENV'] ||= 'test'
      # Prevent database truncation if the environment is production
      abort('The Rails environment is running in production mode!') if Rails.env.production?

      require 'spec_helper'
      require 'email_spec'
      require 'email_spec/rspec'
      require 'rspec/rails'

      # ...
      \end{lstlisting}
    \end{scriptsize}

    Maintenant, nous pouvons ajouter quelques tests pour les mails de commandes que nous venons de créer:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Test des mails de commande}]
      # spec/mailers/order_mailer_spec.rb
      require 'rails_helper'

      RSpec.describe OrderMailer, type: :mailer do
        include Rails.application.routes.url_helpers

        describe '.send_confirmation' do
          before(:all) do
            @user = FactoryBot.create :user
            @order = FactoryBot.create :order, user: @user
            @order_mailer = OrderMailer.send_confirmation(@order)
          end

          it 'should be set to be delivered to the user from the order passed in' do
            expect(@order_mailer).to deliver_to(@user.email)
          end

          it 'should be set to be send from no-reply@marketplace.com' do
            expect(@order_mailer).to deliver_from('no-reply@marketplace.com')
          end

          it "should contain the user's message in the mail body" do
            expect(@order_mailer).to have_body_text(/Order: ##{@order.id}/)
          end

          it 'should have the correct subject' do
            expect(@order_mailer).to have_subject(/Order Confirmation/)
          end

          it 'should have the products count' do
            expect(@order_mailer).to have_body_text(/You ordered #{@order.products.count} products:/)
          end
        end
      end
      \end{lstlisting}
    \end{scriptsize}

    J'ai simplement copié/collé les tests de la documentation et je l'ai adapté à nos besoins. Nous devons maintenant nous assurer que ces tests passent.

    Tout d'abord, nous ajoutons la méthode \verb|OrderMailer#send_confirmation|:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Implémetation de la méthode pour envoyer un mail lors de la création d'une commande}]
      # app/mailers/order_mailer.rb
      class OrderMailer < ApplicationMailer
        default from: 'no-reply@marketplace.com'
        def send_confirmation(order)
          @order = order
          @user = @order.user
          mail to: @user.email, subject: 'Order Confirmation'
        end
      end
      \end{lstlisting}
    \end{scriptsize}

    Après avoir ajouté ce code, nous devons maintenant ajouter les vues correspondantes. C'est une bonne pratique d'inclure une version texte (Listing \ref{lst:order_mailer_send_confirmation_text}) en plus de la version HTML (Listing \ref{lst:order_mailer_send_confirmation_html}).

    \begin{scriptsize}
      \begin{lstlisting}[caption={Vue de l'email de confirmation de commande au format texte}, label={lst:order_mailer_send_confirmation_text}]
      <%# app/views/order_mailer/send_confirmation.txt.erb %>
      Order: #<%= @order.id %>
      You ordered <%= @order.products.count %> products:
      <% @order.products.each do |product| %>
        <%= product.title %> - <%= number_to_currency product.price %>
      <% end %>
      \end{lstlisting}
    \end{scriptsize}

    \begin{scriptsize}
      \begin{lstlisting}[language=html, caption={Vue de l'email de confirmation de commande au format HTML}, label={lst:order_mailer_send_confirmation_html}]
      <!-- app/views/order_mailer/send_confirmation.html.erb -->
      <h1>Order: #<%= @order.id %></h1>
      <p>You ordered <%= @order.products.count %> products:</p>
      <ul>
        <% @order.products.each do |product| %>
          <li><%= product.title %> - <%= number_to_currency product.price %></li>
        <% end %>
      </ul>
      \end{lstlisting}
    \end{scriptsize}

    Maintenant, nos tests devraient passer:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rspec spec/mailers/order_mailer_spec.rb
      .....

      Finished in 0.24919 seconds (files took 0.75369 seconds to load)
      5 examples, 0 failures
      \end{lstlisting}
    \end{scriptsize}

    Et maintenant, il suffit d'appeler la méthode \verb|OrderMailer#send_confirmation| dans l'action de création sur le contrôleur des ordres:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # app/controllers/api/v1/orders_controller.rb
      class Api::V1::OrdersController < ApplicationController
        # ...

        def create
          order = current_user.orders.build(order_params)

          if order.save
            OrderMailer.send_confirmation(order).deliver
            render json: order, status: 201, location: [:api, current_user, order]
          else
            render json: { errors: order.errors }, status: 422
          end
        end

        # ...
      end
      \end{lstlisting}
    \end{scriptsize}

    Pour être sûr que nous n'avons rien cassé, lançons tous les tests:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rspec spec
      ..................................................................................................

      Finished in 1.82 seconds (files took 0.78532 seconds to load)
      98 examples, 0 failures
      \end{lstlisting}
    \end{scriptsize}

    \textit{Commitons} tout ce que nous venons de faire pour terminer cette section:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ git add .
      $ git commit -m "Adds order confirmation mailer"
      \end{lstlisting}
    \end{scriptsize}

  \section{Conclusion}

   Ca y est! Vous avez réussi! Vous pouvez vous applaudir. Je sais que ça a été long mais c'est presque finit, croyez moi.

   Sur les chapitres à venir, nous continuerons à travailler sur le modèle de commande pour ajouter des validations lors de la passation d'une commande. Certains scénarios sont:

   \begin{itemize}
     \item Que se passe-t-il lorsque les produits ne sont pas disponibles?
     \item Diminuer la quantité du produit en cours lors de la passation d'une commande
   \end{itemize}

   Le prochain chapitre sera court, mais il est très important pour la santé l'application. Alors ne le sautez pas.

\chapter{Améliorer les commandes}\label{chapter:9}

  Dans le chapitre \ref{chapter:8}, nous avons amélioré notre API pour passer des commandes et envoyer un e-mail de confirmation à l'utilisateur (juste pour améliorer l'expérience utilisateur). Ce chapitre va s'occuper de quelques validations sur le modèle de commande afin de s'assurer qu'elle est valide. C'est-à-dire:

  \begin{itemize}
    \item Diminuer la quantité du produit en cours lors de la passation d'une commande
    \item Que se passe-t-il lorsque les produits ne sont pas disponibles?
  \end{itemize}

  Nous aurons aussi besoin de mettre à jour un peu la sortie JSON pour les commandes Mais ne \textit{spoilons} pas la suite.

  Maintenant que tout est clair, on peut mettre les mains dans le cambouis. Vous pouvez cloner le projet jusqu'à ce point avec:

  \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ git clone https://github.com/madeindjs/market_place_api.git -b chapter8
    \end{lstlisting}
  \end{scriptsize}

  Créons une branche pour commencer

  \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ git checkout -b chapter9
    \end{lstlisting}
  \end{scriptsize}

  \section{Diminution de la quantité de produit}

    Dans cette partie nous travaillerons sur la mise à jour de la quantité du produit pour nous assurer que chaque commande livrera le produit réel. Actuellement, le modèle de produit n'a pas d'attribut de quantité, alors faisons-le:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rails generate migration add_quantity_to_products quantity:integer
      \end{lstlisting}
    \end{scriptsize}

    Attendez! N'exécutez pas encore cette migrations! Nous allons y apporter une petite modification. Comme bonne pratique, j'aime ajouter des valeurs par défaut pour la base de données juste pour être sûr de ne pas tout gâcher avec des valeurs nulles. C'est un cas parfait!

    Votre fichier de migration devrait ressembler à ceci:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # db/migrate/20181227092237_add_quantity_to_products.rb
      class AddQuantityToProducts < ActiveRecord::Migration[5.2]
        def change
          add_column :products, :quantity, :integer, default: 0
        end
      end
      \end{lstlisting}
    \end{scriptsize}

    Maintenant nous pouvons lancer la migration:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rake db:migrate
      \end{lstlisting}
    \end{scriptsize}

    Il est maintenant temps de diminuer la quantité du \verb|Product| une fois l' \verb|Order| passée. La première chose qui vous vient probablement à l'esprit est de le faire dans le modèle \verb|Order| et c'est une erreur fréquente. Lorsque vous travaillez avec des associations Many-to-Many, nous oublions totalement le modèle de jointure qui dans ce cas est \verb|Placement|. Le \verb|Placement| est un meilleur endroit pour gérer cela car nous avons accès à la commande et au produit. Ainsi, nous pouvons facilement diminuer le stock du produit.

    Avant de commencer à implémenter le code, nous devons changer la façon dont nous gérons la création de la commande car nous devons maintenant accepter une quantité pour chaque produit. Si vous vous souvenez de Listing \ref{lst:orders_controller_create}, nous attendons un tableau d'identifiants de produits. Je vais essayer de garder les choses simples et je vais envoyer un tableau de tableaux où la première position de chaque tableau interne sera l'identifiant du produit et la seconde la quantité.

    Un exemple rapide serait quelque chose comme cela:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      product_ids_and_quantities = [
        [1,4],
        [3,5]
      ]
      \end{lstlisting}
    \end{scriptsize}

    Ça va être difficile, alors restez avec moi. Construisons d'abord des tests unitaires:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # spec/models/order_spec.rb
      require 'rails_helper'

      RSpec.describe Order, type: :model do
        # ...

        describe '#build_placements_with_product_ids_and_quantities' do
          before(:each) do
            product_1 = FactoryBot.create :product, price: 100, quantity: 5
            product_2 = FactoryBot.create :product, price: 85, quantity: 10

            @product_ids_and_quantities = [[product_1.id, 2], [product_2.id, 3]]
          end

          it 'builds 2 placements for the order' do
            expect { order.build_placements_with_product_ids_and_quantities(@product_ids_and_quantities) }.to change { order.placements.size }.from(0).to(2)
          end
        end
      end
      \end{lstlisting}
    \end{scriptsize}

    Et maintenant l'implémentation

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # app/models/order.rb
      class Order < ApplicationRecord
        # ...

        # @param product_ids_and_quantities [Array] something like this
        #        `[[product_1.id, 2], [product_2.id, 3]]`. Where first item is
        #        `product_id` and the second is the quantity
        # @yield [Placement] placement build
        def build_placements_with_product_ids_and_quantities(product_ids_and_quantities)
          product_ids_and_quantities.each do |product_id_and_quantity|
            id, quantity = product_id_and_quantity # [1,5]
            placement = placements.build(product_id: id)
            yield placement if block_given?
          end
        end
      end
      \end{lstlisting}
    \end{scriptsize}

    Et maintenant, si nous lançons les tests, ils devraient passer:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      $ rspec spec/models/order_spec.rb
      ........

      Finished in 0.33759 seconds (files took 3.54 seconds to load)
      8 examples, 0 failures
      \end{lstlisting}
    \end{scriptsize}

    Les \verb|build_placements_with_product_ids_and_quantities| construiront les objets \verb|Placement| et une fois que nous déclencherons la méthode de sauvegarde de l'ordre, tout sera inséré dans la base de données. Une dernière étape avant de valider ceci est de mettre à jour \verb|orders_controller_spec| avec son implémentation.

    Tout d'abord, nous mettons à jour le fichier \verb|orders_controller_spec|:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # spec/controllers/api/v1/orders_controller_spec.rb
      require 'rails_helper'

      RSpec.describe Api::V1::OrdersController, type: :controller do
        # ...

        describe 'POST #create' do
          before(:each) do
            current_user = FactoryBot.create :user
            api_authorization_header current_user.auth_token

            product_1 = FactoryBot.create :product
            product_2 = FactoryBot.create :product
            order_params = {
              product_ids_and_quantities: [[product_1.id, 2], [product_2.id, 3]]
            }
            post :create, params: { user_id: current_user.id, order: order_params }
          end

          it 'embeds the two product objects related to the order' do
            expect(json_response[:products].size).to eql 2
          end

          # ...
        end
      end
      \end{lstlisting}
    \end{scriptsize}

    Nous devons ensuite mettre un peu à jour notre controlleur des commandes:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # app/controllers/api/v1/orders_controller.rb
      class Api::V1::OrdersController < ApplicationController
        # ...

        def create
          order = Order.create! user: current_user
          order.build_placements_with_product_ids_and_quantities(params[:order][:product_ids_and_quantities])

          if order.save
            order.reload # need to reload associations
            OrderMailer.send_confirmation(order).deliver
            render json: order, status: 201, location: [:api, current_user, order]
          else
            render json: { errors: order.errors }, status: 422
          end
        end
      end
      \end{lstlisting}
    \end{scriptsize}

    Notez que j'ai aussi supprimé la méthode \verb|OrdersController#order_params| qui devient inutile.

    Enfin et surtout, nous devons mettre à jour le fichier d'usine des produits afin d'attribuer une valeur de quantité élevée pour avoir au moins quelques produits en stock.

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # spec/factories/products.rb
      FactoryBot.define do
        factory :product do
          title { FFaker::Product.product_name }
          price { rand * 100 }
          published { false }
          user
          quantity { 5 }
        end
      end
      \end{lstlisting}
    \end{scriptsize}

    \textit{Commitons} nos changements avant d'aller plus loin:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ git add .
      $ git commit -m "Allows the order to be placed along with product quantity"
      \end{lstlisting}
    \end{scriptsize}

    Avez-vous remarqué que nous ne mettons pas à jour la quantité des produits? Actuellement, il n'y a aucun moyen d'en faire le suivi. Cela peut être corrigé très facilement, en ajoutant simplement un attribut de quantité au modèle \verb|Placement| de sorte que pour chaque produit, nous sauvegardons la quantité correspondante. Commençons par créer la migration:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rails generate migration add_quantity_to_placements quantity:integer
      \end{lstlisting}
    \end{scriptsize}

    Comme pour la migration des attributs de quantité de produit, nous devrions ajouter une valeur par défaut égale à 0. N'oubliez pas que c'est facultatif mais c'est mieux. Le fichier de migration devrait ressembler à cela:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # db/migrate/20181227104830_add_quantity_to_placements.rb
      class AddQuantityToPlacements < ActiveRecord::Migration[5.2]
        def change
          add_column :placements, :quantity, :integer, default: 0
        end
      end
      \end{lstlisting}
    \end{scriptsize}

    Lancez ensuite la migration:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rake db:migrate
      \end{lstlisting}
    \end{scriptsize}

    Documentons l'attribut \verb|quantity| par un test unitaire:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # spec/models/placement_spec.rb
      # ...
      RSpec.describe Placement, type: :model do
        # ...
        it { should respond_to :quantity }
        # ...
      end
      \end{lstlisting}
    \end{scriptsize}

    Il ne nous reste plus qu'à mettre à jour la méthode \verb|build_placements_with_product_ids_and_quantities| pour ajouter la quantité pour les placements:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # app/models/order.rb
      class Order < ApplicationRecord
        # ...

        def build_placements_with_product_ids_and_quantities(product_ids_and_quantities)
          product_ids_and_quantities.each do |product_id_and_quantity|
            product_id, quantity = product_id_and_quantity # [1,5]
            placements.build(product_id: product_id, quantity: quantity)
          end
        end
      end
      \end{lstlisting}
    \end{scriptsize}

    Maintenant, nos tests devarient passer:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rspec spec/models/order_spec.rb
      ........

      Finished in 0.09898 seconds (files took 0.74936 seconds to load)
      8 examples, 0 failures
      \end{lstlisting}
    \end{scriptsize}

    \textit{Commitons} nos changement:

    \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ git add .
      $ git commit -m "Adds quantity to placements"
      \end{lstlisting}
    \end{scriptsize}

    \subsection{Étendre le modèle de placement}

    Il est temps de mettre à jour la quantité du produit une fois la commande enregistrée ou plus précisément: une fois le placement créé. Pour ce faire, nous allons ajouter une méthode et la connecter au \textit{callback} \verb|after_create|.

    Commençons par mettre à jour notre usine de placement pour qu'elle soit plus logique:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Mise à jour de l'usine des placements}]
      # spec/factories/placements.rb
      FactoryBot.define do
        factory :placement do
          order
          product
          quantity { 1 }
        end
      end
      \end{lstlisting}
    \end{scriptsize}

    Et puis nous pouvons simplement ajouter quelques tests:

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Test de la mise à jour de la quantité des produits}]
      # spec/models/placement_spec.rb
      # ...

      RSpec.describe Placement, type: :model do
        # ...
        it { should respond_to :quantity }
        # ...
        describe '#decrement_product_quantity!' do
          it 'decreases the product quantity by the placement quantity' do
            product = placement.product
            expect { placement.decrement_product_quantity! }.to change { product.quantity }.by(-placement.quantity)
          end
        end
      end
      \end{lstlisting}
    \end{scriptsize}

    La mise en œuvre est assez simple comme le montre le lisitng \ref{lst:placement_decrement_product_quantity}.

    \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Implémentation de la mise à jour de la quantité des produits}, label={lst:placement_decrement_product_quantity}]
      # app/models/placement.rb
      class Placement < ApplicationRecord
        # ...
        after_create :decrement_product_quantity!

        def decrement_product_quantity!
          product.decrement!(:quantity, quantity)
        end
      end
      \end{lstlisting}
    \end{scriptsize}


















\end{document}
