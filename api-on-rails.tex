\documentclass[]{report}
\title{\textbf{API on Rails}\\ Construction d'API REST avec Rails}
\author{Alexandre Rousseau}

\usepackage{graphicx}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{tikz}
%\usepackage{listings}
\usepackage[pdf]{graphviz}
\usepackage{appendix}
\usepackage{csquotes}
\usepackage{tcolorbox}
\usepackage{listings}
\usepackage{tabularx}

\showboxdepth=\maxdimen

\pagestyle{headings}

% \hypersetup{
%     colorlinks,
%     citecolor=black,
%     filecolor=black,
%     urlcolor=black
% }
\usepackage{lstautogobble}
\usepackage{color}
\lstset{
  autogobble,% remove leading space indentation
  breaklines=true, % sets automatic line breaking
  captionpos=b, % sets the caption-position to bottom
  frame=single, % adds a frame around the code
  showtabs=false, % show tabs within strings adding particular underscores
  tabsize=2, % sets default tabsize to 2 spaces
}

\begin{document}


\maketitle

\newpage

\tableofcontents
\newpage

\pagenumbering{arabic}

\chapter{Avant-propos}

  \textquote{API on Rails: Construction d'API REST avec Rails} est une mise à jour et une traduction française du livre \href{http://apionrails.icalialabs.com/book/}{\textquote{APIs on Rails: Building REST APIs with Rails}}. Celui-ci fut initialement publié en 2014 par \href{https://twitter.com/kurenn}{Abraham Kuri} sous les licences \href{http://opensource.org/licenses/MIT}{MIT} et \href{http://people.freebsd.org/~phk/}{Beerware}.

  \section{A propos de l'autheur original}

    \href{https://twitter.com/kurenn}{Abraham Kuri} est un développeur de Rails avec 5 ans d'expérience. Son expérience inclut le travail en tant que freelance dans la construction de produits logiciels et plus récemment dans la collaboration au sein de la communauté open source. Il a développé \href{http://icalialabs.github.io/furatto/}{Furatto} un cadre frontal construit avec Sass, \href{https://github.com/IcaliaLabs/sabisu-rails}{Sabisu} la prochaine génération d'explorateur d'API pour votre application Rails et a collaboré sur d'autres projets. Diplômé en informatique d'ITESM, il a fondé deux sociétés au Mexique (\href{http://icalialabs.com/}{Icalia Labs} et \href{http://codeandomexico.org/}{Codeando Mexico}).

  \section{Droits d'auteur et licence}

    Cette traduction est disponnible sous \href{http://opensource.org/licenses/MIT}{licence MIT}. Tout le code source de ce livre est disponnible au format \href{https://fr.wikipedia.org/wiki/LaTeX}{\LaTeX} sur \href{https://github.com/madeindjs/api_on_rails}{ce répertoire Github}

    \begin{tcolorbox}{The MIT License}
      Copyright (c) 2018 Alexandre Rousseau

      Permission est accordée, à titre gratuit, à toute personne obtenant une copie de ce logiciel et la documentation associée, pour faire des modification dans le logiciel sans restriction et sans limitation des droits d’utiliser, copier, modifier, fusionner, publier, distribuer, concéder sous licence, et / ou de vendre les copies du Logiciel, et à autoriser les personnes auxquelles le Logiciel est meublé de le faire, sous réserve des conditions suivantes:

      L’avis de copyright ci-dessus et cette autorisation doit être inclus dans toutes les copies ou parties substantielles du Logiciel.

      LE LOGICIEL EST FOURNI «TEL QUEL», SANS GARANTIE D’AUCUNE SORTE, EXPLICITE OU IMPLICITE, Y COMPRIS, MAIS SANS S’Y LIMITER, LES GARANTIES DE QUALITÉ MARCHANDE, ADAPTATION À UN USAGE PARTICULIER ET D’ABSENCE DE CONTREFAÇON. EN AUCUN CAS LES AUTEURS OU TITULAIRES DU ETRE TENU RESPONSABLE DE TOUT DOMMAGE, RÉCLAMATION OU AUTRES RESPONSABILITÉ, SOIT DANS UNE ACTION DE CONTRAT, UN TORT OU AUTRE, PROVENANT DE, DE OU EN RELATION AVEC LE LOGICIEL OU L’UTILISATION OU DE TRANSACTIONS AUTRES LE LOGICIEL.
    \end{tcolorbox}

\chapter{Introduction}

  Bienvenue sur APIs on Rails, un tutoriel sous stéroïdes sur la façon de construire votre prochaine API avec Rails. Le but de ce livre est de vous fournir une méthodologie pour développer une API RESTful en suivant les meilleures pratiques existantes. Lorsque vous en aurez fini avec les API Rails, vous devriez être en mesure de créer votre propre API et de l'intégrer à n'importe quel client comme un navigateur Web ou votre une application mobile. Le code généré est construit sur Ruby on Rails 5 qui est la version actuelle, pour plus d'informations à ce sujet, consultez \href{http://rubyonrails.org/}{rubyonrails.org}. La version la plus récente de APIs on Rails se trouve sur \href{https://apionrails.icalialabs.com}{apionrails.icalialabs.com} ; n'oubliez pas de mettre à jour votre version hors ligne si c'est le cas.

  L'intention de ce livre n'est pas d'enseigner comment construire une API avec Rails, mais plutôt de vous apprendre comment construire une API évolutive et maintenable avec Rails. Ce qui signifie améliorer vos connaissances actuelles Rails  sur cette approche. Dans ce voyage que nous allons faire, vous apprendrez à le faire

  \begin{itemize}
    \item Construire des réponses JSON
    \item Utiliser Git pour le contrôle de version
    \item Test de vos points finaux
    \item Optimiser et mettre en cache l'API
  \end{itemize}

  Je vous recommande fortement d'aller étape par étape sur ce livre. Essayez de ne pas sauter des chapitres car je mentionne des conseils et des faits intéressants pour améliorer vos compétences. Vous pouvez vous considérer comme le personnage principal d'un jeu vidéo et avec chaque chapitre, vous obtiendrez un niveau supérieur.

  Dans ce premier chapitre, je vais vous expliquer comment configurer votre environnement au cas où vous ne l'auriez pas déjà. Nous allons ensuite créer l'application appelée \verb|market_place_api|. Je soulignerai tous mes efforts pour vous enseigner toutes les meilleures pratiques que j'ai apprises au cours des années, ce qui signifie qu'immédiatement après avoir initialisé (Section 1.3) le projet, nous commencerons à le suivre avec Git (Section \ref{setup_git}).

  Dans les prochains chapitres, nous allons construire l'application en suivant un *workflow* simple que j'utilise quotidiennement. Nous développerons toute l'application en utilisant le développement piloté par les tests (TDD), en commençant par expliquer l’intérêt d'utiliser une API pour votre prochain projet et de choisir un format de réponse adapté comme le JSON ou le XML. Du chapitre 3 au chapitre 8, nous mettrons les mains dans le cambouis et nous compléterons les bases de l'application en construisant tous les points finaux nécessaires en sécurisant l'accès à l'API et en gérant l'authentification par échange d'en-têtes. Enfin, dans le dernier chapitre (Chapitre 11), nous ajouterons quelques techniques d'optimisation pour améliorer les réponses du serveur.

  L'application finale grattera la surface pour être une place de marché où les utilisateurs seront en mesure de passer des commandes, télécharger des produits et plus encore. Il existe de nombreuses options pour créer une boutique en ligne comme \href{http://shopify.com/}{Shopify}, \href{http://spreecommerce.com/}{Spree} ou \href{http://magento.com/}{Magento}.

  À la fin ou au cours du processus (cela dépend vraiment de votre expertise), vous allez vous améliorer et être en mesure de mieux comprendre certaines des meilleures ressources Rails. J'ai aussi pris certaines des pratiques que j'ai trouvé et je vous les ai apportées :

  \begin{itemize}
    \item \href{http://railscasts.com/}{Railscasts}
    \item \href{http://codeschool.com/}{CodeSchool}
    \item \href{http://jsonapi.org/format/}{JSON API}
  \end{itemize}

  \section{Conventions sur ce livre}

    Les conventions de ce livre sont basées sur celles du Tutoriel Ruby on Rails. Dans cette section, j'en mentionnerai quelques-unes qui ne sont peut-être pas aussi claires.

    Je vais utiliser de nombreux exemples en utilisant des ligne de commande. Je ne vais pas traiter avec Windows \verb|cmd| (désolé les gars), donc je vais baser tous les exemples en utilisant l'invite de ligne de commande de style Unix, comme suit:

    \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ echo "A command-line command"
    A command-line command
    \end{lstlisting}
    \end{scriptsize}

    J'utiliserai quelques lignes directrices relatives au langage Ruby, ce que j'entends par là:

    \begin{itemize}
      \item \textquote{Éviter} signifie que tu n'es pas censé le faire.
      \item \textquote{Préférer} indique que parmi les 2 options, la première est la plus appropriée.
      \item \textquote{Utiliser} signifie que vous êtes en mesure d'utiliser la ressource.
    \end{itemize}

    Si pour une raison quelconque vous rencontrez des erreurs lors de l'exécution d'une commande, plutôt que d'essayer d'expliquer tous les résultats possibles, je vous recommanderai de *"google it"* (ce que je ne considère pas comme une mauvaise pratique). Mais si vous avez envie de prendre une bière ou si vous rencontrez des problèmes avec ce tutoriel, vous pouvez toujours \href{http://twitter.com/kurenn}{me tweeter} ou \href{mailto:kurenn@icalialabs.com}{m'envoyer un email}.

  \section{Pour commencer}

    L'une des parties les plus douloureuses pour presque tous les développeurs est de tout mettre en place, mais tant que vous le faites, les prochaines étapes devraient être un jeu d'enfant et bien récompensé. Afin de vous faciliter la tâche et de vous motiver, nous utiliserons un script bash que je gère, appelé Kaishi, qui inclut tous les outils nécessaires (encadré \ref{box:kaishi_tools}) et plus encore pour configurer votre environnement de développement, il ne fonctionne actuellement que pour Mac OS:

    \begin{tcolorbox}{Outils de développement Kaishi}\label{box:kaishi_tools}
      \begin{itemize}
        \item \href{https://github.com/robbyrussell/oh-my-zsh}{oh-my-zsh}  en tant que Shell par défault
        \item \href{http://brew.sh/}{Homebrew} pour la gestion des paquets
        \item \href{http://git-scm.com/}{Git} en tant que gestionnaire de base de données
        \item \href{http://www.postgresql.org/}{Postresql} en tant que gestionnaire de base de données
        \item \href{http://www.vim.org/}{Vim} pour l'édition de texte
        \item \href{http://www.imagemagick.org/}{ImageMagick} pour le traitement d'images
        \item \href{https://github.com/sstephenson/rbenv}{Rbenv} pour la gestion de l'environnement rubis
        \item \href{http://bundler.io/}{Bundler}
        \item \href{https://github.com/ddollar/foreman}{Foreman} pour l'exécution d'applications
        \item \href{http://rubyonrails.org/}{Rails} pour la création de n'importe quelle application rails
        \item \href{https://toolbelt.heroku.com/}{Heroku} pour interagir avec l'API Heroku
        \item \href{https://github.com/IcaliaLabs/railsAppCustomGenerator}{RailsAppCustomGenerator} pour initialiser n'importe quelle application Rails avec le modèle d'Icalia
        \item \href{http://pow.cx/}{Pow} pour exécuter des applications locales en local comme un super-héros
      \end{itemize}
    \end{tcolorbox}

  \section{Environnements de développement}

    \subsection{Editeurs de texte et Terminal}

      Il existe de nombreux cas dans lesquels les environnements de développement peuvent différer d'un ordinateur à l'autre. Ce n'est pas le cas avec les éditeurs de texte ou les IDE. Je pense que pour le développement de Rails un IDE est beaucoup trop lourd tandis que d'autres pourraient trouver que c'est la meilleure façon de développer. Si c'est votre cas, je vous recommande d'essayer avec \href{http://www.aptana.com/products/radrails}{RadRails} ou \href{http://www.jetbrains.com/ruby/index.html}{RubyMine}, les deux sont bien soutenus et possèdent de nombreuses intégrations par défault.

      Maintenant pour ceux qui sont plus comme moi, je peux vous dire qu'il y a beaucoup d'options disponibles que vous pouvez personnaliser via des plugins et plus.

      \begin{description}
        \item[Editeur de texte] J'utilise personnellement \href{http://www.vim.org/}{Vim} comme éditeur par défaut avec \href{https://github.com/carlhuda/janus}{Janus} qui ajoute et gère plusieurs des plugins que vous allez probablement utiliser. Au cas où vous n'êtes pas un fan de Vim comme moi, il y a beaucoup d'autres solutions comme \href{http://www.sublimetext.com/}{Sublime Text} qui est une multiplateforme facile à apprendre et à personnaliser (c'est probablement votre meilleure option), il est fortement inspiré par \href{http://macromates.com/}{TextMate} (disponible uniquement pour Mac OS). Une troisième option est d'utiliser un éditeur de texte plus récent des gars de \href{http://gitub.com/}{Github} appelé \href{https://atom.io/}{Atom}, c'est un éditeur de texte prometteur fait en Javascript. Il est facile à personnaliser pour répondre à vos besoins, faites un essai. N'importe lequel des éditeurs que je vous présente fera le travail, donc je vous laisserai décider lequel vous convient.

        \item[Terminal] Si vous avez décidé d'utiliser \href{http://icalialabs.github.io/kaishi/}{kaishi} pour paramétrer l'environnement, vous remarquerez qu'il définit le shell par défaut à \verb|zsh|, ce que je recommande vivement. Pour le terminal, je ne suis pas un fan de l'application Terminal par défault sous Mac OS. Je recommande \href{http://www.iterm2.com/#/section/home}{iTerm2}, qui est un remplacement de terminal pour Mac OS. Si vous êtes sous Linux, vous avez probablement déjà un beau terminal, mais le défaut devrait fonctionner très bien.
      \end{description}

    \subsection{Navigateur web}

      Quand il s'agit de navigateurs, je dirais \href{https://www.google.com/intl/en/chrome/browser/}{Chrome} immédiatement. Mais d'autres développeurs peuvent dire \href{http://www.mozilla.org/en-US/firefox/new/}{Firefox} ou même \href{https://www.apple.com/safari/}{Safari}. N'importe lequel d'entre eux vous aidera à construire l'application que vous voulez. Ils porposent tous un bon inspecteur pour le DOM, un analyseur de réseau et de nombreuses autres fonctionnalités que vous connaissez peut-être déjà.

    \subsection{Note sur les outils}

      Très bien, je comprends que vous ne voudrez peut-être pas inclure tous les paquets qui viennent avec \href{http://icalialabs.github.io/kaishi/}{kaishi}, et c'est juste, ou peut-être que vous avez déjà quelques outils installés, eh bien je vais vous décrire comment installer le bare bones dont vous avez besoin pour commencer:

    \subsection{Note sur les outils}

      Très bien, je comprends que vous ne voudrez peut-être pas inclure tous les paquets qui viennent avec \href{http://icalialabs.github.io/kaishi/}{kaishi}, et c'est normal. Ou peut-être que vous avez déjà quelques outils installés. Je vais vous décrire comment installer seulment ce dont vous avez besoin pour commencer:

    \subsection{Gestionnaire de paquets}

      \begin{description}
        \item[Mac OS] Il existe de nombreuses options pour gérer la façon dont vous installez les paquets sur votre Mac, comme \href{https://www.macports.org/}{Mac Ports} ou \href{http://brew.sh/}{Homebrew}. Les deux sont de bonnes options, mais je choisirais la dernière, j'ai rencontré moins de problèmes lors de l'installation de logiciels et de sa gestion. Pour installer \verb|brew| il suffit d'exécuter la commande ci-dessous:
        \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ ruby -e "$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)"
        \end{lstlisting}
        \end{scriptsize}
        \item[Linux] Vous êtes quasiment prêts! Peu importe si vous utilisez \verb|apt|, \verb|pacman|, \verb|yum|, tant que vous vous sentez à l'aise avec lui et que vous savez comment installer des paquets pour pouvoir continuer à avancer.
      \end{description}

    \subsection{Git}
      \label{setup_git}

      Nous utiliserons beaucoup Git, et vous devriez aussi l'utiliser non seulement pour le but de ce tutoriel mais pour tout vos projet.

      Instalation de Git sous Mac OS:
      \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ brew install git
      \end{lstlisting}
      \end{scriptsize}

      Instalation de Git sous Linux:
      \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ sudo apt-get install git
      \end{lstlisting}
      \end{scriptsize}

    \subsection{Ruby}

      Il existe de nombreuseuses façons d'installer et de gérer Ruby, et maintenant vous devriez probablement avoir une version installée (1.8 si vous êtes sous Mac OS). Pour connaître votre version, tapez simplement:

      \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ ruby -v
      \end{lstlisting}
      \end{scriptsize}

      Rails 5 nécessite l'installation de la version 2.2.2 ou supérieure. Pour l'installer, je vous recommande de commencer à utiliser \href{http://rvm.io/}{Ruby Version Manager (RVM)} ou \href{http://rbenv.org/}{rbenv}. Ces outils vous permettrons d'installer plusieurs versions de \verb|ruby|. J'ai récemment changé de RVM à rbenv et c'est super, donc n'importe laquelle de ces deux options que vous choisirez est bonne. Dans ce tutoriel, nous allons utiliser rbenv.

      Note pour Mac OS: si vous utilisez Mac, n'oubliez pas que vous devez avoir installé les \href{https://developer.apple.com/downloads/}{outils en ligne de commande pour Xcode}.


      \subsubsection{Mac OS}

        Pour commencer l'installation de ruby, tapez:

        \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ rbenv install 2.1.2
        \end{lstlisting}
        \end{scriptsize}

        Ensuite, vous devez configurer la version de ruby qui vient d'être installée comme version par défaut:

        \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ rbenv global 2.1.2
        $ rbenv rehash
        \end{lstlisting}
        \end{scriptsize}

        La commande \verb|rehash| est supposée s'exécuter à chaque fois que vous installez une nouvelle version de Ruby ou une Gem. Cela semble beaucoup ? Jetez un coup d'œil à la formule de brasserie \href{https://github.com/sstephenson/rbenv-gem-rehash}{rbenv-gem-rehash-rehash} pour atténuer ce problème.\footnote{Pour plus d'informations sur la personnalisation ou d'autres types d'installation, consultez la \href{https://github.com/sstephenson/rbenv}{documentation du projet}.}.

      \subsubsection{Linux}

        La première étape est de configurer quelques dépendances pour Ruby:

        \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ sudo apt-get update
        $ sudo apt-get install git-core curl zlib1g-dev build-essential libssl-dev \
                            libreadline-dev libyaml-dev libsqlite3-dev sqlite3 \
                            libxml2-dev libxslt1-dev libcurl4-openssl-dev zlib1g-dev \
                            python-software-properties
        \end{lstlisting}
        \end{scriptsize}

        Ensuite, vouss pouvez installer la dernière version de Ruby:

        \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ cd
        $ git clone git://github.com/sstephenson/rbenv.git .rbenv
        $ echo 'export PATH="$HOME/.rbenv/bin:$PATH"' >> ~/.bash_profile
        $ echo 'eval "$(rbenv init -)"' >> ~/.bash_profile

        $ git clone git://github.com/sstephenson/ruby-build.git ~/.rbenv/plugins/ruby-build
        $ echo 'export PATH="$HOME/.rbenv/plugins/ruby-build/bin:$PATH"' >> ~/.bash_profile
        $ source ~/.bash_profile

        $ rbenv install 2.5.3
        $ rbenv global 2.5.3
        \end{lstlisting}
        \end{scriptsize}

        Si tout s'est bien passé, il est temps d'installer le reste des dépendances que nous allons utiliser.

      \subsubsection{Gems, Rails et bibliothèques manquantes}

        Tout d'abord, nous mettons à jour les Gems sur l'ensemble du système:

        \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ gem update --system
        \end{lstlisting}
        \end{scriptsize}

        Dans la plupart des cas, si vous êtes sous Mac OS, vous devriez installer des bibliothèques supplémentaires:

        \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ brew install libtool libxslt libksba openssl
        \end{lstlisting}
        \end{scriptsize}

        Nous installons ensuite les gems nécessaires et ignorons la documentation pour chaque gemme :

        \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ printf 'gem: --no-document' >> ~/.gemrc
        $ gem install bundler
        $ gem install foreman
        $ gem install rails -v 5.2
        \end{lstlisting}
        \end{scriptsize}

        Vérifiez que tout fonctionne bien:

        \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ rails -v 5.2
        5.2.0
        \end{lstlisting}
        \end{scriptsize}

      \subsubsection{Bases de données}

        Je vous recommande fortement d'installer \href{http://www.postgresql.org/}{Postgresql} pour gérer vos bases de données, mais pour plus de simplicité nous allons utiliser \href{http://www.sqlite.org/}{SQlite}. Si vous utilisez Mac OS, vous devriez être prêt à partir, au cas où vous êtes sous Linux, ne vous inquiétez pas, on vous guide:

        \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ sudo apt-get install libxslt-dev libxml2-dev libsqlite3-dev
        \end{lstlisting}
        \end{scriptsize}

        ou

        \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ sudo yum install libxslt-devel libxml2-devel libsqlite3-devel
        \end{lstlisting}
        \end{scriptsize}

  \section{Initialisation du projet}

    L'initialisation d'une application Rails doit être assez simple pour vous, si ce n'est pas le cas, voici un tutoriel super rapide (Listing \ref{rails_new}).

    Sachez que nous utiliserons \href{http://rspec.info/}{Rspec} comme suite de test, alors assurez-vous d'inclure l'option \verb|-T| lors de la création de l'application rails.

    \begin{scriptsize}
    \begin{lstlisting}[language=bash, caption={Initialisation du projet avec 'rails new'.}, label={rails_new}]
    $ mkdir ~/workspace
    $ cd workspace
    $ rails new market_place_api -T
    \end{lstlisting}
    \end{scriptsize}

    Comme vous pouvez le deviner, les commandes ci-dessus (Listing \ref{rails_new}) génèreront les éléments indispensables de votre application Rails. La prochaine étape est d'ajouter quelques gems que nous utiliserons pour construire l'api.

    \subsection{Installer Pow ou Prax}\label{subsection:install_pow}

      Vous pouvez vous demander, pourquoi diable voudrais-je installer ce type de paquet? La réponse est simple. Nous allons travailler avec des \href{http://en.wikipedia.org/wiki/Subdomain}{sous-domaines}. \href{http://pow.cx/}{Pow} et \href{https://github.com/ysbaddaden/prax.cr}{Prax} vont nous aider a faire cela très facilement.

      \subsubsection{Installer Pow}

        Pow ne fonctionne que sous Mac OS, mais ne vous inquiétez pas, il existe une alternative qui imite les fonctionnalités sous Linux. Pour l'installer, tapez simplement:

        \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ curl get.pow.cx | sh
        \end{lstlisting}
        \end{scriptsize}

        Et c'est tout ce que vous avez à faire. Il suffit d'établir un lien symbolique avec l'application pour configurer l'application Rack.

        D'abord vous allez dans le répertoire \verb|~/.pow|:

        \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ cd ~/.pow
        \end{lstlisting}
        \end{scriptsize}

        Ensuite, vous pouvez créer le \href{http://en.wikipedia.org/wiki/Symbolic_link}{lien symbolique}

        \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ ln -s ~/workspace/market_place_api
        \end{lstlisting}
        \end{scriptsize}

        N'oubliez pas de changer le répertoire utilisateur pour celui qui correspond au votre. Vous pouvez maintenant accéder à l'application via \href{http://market_place_api.dev/}{http://market\_place\_api.dev}. Votre application devrait être en cours d'exécution comme celle illustrée à la Figure \ref{rails_new}.

      \subsubsection{Installer Pax}

        Pour les utilisateurs de Linux uniquement, \href{https://github.com/ysbaddaden/prax.cr}{Prax} distribue des paquet déjà compilé pour les distribution Debian / Ubuntu. Il suffit donc de télécharger le paquet \verb|.deb| et de l'installer avec \verb|dpkg|.

        \begin{scriptsize}
        \begin{lstlisting}[language=bash, breaklines]
        $ cd /tmp
        $ wget https://github.com/ysbaddaden/prax.cr/releases/download/v0.8.0/prax_0.8.0-1_amd64.deb
        $ sudo dpkg -i prax_0.8.0-1_amd64.deb
        \end{lstlisting}
        \end{scriptsize}

        Ensuite, il ne nous reste plus qu'à lier les applications:

        \begin{scriptsize}
        \begin{lstlisting}[language=bash]
        $ cd ~/workspace/market_place_api
        $ prax link
        \end{lstlisting}
        \end{scriptsize}

        Si vous voulez démarrer le prax server automatiquement, ajoutez cette ligne au fichier \verb|.profile|:

        \begin{scriptsize}
        \begin{lstlisting}
        prax start
        \end{lstlisting}
        \end{scriptsize}

        Lors de l'utilisation de \href{https://github.com/ysbaddaden/prax.cr}{Prax}, vous devez spécifier le port de l'URL, dans ce cas-ci: \href{http://market_place_api.dev:3000/}{http://market\_place\_api.dev:3000}:

        Vous devriez voir l'application en marche, voir Figure \ref{fig:pow_running}.

        \begin{figure}
          \includegraphics[width=\linewidth]{img/pow_running.png}
          \caption{http://market\_place\_api.dev/}
          \label{fig:pow_running}
        \end{figure}

        Une fois l'application Rails créée, l'étape suivante consiste à ajouter une Gem simple mais très puissante pour sérialiser les ressources que nous allons exposer sur l'API. La Gem s'appelle \verb|active_model_serializers|. C'est un excellent choix pour la construction de ce type d'application car la librairie est bien entretenu et la \href{https://github.com/rails-api/active_model_serializers}{documentation} est incroyable.

        Votre \verb|Gemfile| devrait donc ressembler à ceci (Listing \ref{listing:gemfile_active _model_serializers}) après avoir ajouté la gemme \verb|active _model_serializers|:


        \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Le Gemfile par défaut avec la Gem des sérialiseurs.}, label={listing:gemfile_active _model_serializers}, breaklines]
        source 'https://rubygems.org'
        git_source(:github) { |repo| "https://github.com/#{repo}.git" }

        ruby '2.5.3'

        # Bundle edge Rails instead: gem 'rails', github: 'rails/rails'
        gem 'rails', '~> 5.2.0'
        # Use sqlite3 as the database for Active Record
        gem 'sqlite3'
        # Use Puma as the app server
        gem 'puma', '~> 3.11'
        # Use SCSS for stylesheets
        gem 'sass-rails', '~> 5.0'
        # Use Uglifier as compressor for JavaScript assets
        gem 'uglifier', '>= 1.3.0'

        # Api gems
        gem 'active_model_serializers'

        # ...
        \end{lstlisting}
        \end{scriptsize}

        Notez que j'enlève les gemmes \verb|jbuilder| et \verb|turbolinks| et \verb|coffee-rails|. Nous n'allons pas les utiliser.

        C'est une bonne pratique aussi d'inclure la version ruby utilisée sur l'ensemble du projet, ce qui empêche les dépendances de casser si le code est partagé entre différents développeurs, que ce soit pour un projet privé ou public.

        Il est également important que vous mettiez à jour le Gemfile pour regrouper les différentes gemmes dans l'environnement correct (Listing \ref{listing:gemfile_active _group}) :

        \begin{scriptsize}
        \begin{lstlisting}[language=ruby, caption={Le Gemfile mis à jour pour différents groupes.}, label={listing:gemfile_active _group}, breaklines]
        # ...
        group :development do
          gem 'sqlite3'
        end
        # ...
        \end{lstlisting}
        \end{scriptsize}

        Ceci, comme vous vous en souvenez peut-être, empêchera l'installation ou l'utilisation de sqlite lorsque vous déployez votre application chez un fournisseur de serveurs comme Heroku\footnote{En raison de la structure de l'application, nous n'allons déployer l'application sur aucun serveur, mais nous allons utiliser \href{http://pow.cx/}{Pow} de \href{https://basecamp.com/}{Basecamp}. Si vous utilisez Linux, il existe une solution similaire appelée \href{https://github.com/ysbaddaden/prax.cr}{Prax} par \href{https://github.com/ysbaddaden}{ysbaddaden}. Voir la section \ref{subsection:install_pow}}.

        \begin{displayquote}
          Pow est un serveur Rack zéro-configuration pour Mac OS X. Servez vos applications localement en moins d'une minute. - \href{https://basecamp.com/}{Basecamp}
        \end{displayquote}

        Une fois cette configuration configurée, il est temps d'exécuter la commande d'installation du paquet pour intégrer les dépendances correspondantes:

        \begin{scriptsize}
        \begin{lstlisting}[language=bash, breaklines]
        $ bundle install
        \end{lstlisting}
        \end{scriptsize}

        Une fois que la commande a terminé son exécution, il est temps de commencer à suivre le projet avec git (Section \ref{section:git})

  \section{Contrôle de version}\label{section:git}

    Rappelez-vous que Git vous aide à suivre et à maintenir l'historique de votre code. Gardez à l'esprit que le code source de l'application est publié sur Github. Vous pouvez suivre le référentiel sur \href{https://github.com/madeindjs/market_place_api}{github.com/madeindjs/market\_place\_api}

    À ce stade, je suppose que vous avez déjà configuré git et que vous êtes prêt à l'utiliser pour suivre le projet. Si ce n'est pas votre cas, suivez ces étapes de première installation:

    \begin{scriptsize}
    \begin{lstlisting}[language=bash, breaklines]
    $ git config --global user.name "Type in your name"
    $ git config --global user.email "Type in your email"
    $ git config --global core.editor "vim"
    \end{lstlisting}
    \end{scriptsize}

    Il est donc temps d'initier le projet avec Git. N'oubliez pas de naviguer dans le répertoire racine de l'application \verb|market_place_api|:

    \begin{scriptsize}
    \begin{lstlisting}[language=bash, breaklines]
    $ git init
    Initialized empty Git repository in ~/workspace/market_place_api/.git/
    \end{lstlisting}
    \end{scriptsize}

    L'étape suivante est d'ignorer certains fichiers que nous ne voulons pas suivre. Votre fichier \verb|.gitignore| devrait ressembler à celui montré ci-dessous (Listing \ref{lstlisting:gitignore}):

    \begin{scriptsize}
    \begin{lstlisting}[breaklines, caption={La version modifiée du fichier .gitignore}, label={lstlisting:gitignore}]
    # Ignore bundler config.
    /.bundle

    # Ignore the default SQLite database.
    /db/*.sqlite3
    /db/*.sqlite3-journal

    # Ignore all logfiles and tempfiles.
    /log/*
    /tmp/*
    !/log/.keep
    !/tmp/.keep

    # Ignore uploaded files in development
    /storage/*

    /node_modules
    /yarn-error.log

    /public/assets
    .byebug_history

    # Ignore master key for decrypting credentials and more.
    /config/master.key
    \end{lstlisting}
    \end{scriptsize}

    Après avoir modifié le fichier \verb|.gitignore|, il suffit d'ajouter les fichiers et de valider les modifications. Les commandes nécessaires sont indiquées ci-dessous:

    \begin{scriptsize}
    \begin{lstlisting}[language=bash, breaklines]
    $ git add .
    $ git commit -m "Initial commit"
    \end{lstlisting}
    \end{scriptsize}

    Bonne pratique : J'ai appris que commencer un message par un verbe au présent décrit ce que fait le commit et non ce qu'il a fait. De cette façon il est plus facile de lire et de comprendre l'histoirique du projet (ou du moins pour moi). Je vais suivre cette pratique jusqu'à la fin du tutoriel.

    Enfin, comme étape optionnelle, nous installons le projet github (je ne vais pas passer par là) et poussons notre code vers le serveur distant:

    On ajoute d'abord le serveur distant:

    \begin{scriptsize}
    \begin{lstlisting}[language=bash, breaklines]
    $ git remote add origin git@github.com:madeindjs/market_place_api.git
    \end{lstlisting}
    \end{scriptsize}

    ensuite:

    \begin{scriptsize}
    \begin{lstlisting}[language=bash, breaklines]
    $ git push -u origin master
    \end{lstlisting}
    \end{scriptsize}

    Au fur et à mesure que nous avançons dans le tutoriel, j'utiliserai les pratiques que j'utilise quotidiennement. Cela inclut le travail avec les branches, le rebasage, le squash et bien d'autres. Pour l'instant, vous n'avez pas à vous inquiéter si certains des termes ne vous semblent pas familiers, je les expliquerai le temps venu.

  \section{Conclusion}

    Cela a été un long chemin à travers ce chapitre, si vous arrivez ici, permettez-moi de vous féliciter. Soyez sûr que les choses vont s'améliorer à partir de ce point.

    Maintenant, commençons à mettre les mains dans le code!

\chapter{L'API}

  Dans cette section, je vais vous donner les grandes lignes de l'application, vous devriez maintenant avoir le texte de l'application, comme indiqué dans la section 1.3, si vous ne l'avez pas lu, je vous recommande de le faire.

  Vous pouvez cloner le projet jusqu'à ce point avec :

  \begin{scriptsize}
  \begin{lstlisting}[language=bash, breaklines]
  $ git clone https://github.com/madeindjs/market_place_api
  $ cd market_place_api
  $ git checkout -b chapter1 b98a9a7a328017640482af95beebc1d6e612e0ac
  \end{lstlisting}
  \end{scriptsize}

  Et pour résumer, nous avons mis à jour le Gemfile pour ajouter la Gem \verb|active_model_serializers| (voir Listing \ref{listing:gemfile_active _model_serializers} pour plus d'informations).

  \section{Planification de l'application}

    Comme nous voulons faure simple avec l'application, elle se composera de 5 modèles (Figure \ref{fig:data_model}). Ne vous inquiétez pas si vous ne comprenez pas bien ce qui se passe, nous reverrons et développerons chacune de ces ressources au fur et à mesure que nous avancerons avec le tutoriel.

    \begin{figure}
      \includegraphics[width=\linewidth]{img/data_model.png}
      % \caption{http://market\_place\_api.dev/}
      \label{fig:data_model}
    \end{figure}

    En bref, nous avons l'utilisateur (\verb|User|) qui sera en mesure de passer de nombreuses commandes (\verb|Order|), télécharger de multiples produits (\verb|product|) qui peuvent avoir de nombreuses images (\verb|Image|) ou commentaires (\verb|Comment|) d'autres utilisateurs sur l'application.

    Nous n'allons pas construire de vues pour l'affichage ou l'interaction avec l'API afin de ne pas surcharger le tutoriel.  Si vous voulez construire des vues, il existe de nombreuses options comme des frameworks javascript (\href{https://angularjs.org/}{Angular}, \href{https://vuejs.org/}{Vue.JS}, \href{https://reactjs.org/}{React}) ou des librairies mobile (\href{https://github.com/AFNetworking/AFNetworking}{AFNetworking}).

    À ce stade, vous devez vous poser la question \textquote{d'accord, mais j'ai besoin d'explorer et de visualiser l'API que nous allons construire}, et c'est juste. Si vous googlez quelque chose lié à l'exploration d'une API, vous allez sûremment entendre parler de \href{https://www.getpostman.com/}{Postman}. C'est un excellent complément si vous utilisez chrome, mais nous ne l'utiliserons pas de toute façon, car probablement pas tous les développeurs utilisent le navigateur Google. Au lieu de cela, nous utiliserons une gemme que j'ai construite appelée  qui est un puissant client de moteur de type facteur pour explorer votre application Rails api's. Nous traiterons de l'intégration des pierres précieuses à la section 3.3.
    % TODO keep it?

  \section{Mettre en place l'API}\label{section:setup_api}

    Une API est définie par \href{https://fr.wikipedia.org/wiki/Interface_de_programmation}{wikipedia} comme une interface de programmation d'application (API) qui  est un ensemble normalisé de composants qui sert de façade par laquelle un logiciel offre des services à d'autres logiciels. En d'autres termes, il s'agit d'une façon dont les systèmes interagissent les uns avec les autres via une interface (dans notre cas un service web construit avec JSON). Il existe d'autres types de protocoles de communication comme SOAP, mais nous n'en parlons pas ici.

    JSON est devenu incontournable en tant sur média Internet en raison de sa lisibilité, de son extensibilité et sa facilité à mettre en œuvre. Beaucoup de frameworks Javascript l'utilisent comme protocole par défault comme \href{https://angularjs.org/}{Angular} ou \href{http://emberjs.com/}{EmberJS}. D'autres grandes bibliothèques en Objective-C l'utilisent  comme \href{https://github.com/AFNetworking/AFNetworking}{AFNetworking} ou \href{http://restkit.org/}{RESTKit}. Il existe probablement de bonnes solutions pour Android, mais en raison de mon manque d'expérience sur cette plate-forme de développement je ne suis peut-être pas la bonne personne pour vous recommander quelque chose.

    Très bien, donc nous construisons notre API avec JSON mais il y a beaucoup de façons d'y parvenir. La première chose qui pourrait vous venir à l'esprit serait de commencer à créer des routes en vrac. Le problème est qu'elles ne seront pas normalisées. Un utilisateur ne pourrait pas deviner qu'elle ressource est renvoyée par une route.

    C'est pourquoi une norme existe: REST \textit{(Representational State Transfer)}. REST impose une norme pour les routes qui doivent créer, lire, mettre à jour ou supprimer des informations sur un serveur en utilisant de simples appels HTTP. C'est une alternative aux mécanismes plus complexes comme SOAP(Listing \ref{lst:soap_example}), CORBA et RPC. Un appel REST est simplement une requête GET HTTP vers le serveur.

    \begin{scriptsize}
    \begin{lstlisting}[label={lst:soap_example}, caption={Un exemple d'appel SOAP}]
    aService.getUser("1")
    \end{lstlisting}
    \end{scriptsize}

    Et dans REST vous pouvez appeler une URL avec une requête HTTP spécifique, dans ce cas avec une requête GET (Listing \ref{lst:rest_example}):

    \begin{scriptsize}
    \begin{lstlisting}[label={lst:rest_example}, caption={Un exemple d'appel REST}]
    http://domain.com/resources_name/uri_pattern
    \end{lstlisting}
    \end{scriptsize}

    Les API RESTful doivent suivre aux minimum trois règles:

    \begin{itemize}
      \item Une URI de base comme \href{http://example.com/resources/}{http://example.com/resources/}
      \item Un type de média Internet pour représenter les données, il est communément JSON et est communément défini par l'échange d'en-têtes.
      \item Suivez les méthodes \href{https://fr.wikipedia.org/wiki/Hypertext_Transfer_Protocol}{HTTP} standard telles que GET, POST, PUT, PUT, DELETE.
    \end{itemize}

    \begin{description}
      \item[GET] Lit la ou les ressources définies par le modèle URI
      \item[POST] Crée une nouvelle entrée dans la collection de ressources
      \item[PUT] Mise à jour d'une collection ou d'un membre des ressources
      \item[DELETE] Détruit une collection ou un membre des ressources
    \end{description}

    Cela n'est peut-être pas assez clair ou peut sembler beaucoup d'informations à digérer. Mais à mesure que nous avancerons dans le tutoriel, cela deviendra beaucoup plus facile à comprendre.

    \subsection{Routes, Constraints and Namespaces}\label{subsec:routes_constraints_namespaces}

      Avant de commencer à taper du code, nous allons préparer le réprtoire Git. Le \textit{workflow} que nous allons suivre est le suivant. Nous allons créer une branche par chapitre.Une fois terminé, nous le pousserons la branche sur github et nous la fusionnerons avec master.

      Commençons donc par ouvrir le terminal dans le répertoire \verb|market_place_api| et tapez la commande suivante pour créer la branche:

      \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ git checkout -b setting-api
      Switched to a new branch 'setting-api'
      \end{lstlisting}
      \end{scriptsize}

      Nous allons seulement travailler sur le fichier \verb|config/routes.rb| (Listing \ref{lst:default_routes}), car nous allons simplement définir les contraintes et le format de réponse par défaut pour chaque requête.

      \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Le fichier routes.rb par défault}, label={lst:default_routes}]
      Rails.application.routes.draw do
        # ...
      end
      \end{lstlisting}
      \end{scriptsize}

      Effacez tout le code commenté qui se trouve dans le fichier. Nous n'en aurons pas besoin. Ensuite, faites un \verb|commit|, juste pour s'échauffer:

      \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ git add config/routes.rb
      $ git commit -m "Removes comments from the routes file"
      \end{lstlisting}
      \end{scriptsize}

      Nous allons isoler les contrôleurs API dans des Namespace. Avec Rails, c'est assez simple. Il suffit de créer un dossier sous \verb|app/controllers| nommé \verb|api|. Le nom est important car c'est l'espace de noms que nous allons utiliser pour gérer les contrôleurs pour les terminaux api. (Listing \ref{lst:mkdir_controllers_api})

      \begin{scriptsize}
      \begin{lstlisting}[language=bash, caption={Commande pour créer le dossier controllers/api}, label={lst:mkdir_controllers_api}]
      $ mkdir app/controllers/api
      \end{lstlisting}
      \end{scriptsize}

      Nous ajoutons ensuite ce \textit{namespace} dans notre fichier routes.rb (Listing \ref{lst:routes_create_namespace}):

      \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Création d'un Namespace}, label={lst:routes_create_namespace}]
      Rails.application.routes.draw do
        # Api definition
        namespace :api do
          # We are going to list our resources here
        end
      end
      \end{lstlisting}
      \end{scriptsize}

      En définissant un \textit{Namespace} dans le fichier \verb|routes.rb|, Rails mappera automatiquement ce \textit{Namespace} à un répertoire correspondant au nom sous le dossier controllers, dans notre cas le répertoire \verb|api/|.

      Rails supporte jusqu'à 35 types de médias différents, vous pouvez les lister en accédant à la classe \verb|SET| sous le module de \verb|Mime|:


      \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rails c
      Loading development environment (Rails 5.2.1)
      irb(main):001:0> Mime::SET.collect(&:to_s)
      => ["text/html", "text/plain", "text/javascript", "text/css", "text/calendar", "text/csv", "text/vcard", "text/vtt", "image/png", "image/jpeg", "image/gif", "image/bmp", "image/tiff", "image/svg+xml", "video/mpeg", "audio/mpeg", "audio/ogg", "audio/aac", "video/webm", "video/mp4", "font/otf", "font/ttf", "font/woff", "font/woff2", "application/xml", "application/rss+xml", "application/atom+xml", "application/x-yaml", "multipart/form-data", "application/x-www-form-urlencoded", "application/json", "application/pdf", "application/zip", "application/gzip", "application/vnd.web-console.v2"]
      \end{lstlisting}
      \end{scriptsize}

      C'est important parce que nous allons travailler avec JSON, l'un des types MIME intégrés par Rails. Ainsi nous avons juste besoin de spécifier ce format comme format par défaut (Listing \ref{lst:routes_create_namespace_with_format}) :

      \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Création d'un Namespace avec un format par défault}, label={lst:routes_create_namespace_with_format}]
      Rails.application.routes.draw do
        # Api definition
        namespace :api, defaults: { format: :json }  do
          # We are going to list our resources here
        end
      end
      \end{lstlisting}
      \end{scriptsize}

      Jusqu'à présent, nous n'avons rien fait de fou. Nous voulons maintenant générer une \verb|base_uri| sous un sous-domaine. C'est-à-dire quelque chose comme \verb|api.market_place_api.dev|. Définir l'API sous un sous-domaine est une bonne pratique car cela permet d'adapter l'application à un niveau DNS. Alors, comment y parvenir? (Listing \ref{lst:routes_create_namespace_with_subdomain})

      \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Création d'un Namespace avec un format par défault}, label={lst:routes_create_namespace_with_subdomain}]
      Rails.application.routes.draw do
        # Api definition
        namespace :api, defaults: { format: :json }, constraints: { subdomain: 'api' }, path: '/'  do
          # We are going to list our resources here
        end
      end
      \end{lstlisting}
      \end{scriptsize}

      Vous voyez la différence? Nous n'avons pas seulement ajouté un \verb|Hash| de contraintes pour spécifier le sous-domaine, nous avons aussi ajouté l'option chemin d'accès, et lui avons donné un \textit{backslash}. Cel indique à Rails que le chemin de départ pour chaque requête est la racine par rapport au sous-domaine (Encadré 2.1), obtenant ce que nous recherchons.

      \begin{tcolorbox}{Les conventions des API}
        Vous pouvez trouver de nombreuses approches pour configurer la \verb|base_uri| d'une API. En supposant que nous versionnont notre api (Section \ref{section:api_versioning}):

        \begin{description}
          \item[api.example.com/] Je suis d'avis que c'est la voie à suivre, vous donne une meilleure interface et l'isolement, et à long terme peut vous aider à mettre rapidement à l'échelle \url{http://www.makeuseof.com/tag/optimize-your-dns-for-faster-internet/}
          \item[example.com/api/] Ce modèle est très commun. C'est un bon moyen de commencer quand vous ne voulez pas de Namespace de votre API avec sous un sous-domaine
          \item[example.com/api/v1] Cela semble être une bonne idée. En définissant la version de l'API par l'URL semble être un modèle plus descriptif. Cependant, vous forcez à inclure la version àl'URL sur chaque demande. Cela devient un problème Si vous décidez de changer ce modèle
        \end{description}

        Ne vous inquiétez pas, nous rentrerons plus en détails à propos du versionnement lors de la section \ref{section:api_versioning}

      \end{tcolorbox}

      Il est temps de \textit{commiter}:

      \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ git add config/routes.rb
      $ git commit -m "Set the routes contraints for the api"
      \end{lstlisting}
      \end{scriptsize}

  \section{Versionnement de l'API}\label{section:api_versioning}

    A ce stade, nous devrions avoir un bon mappage des routes utilisant un sous-domaine pour l'espacement des noms des requêtes, votre fichier routes.rb devrait ressembler à ceci:

    \begin{scriptsize}
    \begin{lstlisting}[language=ruby]
    Rails.application.routes.draw do
      # Api definition
      namespace :api, defaults: { format: :json }, constraints: { subdomain: 'api' }, path: '/'  do
        # We are going to list our resources here
      end
    end
    \end{lstlisting}
    \end{scriptsize}

    Il est maintenant temps de mettre en place d'autres contraintes pour le versioning. Vous devriez vous soucier de versionner votre application dès le début car cela donnera une meilleure structure à votre API. Lorsque des changements interviendrons sur votre API, vous proposer aux développeurs de s'adapter aux nouvelles fonctionnalités pendant que les anciennes sont dépréciées. Il y a un excellent \href{http://railscasts.com/episodes/350-rest-api-versioning}{railscast} qui explique cela.


    Votre versionnement de l'API est erroné, c'est pourquoi j'ai décidé de le faire de 3 façons différentes -Troy Hunt

    Afin de définir la version de l'API, nous devons d'abord ajouter un autre répertoire sous l'api que nous avons créé (Section \ref{section:setup_api}):

    \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ mkdir app/controllers/api/v1
    \end{lstlisting}
    \end{scriptsize}

    De cette façon, nous pouvons très facilement définir la portée de notre API dans différentes versions. Il ne nous reste plus qu'à ajouter le code nécessaire dans le fichier \verb|routes.rb| (Listing \ref{lst:add_scope_to_toutes})

    \begin{scriptsize}
    \begin{lstlisting}[language=ruby, caption={Spécification de la version de l'API}, label={lst:add_scope_to_toutes}]
    Rails.application.routes.draw do
      # Api definition
      namespace :api, defaults: { format: :json }, constraints: { subdomain: 'api' }, path: '/'  do
        scope module: :v1 do
          # We are going to list our resources here
        end
      end
    end
    \end{lstlisting}
    \end{scriptsize}

    L'API est désormais scopée via l'URL. Par exemple, avec la configuration actuelle, la récupération d'un produit via l'API se ferait avec cette url:

    \begin{scriptsize}
    \begin{lstlisting}
    http://api.marketplace.dev/v1/products/1
    \end{lstlisting}
    \end{scriptsize}

  \section{Améliorer le versionning}\label{section:improve_api_versioning}

    Jusqu'à présent, l'API a été versionnée via l'URL. Mais quelque chose ne va pas? De mon point de vue, le développeur ne devrait pas être au courant de la version qu'il utilise. Par défaut, il devrait utiliser la dernière version. Mais comment pouvons-nous y parvenir ?

    Tout d'abord, nous devons améliorer l'accès à la version de l'API via les \href{http://en.wikipedia.org/wiki/List_of_HTTP_header_fields}{en-têtes HTTP}. Cela présente deux avantages:

    \begin{itemize}
      \item Removes the version from the URL
      \item The API description is handle through request headers (Box 2.2)
    \end{itemize}


    \begin{tcolorbox}{Description des en-têtes de requête}
      Les champs d'en-tête HTTP sont des composants de l'en-tête de demandes et de réponses dans le protocole HTTP. Ils définissent les paramètres de fonctionnement d'une transaction HTTP.

      Une liste commune des en-têtes utilisés est présentée ci-dessous:

      \begin{description}
        \item[Accept] Types de contenu acceptables pour la réponse. Exemple: \verb|Accept: text/plain|
        \item[Authorization] Identifiants d'authentification pour l'authentification HTTP. Exemple: \verb|Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==|
        \item[Content-Type] Le type MIME du corps de la requête (utilisé avec les requêtes POST et PUT). Exemple: \verb|Content-Type: application/x-www-form-urlencoded|
        \item[Origin] Lance une demande de partage de ressources d'origine croisée (demande au serveur un en-tête de réponse \verb|Accès-Contrôle-Autorisation-Autorisation-Origin|) .. Exemple: \verb|Origin: http://www.example-social-network.com|
        \item[User-Agent] La chaîne d'agent utilisateur de l'agent utilisateur. Exemple: \verb|User-Agent: Mozilla/5.0|
      \end{description}

      Il est important que vous vous sentiez à l'aise avec celles-ci et que vous les compreniez.

      Il en existe beaucoup d'autres. La liste complète est disponnible \href{https://en.wikipedia.org/wiki/List_of_HTTP_header_fields}{sur Wikipedia}.
    \end{tcolorbox}

    Avec Rails, il est très facile d'ajouter ce type de versionnement par le biais d'un en-tête \verb|Accept|. Nous allons créer une classe sous le répertoire \verb|lib| de votre application Rails. N'oubliez pas que nous faisons du TDD donc nous allons commencer par un test. (Liste \ref{lst:create_api_constraints_spec}).

    Tout d'abord, nous devons ajouter notre suite de tests, qui dans notre cas sera \href{http://rspec.info/}{Rspec} (Listing \ref{lst:add_rspect_to_gemfile}):

    \begin{scriptsize}
    \begin{lstlisting}[language=ruby, caption={Gemfile avec la suite de test}, label={lst:add_rspect_to_gemfile}]
    group :test do
      gem 'rspec-rails', '~> 3.8'
      gem 'factory_bot_rails', '~> 4.9'
      gem 'ffaker', '~> 2.10'
    end
    \end{lstlisting}
    \end{scriptsize}

    Ensuite nous lançons la commande \verb|bundle| pour installer les gemmes:

    \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ bundle install
    \end{lstlisting}
    \end{scriptsize}

    Enfin, nous installons \verb|rspec| et ajoutons de la configuration pour éviter que des vues et des tests helpers ne soient générés :

    \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ rails generate rspec:install
    \end{lstlisting}
    \end{scriptsize}

    \begin{scriptsize}
    \begin{lstlisting}[language=ruby, caption={Configuration de notre suite de test avec respec  (/config/application.rb)}, label={lst:setup_rspec}]
    # ...
    module MarketPlaceApi
      class Application < Rails::Application
        # Initialize configuration defaults for originally generated Rails version.
        config.load_defaults 5.2

        config.generators do |g|
          g.test_framework :rspec, fixture: true
          g.fixture_replacement :factory_bot, dir: 'spec/factories'
          g.view_specs false
          g.helper_specs false
          g.stylesheets = false
          g.javascripts = false
          g.helper = false
        end

        config.autoload_paths += %W(\#{config.root}/lib)

        # Don't generate system test files.
        config.generators.system_tests = nil
      end
    end
    \end{lstlisting}
    \end{scriptsize}

    Si tout s'est bien passé, il est maintenant temps d'ajouter un répertoire \verb|spec| sous \verb|lib| et d'ajouter le fichier \verb|api_constraints_spec.rb|:

    \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ mkdir lib/spec
    $ touch lib/spec/api_constraints_spec.rb
    \end{lstlisting}
    \end{scriptsize}

    Nous ajoutons ensuite une série de spécifications décrivant notre classe:

    \begin{scriptsize}
    \begin{lstlisting}[language=ruby, caption={Test ApiConstraints (lib/spec/api\_constraints\_spec.rb)}, label={lst:create_api_constraints_spec}]
    require 'spec_helper'
    require './lib/api_constraints'

    describe ApiConstraints do
      let(:api_constraints_v1) { ApiConstraints.new(version: 1) }
      let(:api_constraints_v2) { ApiConstraints.new(version: 2, default: true) }

      describe 'matches?' do
        it "returns true when the version matches the 'Accept' header" do
          request = double(host: 'api.marketplace.dev',
                           headers: { 'Accept' => 'application/vnd.marketplace.v1' })
          expect(api_constraints_v1.matches?(request)).to be_truthy
        end

        it "returns the default version when 'default' option is specified" do
          request = double(host: 'api.marketplace.dev')
          expect(api_constraints_v2.matches?(request)).to be_truthy
        end
      end
    end
    \end{lstlisting}
    \end{scriptsize}


    Laissez-moi vous expliquer le code. Nous initialisons la classe avec un \verb|Hash| d'options qui contiendra la version de l'API  et une valeur par défaut pour gérer la version par défaut. Nous fournissons une méthode \verb|match?| afin que le routeur devine si la version par défaut est requise ou si l'en-tête \verb|Accept| correspond à la chaîne donnée.

    L'implémentation ressemble à ceci (Listing \ref{lst:create_api_constraints})

    \begin{scriptsize}
    \begin{lstlisting}[language=ruby, caption={La classe ApiConstraints (lib/api\_constraints.rb)}, label={lst:create_api_constraints}]
    class ApiConstraints
      def initialize(options)
        @version = options[:version]
        @default = options[:default]
      end

      def matches?(req)
        @default || req.headers['Accept'].include?("application/vnd.marketplace.v#{@version}")
      end
    end
    \end{lstlisting}
    \end{scriptsize}

    Comme vous l'imaginez, nous devons ajouter la classe à notre fichier \verb|routes.rb| et la définir comme option de portée de contrainte (Listing \ref{lst:add_api_constraints_to_toutes}):

    \begin{scriptsize}
    \begin{lstlisting}[language=ruby, caption={Ajout de la contrainte à la route (config/routes.rb)}, label={lst:add_api_constraints_to_toutes}]
    require 'api_constraints'

    Rails.application.routes.draw do
      # Api definition
      namespace :api, defaults: { format: :json }, constraints: { subdomain: 'api' }, path: '/' do
        scope module: :v1, constraints: ApiConstraints.new(version: 1, default: true) do
          # We are going to list our resources here
        end
      end
    end
    \end{lstlisting}
    \end{scriptsize}

    La configuration ci-dessus gère maintenant le versioning par le biais des en-têtes. Pour l'instant la version 1 est la version par défaut. Chaque requête sera redirigée vers cette version, peu importe si l'en-tête avec la version est présent ou non.

    Avant de nous dire au revoir, faisons nos premiers tests et assurons-nous que notre test fonctionne:

    \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ bundle exec rspec lib/spec/api_constraints_spec.rb
    ..

    Finished in 0.00294 seconds (files took 0.06292 seconds to load)
    2 examples, 0 failures
    \end{lstlisting}
    \end{scriptsize}

    Ça a été un long chemin, je sais, mais vous avez réussi! N'abandonnez pas, c'est juste notre petite fondation pour quelque chose de grand, alors continuez comme ça. En attendant, et je vous intrigue, il y a quelques gemmes qui gèrent ce genre de configuration:

    \begin{itemize}
      \item \href{https://github.com/Sutto/rocket_pants}{RocketPants}
      \item \href{https://github.com/bploetz/versionist}{Versionist}
    \end{itemize}

    Je n'en parle pas ici puisque nous essayons d'apprendre comment mettre en œuvre ce genre de fonctionnalité. Le code jusqu'ici est disponnible \href{https://github.com/madeindjs/market_place_api/commit/124873774b578af3df21136df5ee80f4d50da3bd}{ici}.

\chapter{Présentation des utilisateurs}

  Dans le dernier chapitre, nous avons réussi à mettre en place les bases de la configuration de notre application. Nous avons même ajouté le versioning par le biais des en-têtes HTTP. Dans le Chapitre 5, nous traiterons l'authentification des utilisateurs à l'aide de jetons d'authentification ainsi que la définition de permissions pour limiter l'accès aux utilisateurs  connectés. Dans les chapitres à venir, nous relierons les produits aux utilisateurs et leur donnerons la possibilité de passer des commandes.

  Vous pouvez cloner le projet jusqu'à ce point avec:

  \begin{scriptsize}
  \begin{lstlisting}[language=bash]
  $ git clone https://github.com/madeindjs/market_place_api/tree/chapitre_2
  \end{lstlisting}
  \end{scriptsize}

  Comme vous pouvez déjà l'imaginer, il existe de nombreuses solutions d'authentification pour Rails comme \href{https://github.com/binarylogic/authlogic}{AuthLogic}, \href{https://github.com/thoughtbot/clearance}{Clearance} et \href{https://github.com/plataformatec/devise}{Devise}. Nous utiliserons le dernier (Encadré \ref{box:devise_for_authentication}), qui offre un excellent moyen d'intégrer non seulement l'authentification de base, mais de nombreux autres modules pour une utilisation ultérieure.

  \begin{tcolorbox}{Devise pour l'authentification}\label{box:devise_for_authentication}
    Devise est livré avec jusqu'à 10 modules pour la gestion de l'authentification :

    \begin{itemize}
      \item Database Authenticable
      \item Omniauthable
      \item Confirmable
      \item Recoverable
      \item Registerable
      \item Rememberable
      \item Trackable
      \item Timeoutable
      \item Validatable
      \item Lockable
    \end{itemize}

    Si vous n'avez jamais travaillé avec devise auparavant, je vous recommande de visiter \href{https://github.com/plataformatec/devise}{le répertoire Github} et de lire la documentation. Vous y trouverez beaucoup de bons exemples.
  \end{tcolorbox}

  Ce chapitre sera complet. Il sera peut-être long mais j'essaie d'aborder autant de sujets que possible et d'aborder les meilleures pratiques. N'hésitez pas à vous prendre un café et allons-y. A la fin de ce chapitre, vous aurez construit toute la logique des utilisateurs ainsi que la validations et la gestion des erreurs.

  Nous voulons suivre ce chapitre, c'est donc un bon moment pour créer une nouvelle branche:

  \begin{scriptsize}
  \begin{lstlisting}[language=bash]
  $ git checkout -b chapter3
  \end{lstlisting}
  \end{scriptsize}

  Assurez-vous simplement d'être sur la branche \verb|master| avant.

  \section{Modèle d'utilisateur}

    Nous devons d'abord ajouter la gemme Devise au \verb|Gemfile| (Listing \ref{lst:add_devise_to_gemfile})

    \begin{scriptsize}
    \begin{lstlisting}[language=ruby, caption={Le Gemfile avec l'ajout de Devise}, label={lst:add_devise_to_gemfile}]
    source 'https://rubygems.org'
    git_source(:github) { |repo| "https://github.com/#{repo}.git" }

    ruby '2.5.3'

    # Bundle edge Rails instead: gem 'rails', github: 'rails/rails'
    gem 'rails', '~> 5.2.0'
    # Use sqlite3 as the database for Active Record
    gem 'sqlite3'
    # Use Puma as the app server
    gem 'puma', '~> 3.11'
    # Use SCSS for stylesheets
    gem 'sass-rails', '~> 5.0'
    # Use Uglifier as compressor for JavaScript assets
    gem 'uglifier', '>= 1.3.0'

    # Api gems
    gem 'active_model_serializers'

    # Reduces boot times through caching; required in config/boot.rb
    gem 'bootsnap', '>= 1.1.0', require: false

    group :development, :test do
      # Call 'byebug' anywhere in the code to stop execution and get a debugger console
      gem 'byebug', platforms: %i[mri mingw x64_mingw]
    end

    group :development do
      # Access an interactive console on exception pages or by calling 'console' anywhere in the code.
      gem 'listen', '>= 3.0.5', '< 3.2'
      gem 'web-console', '>= 3.3.0'
      # Spring speeds up development by keeping your application running in the background. Read more: https://github.com/rails/spring
      gem 'spring'
      gem 'spring-watcher-listen', '~> 2.0.0'
    end

    group :test do
      gem 'factory_bot_rails', '~> 4.9'
      gem 'ffaker', '~> 2.10'
      gem 'rspec-rails', '~> 3.8'
    end

    # Windows does not include zoneinfo files, so bundle the tzinfo-data gem
    gem 'tzinfo-data', platforms: %i[mingw mswin x64_mingw jruby]

    gem 'devise'
    \end{lstlisting}
    \end{scriptsize}

    Lancez ensuite la commande \verb|bundle install| pour installer la Gem. Une fois que la commande est terminée, nous devons lancer le générateur d'installation de Devise:

    \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ rails g devise:install
      create  config/initializers/devise.rb
      create  config/locales/devise.en.yml
      ...
    \end{lstlisting}
    \end{scriptsize}

    Maintenant et si tout s'est bien passé, nous serons en mesure de générer le modèle \verb|user| à l'aide du générateur de Devise:

    \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ rails g devise User
        invoke  active_record
        create    db/migrate/20181113070805_devise_create_users.rb
        create    app/models/user.rb
        invoke    rspec
        create      spec/models/user_spec.rb
        invoke      factory_bot
        create        spec/factories/users.rb
        insert    app/models/user.rb
        route  devise_for :users
    \end{lstlisting}
    \end{scriptsize}

    A partir de maintenant, chaque fois que nous créons un modèle, le générateur va également créer un fichier d'usine pour ce modèle (Listing \ref{lst:create_factories_users}). Cela nous aidera à créer facilement des utilisateurs de tests et facilitera la rédaction de nos tests.

    \begin{scriptsize}
    \begin{lstlisting}[language=ruby, caption={Usine d'utilsateurs (spec/factories/users.rb)}, label={lst:create_factories_users}]
    FactoryBot.define do
      factory :user do

      end
    end
    \end{lstlisting}
    \end{scriptsize}

    Ensuite, nous allons migrer la base de données et préparer la base de données de test.

    \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ rake db:migrate
    == 20181113070805 DeviseCreateUsers: migrating ================================
    -- create_table(:users)
       -> 0.0008s
    -- add_index(:users, :email, {:unique=>true})
       -> 0.0005s
    -- add_index(:users, :reset_password_token, {:unique=>true})
       -> 0.0007s
    == 20181113070805 DeviseCreateUsers: migrated (0.0023s) =======================
    \end{lstlisting}
    \end{scriptsize}

    \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ rake db:test:prepare
    \end{lstlisting}
    \end{scriptsize}

    Faisons maintenant un \verb|commit| afin de garder un historique concis:

    \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ git add .
    $ git commit -m "Adds devise user model"
    \end{lstlisting}
    \end{scriptsize}

  \section{Notre premier test sur le modèle User}

    Nous allons ajouter quelques spécifications pour nous assurer que le modèle utilisateur répond aux attributs \verb|email|, \verb|password| et \verb|password_confirmation| fournis par Devise. nous allons les ajouter (Listing \ref{lst:user_spec_with_attrs}). Pour des raisons de commodité, nous allons modifier le fichier d'usine des utilisateurs pour ajouter les attributs correspondants (Listing \ref{lst:user_factory_with_attrs}).

    \begin{scriptsize}
    \begin{lstlisting}[language=ruby, caption={Usine d'utilisateurs avec les attributs (spec/factories/users.rb)}, label={lst:user_factory_with_attrs}]
    FactoryBot.define do
      factory :user do
        email { FFaker::Internet.email }
        password { '12345678' }
        password_confirmation { '12345678' }
      end
    end
    \end{lstlisting}
    \end{scriptsize}

    Une fois les attributs ajoutés, il est temps de tester notre modèle \verb|User| (Listing \ref{lst:user_spec_with_attrs})).

    \begin{scriptsize}
    \begin{lstlisting}[language=ruby, caption={Test pour les attributs Devise (spec/models/user\_spec.rb)}, label={lst:user_spec_with_attrs}]
    require 'rails_helper'

    RSpec.describe User, type: :model do
      before { @user = FactoryBot.build(:user) }

      subject { @user }

      it { should respond_to(:email) }
      it { should respond_to(:password) }
      it { should respond_to(:password_confirmation) }

      it { should be_valid }
    end
    \end{lstlisting}
    \end{scriptsize}

    Vue que nous avons préparé la base de données de test avec \verb|rake db:test:prepare|, nous pouvons exécuter les tests:


    \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ bundle exec rspec spec/models/user_spec.rb
    \end{lstlisting}
    \end{scriptsize}

    Nos tests devraient passer:

    \begin{scriptsize}
    \begin{lstlisting}
    ....

    Finished in 0.03231 seconds (files took 0.81624 seconds to load)
    4 examples, 0 failures
    \end{lstlisting}
    \end{scriptsize}

    C'était facile! Nous devrions maintenant faire un \verb|commit|:

    \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ git add .
    $ git commit -am 'Adds user firsts specs'
    \end{lstlisting}
    \end{scriptsize}

  \section{Construire les utilisateurs}

    Il est temps de faire notre première ressource. Nous allons juste commencer à construire l'action \verb|show| pour l'utilisateur qui va afficher un utilisateur en JSON. Nous devons d'abord générer le \verb|users_controller|, ajouter les tests correspondants et ensuite construire le code réel.

    Tout d'abord, nous générons le contrôleur utilisateur:

    \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ rails generate controller users
    \end{lstlisting}
    \end{scriptsize}

    Cette commande var créer le fichier \verb|users_controller_spec.rb| (Listing \ref{lst:add_show_test_to_users_controller_spec}). Avant d'entrer dans le vif du sujet, il y a deux choses que nous voulons tester pour une API.

    \begin{itemize}
      \item La structure du JSON renvoyée par le serveur
      \item Le code de réponse HTTP renvoyée par le serveur (encadré 3.2).
    \end{itemize}

    \begin{tcolorbox}{Les codes HTTP courants}\label{box:common_http_code}
      \begin{quote}
        Le premier chiffre du code d'état spécifie l'une des cinq classes de réponse ; le strict minimum pour un client HTTP est qu'il reconnaît ces cinq classes - Wikipedia
      \end{quote}

      Voici une liste des codes HTTP courrament utilisés:

      \begin{description}
        \item[200] Réponse standard pour les requêtes HTTP réussies. C'est généralement sur les requêtes GET
        \item[201] La demande a été satisfaite et a donné lieu à la création d'une nouvelle ressource. Après les demandes de POST
        \item[204] Le serveur a traité la requête avec succès, mais ne renvoie aucun contenu. Il s'agit généralement d'une requête DELETE réussie.
        \item[400] La requête ne peut pas être exécutée en raison d'une mauvaise syntaxe. Peut arriver pour tout type de requête.
        \item[401] Similaire au 403 Interdit, mais spécifiquement pour une utilisation lorsque l'authentification est requise et qu'elle a échoué ou n'a pas encore été fournie. Peut arriver pour tout type de requête.
        \item[404] La ressource demandée n'a pas pu être trouvée mais peut être à nouveau disponible à l'avenir. Habituellement, concerne les requêtes GET
        \item[500] Un message d'erreur générique, donné lorsqu'une condition inattendue a été rencontrée et qu'aucun autre message spécifique ne convient. Peut arriver pour tout type de requête.
      \end{description}


      Pour une liste complète des codes de réponse HTTP, consultez l'\href{https://fr.wikipedia.org/wiki/Liste_des_codes_HTTP}{article sur Wikipedia}.
    \end{tcolorbox}

    Pour garder notre code bien découpé, nous allons créer quelques répertoires sous le répertoire des tests des contrôleurs afin d'être cohérent la configuration (Listing \ref{lst:mkdir_controllers_api}). Il existe aussi une autre convention qui utilise à la place du répertoire \verb|controllers| un répertoire de \verb|request| ou \verb|integration|. Dans notre cas, je préfère rester cohérent avec le répertoire \verb|app/controllers|.


    \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ mkdir -p spec/controllers/api/v1
    $ mv spec/controllers/users_controller_spec.rb spec/controllers/api/v1
    \end{lstlisting}
    \end{scriptsize}

    Après avoir créé les répertoires, nous devons changer le nom de la classe \verb|UsersController| en \verb|Api::V1::UsersController|. Le fichier doit ressembler à ça:

    \begin{scriptsize}
    \begin{lstlisting}[language=ruby]
    require 'rails_helper'

    RSpec.describe Api::V1::UsersController, type: :controller do

    end
    \end{lstlisting}
    \end{scriptsize}

    Maintenant, voici le fichier avec les tests crée:

    \begin{scriptsize}
    \begin{lstlisting}[language=ruby, caption={Le test du contrôlleur des utilisateur  (spec/controllers/api/v1/users\_controller\_spec.rb)}, label={lst:add_show_test_to_users_controller_spec}]
    require 'rails_helper'

    RSpec.describe Api::V1::UsersController, type: :controller do
      before(:each) { request.headers['Accept'] = "application/vnd.marketplace.v1" }

        describe "GET #show" do
          before(:each) do
            @user = FactoryBot.create :user
            get :show, params: { id: @user.id, format: :json}
          end

          it "returns the information about a reporter on a hash" do
            user_response = JSON.parse(response.body, symbolize_names: true)
            expect(user_response[:email]).to eql @user.email
          end

          it { expect(response).to be_success }
        end
    end
    \end{lstlisting}
    \end{scriptsize}

    Il suffit ensuite d'ajouter l'action à notre contrôlleur (Listing \ref{lst:add_show_to_users_controller_spec}). C'est extrêmement simple:

    \begin{scriptsize}
    \begin{lstlisting}[language=ruby, caption={Le contrôlleur des utilisateurs avec l'action' 'show' (app/controllers/api/v1/users\_controller.rb)}, label={lst:add_show_to_users_controller_spec}]
    class  Api::V1::UsersController < ApplicationController
      def show
        render json: User.find(params[:id])
      end
    end
    \end{lstlisting}
    \end{scriptsize}

    \begin{tcolorbox}{Les codes HTTP courants}
      Il est possible qu'il faille activer le module \verb|Devise::Test::ControllerHelpers| au fichier \verb|spec/rails_helper.rb| afin de charger les utilitaires Devise aux test. Si c'est le cas, ajouter la ligne suivante

      \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      #  ...
      RSpec.configure do |config|
        #  ...
        config.include Devise::Test::ControllerHelpers, type: :controller
        #  ...
      end
      \end{lstlisting}
      \end{scriptsize}
    \end{tcolorbox}

    Si vous exécutez les tests avec \verb|bundle exec rspec spec/controllers| vous obtenez l'erreur suivante:

    \begin{scriptsize}
    \begin{lstlisting}
    $ bundle exec rspec spec/controllers
    FF

    Failures:

      1) Api::V1::UsersController GET #show returns the information about a reporter on a hash
        Failure/Error: get :show, params: { id: @user.id, format: :json}

        ActionController::UrlGenerationError:
        No route matches {:action=>"show", :controller=>"api/v1/users", :format=>:json, :id=>1}
          ...

      2) Api::V1::UsersController GET #show
        Failure/Error: get :show, params: { id: @user.id, format: :json}

        ActionController::UrlGenerationError:
        No route matches {:action=>"show", :controller=>"api/v1/users", :format=>:json, :id=>1}
          ...

    Finished in 0.01632 seconds (files took 0.47675 seconds to load)
      2 examples, 2 failures
    \end{lstlisting}
    \end{scriptsize}

    Ce type d'erreur est très courant lorsque vous générer vos ressources à la main! En effet, nous vons totalement oublié les routes. Alors ajoutons-les (Figure \ref{lst:add_route_users_show}):

    \begin{scriptsize}
    \begin{lstlisting}[language=ruby, caption={Ajoute de la route Users\#Show}, label={lst:add_route_users_show}]
    # config/routes.rb

    require 'api_constraints'

    Rails.application.routes.draw do
      devise_for :users
      # Api definition
      namespace :api, defaults: { format: :json }, constraints: { subdomain: 'api' }, path: '/' do
        scope module: :v1, constraints: ApiConstraints.new(version: 1, default: true) do
          resources :users, only: [:show]
        end
      end
    end
    \end{lstlisting}
    \end{scriptsize}

    Vos tests devraient désormais passer:

    \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ bundle exec rspec spec/controllers
    ..

    Finished in 0.02652 seconds (files took 0.47291 seconds to load)
    2 examples, 0 failures
    \end{lstlisting}
    \end{scriptsize}

    Comme d'habitude, après avoir ajouté un des fonctionnalités dont nous sommes satisfaits, nous faisons un \verb|commit|:

    \begin{scriptsize}
    \begin{lstlisting}[language=bash]
    $ git add .
    $ git commit -m "Adds show action the users controller"
    \end{lstlisting}
    \end{scriptsize}

    \subsection{Tester notre ressource avec cURL}

      Nous avons donc enfin une ressource à tester. Nous avons plusieurs solutions pour la tester. La première qui me vient à l'esprit est l'utilisation de cURL qui est intégré dans presque toutes les distributions Linux. Alors, essayons:

      Rappelez-vous que notre URI de base est \verb|api.market_place_api.dev| (Section \ref{subsec:routes_constraints_namespaces}).

      \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ curl -H 'Accept: application/vnd.marketplace.v1' http://api.market_place_api.dev/users/1
      \end{lstlisting}
      \end{scriptsize}

      En faisant cela nous obtenons une erreur et c'est normal: l'utilisateur n'existe pas. Créons-le avec le terminal:

      \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ rails console
      Loading development environment (Rails 5.2.1)
      2.5.3 :001 >  User.create email: "example@marketplace.com", password: "12345678", password_confirmation: "12345678"
      \end{lstlisting}
      \end{scriptsize}

      Après avoir créé l'utilisateur, notre appel cURL devrait fonctionner:

      \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ curl -H 'Accept: application/vnd.marketplace.v1' \
      http://api.market_place_api.dev/users/1
      {"id":1,"email":"example@marketplace.com", ...
      \end{lstlisting}
      \end{scriptsize}

      Et voilà! Vous avez maintenant une entrée d'API d'enregistrement d'utilisateur. Si vous avez des problèmes avec la réponse, vous devrez peut-être modifier le fichier \verb|application_controller.rb| et ajouter la ligne suivante (Listing \ref{lst:add_protect_from_forgery}):

      \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Correction de la réponde de l'API}, label={lst:add_protect_from_forgery}]
      # app/controllers/application_controller.rb

      class ApplicationController < ActionController::Base
        # Prevent CSRF attacks by raising an exception.
        # For APIs, you may want to use :null_session instead.
        protect_from_forgery with: :null_session
      end
      \end{lstlisting}
      \end{scriptsize}

      Comme suggéré même par Rails, nous devrions utiliser \verb|null_session| pour empêcher les attaques CSFR. Je vous recommande fortement de le faire sinon les requêtes POST et PUT ne fonctionnerons pas. Après avoir mis à jour le fichier \verb|application_controller.rb| c'est le moment de faire un \verb|commit|:

      \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ git add .
      $ git commit -m "Updates application controller to prevent CSRF exception from being raised"
      \end{lstlisting}
      \end{scriptsize}

    \subsection{Créer les utilisateurs}\label{subsec:create_users}

      Maintenant que nous avons une meilleure compréhension de la façon de construire des points d'entrée, il est temps d'étendre notre API. Une des fonctionnalités les plus importante est de laisser les utilisateurs créer un profil sur notre application. Comme d'habitude, nous allons écrire des tests avant d'implémenter notre code pour étendre notre suite de tests.

      Assurez-vous que votre répertoire Git est propre et que vous n'avez pas de fichier en \verb|staging|. Si c'est le cas, \textit{committez}-les pour que nous puissions recommencer à zéro.

      Commençons donc par écrire notre test tests en ajoutant une entrée pour créer un utilisateur sur le fichier \verb|users_controller_spec.rb| (Listing \ref{lst:add_spec_users_controller_create}):

      \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Ajout les tests de création des utilisateurs}, label={lst:add_spec_users_controller_create}]
      # spec/controllers/api/v1/users_controller_spec.rb

      require 'rails_helper'

      RSpec.describe Api::V1::UsersController, type: :controller do

        # ...

        describe 'POST #create' do
          context 'when is successfully created' do
            before(:each) do
              @user_attributes = FactoryBot.attributes_for :user
              post :create, params: { user: @user_attributes }, format: :json
            end

            it 'renders the json representation for the user record just created' do
              user_response = JSON.parse(response.body, symbolize_names: true)
              expect(user_response[:email]).to eql @user_attributes[:email]
            end

            it { expect(response.response_code).to eq(201) }
          end

          context 'when is not created' do
            before(:each) do
              # notice I'm not including the email
              @invalid_user_attributes = { password: '12345678',
                                           password_confirmation: '12345678' }
              post :create, params: { user: @invalid_user_attributes }, format: :json
            end

            it 'renders an errors json' do
              user_response = JSON.parse(response.body, symbolize_names: true)
              expect(user_response).to have_key(:errors)
            end

            it 'renders the json errors on why the user could not be created' do
              user_response = JSON.parse(response.body, symbolize_names: true)
              expect(user_response[:errors][:email]).to include "can't be blank"
            end

            it {  expect(response.response_code).to eq(422) }
          end
        end
      end
      \end{lstlisting}
      \end{scriptsize}

      Cela fait beaucoup de code (Listing \ref{lst:add_spec_users_controller_create}). Ne vous inquiétez pas, je vous explique tout:

      \begin{itemize}
        \item Nous devons valider les états sur lesquels l'enregistrement peut être valide ou invalide. Dans ce cas, nous utilisons les \verb|context| pour réaliser ces scénarios.
        \item  Au cas où tout se passe bien, nous devrions retourner un code HTTP 201\footnote{signifie qu'un enregistrement vient d'être créé} ainsi que la représentation JSON de cet objet.
        \item En cas d'erreur, nous devons renvoyer un code HTTP 422\footnote{signifie Unprocessable Entity c'est à dire que le serveur ne peut pas sauvegarder l'enregistrement}. Nous retournons également un JSON représentant la raison pour laquelle la ressource n'a pas pu être sauvegardée.
      \end{itemize}

      A ce moment là, Les tests doivent échouer:

      \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ bundle exec rspec spec/controllers/api/v1/users_controller_spec.rb
      .FFFFFF
      \end{lstlisting}
      \end{scriptsize}

      Il est donc temps d'implémenter le code pour que nos tests reussissent (Listing \ref{})

      \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Implémentation du contrôlleur utilisateurs afin que les tests de création passent}]
      # app/controllers/api/v1/users_controller.rb

      class Api::V1::UsersController < ApplicationController

        # ...

        def create
          user = User.new user_params
          if user.save
            render json: user, status: 201, location: [:api, user]
          else
            render json: { errors: user.errors }, status: 422
          end
        end

        private

        def user_params
          params.require(:user).permit(:email, :password, :password_confirmation)
        end
      end
      \end{lstlisting}
      \end{scriptsize}

      Rappelez-vous qu'à chaque fois que nous ajoutons une entrée dans notre API il faut aussi ajouter cette action dans notre fichier \verb|routes.rb|.

      \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # config/routes.rb

      Rails.application.routes.draw do
        # ...
        resources :users, only: [:show, :create]
        # ...
      end
      \end{lstlisting}
      \end{scriptsize}

      Comme vous pouvez le constater, l'implémentation est assez simple. Nous avons également ajouté la méthode privée \verb|user_params| pour protéger les assignation d'attributs en masse. Maintenant, nos tests devraient passer:

      \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ bundle exec rspec spec/controllers/api/v1/users_controller_spec.rb
      .......

      Finished in 0.05967 seconds (files took 0.4673 seconds to load)
      7 examples, 0 failures
      \end{lstlisting}
      \end{scriptsize}

      Oura! \textit{Committons} les changements et continuons à construire notre application:

      \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ git add .
      $ git commit -m "Adds the user create endpoint"
      \end{lstlisting}
      \end{scriptsize}


    \subsection{Mettre à jour les utilisateurs}

      Le schéma de mise à jour des utilisateurs est très similaire à celui de la création (Section \ref{subsec:create_users}). Si vous êtes un développeur de Rails expérimenté, vous connaissez peut-être déjà les différences entre ces deux actions:

      \begin{itemize}
        \item L'action de mise à jour répond à une requête PUT/PATCH (Section \ref{section:setup_api}).
        \item Seul un utilisateur connecté devrait être en mesure de mettre à jour ses informations. Ce qui signifie que nous devrons forcer un utilisateur à s'authentifier. Nous en parlerons au chapitre 5.
      \end{itemize}

      Comme d'habitude, nous commençons par écrire nos tests (Listing \ref{lst:add_spec_users_controller_update}):

      \begin{scriptsize}
      \begin{lstlisting}[language=ruby, caption={Les tests du contrôlleur utilisateur avec les test de mise à jour}, label={lst:add_spec_users_controller_update}]
      # spec/controllers/api/v1/users_controller_spec.rb

      RSpec.describe Api::V1::UsersController, type: :controller do

        # ...

        describe "PUT/PATCH #update" do

         context "when is successfully updated" do
           before(:each) do
             @user = FactoryBot.create :user
             patch :update, params: {
               id: @user.id,
               user: { email: "newmail@example.com" } },
               format: :json
           end

           it "renders the json representation for the updated user" do
             user_response = JSON.parse(response.body, symbolize_names: true)
             expect(user_response[:email]).to eql "newmail@example.com"
           end

           it {  expect(response.response_code).to eq(200) }
         end

         context "when is not created" do
           before(:each) do
             @user = FactoryBot.create :user
             patch :update, params: {
               id: @user.id,
               user: { email: "bademail.com" } },
               format: :json
           end

           it "renders an errors json" do
             user_response = JSON.parse(response.body, symbolize_names: true)
             expect(user_response).to have_key(:errors)
           end

           it "renders the json errors on whye the user could not be created" do
             user_response = JSON.parse(response.body, symbolize_names: true)
             expect(user_response[:errors][:email]).to include "is invalid"
           end

           it {  expect(response.response_code).to eq(422) }
         end
       end
      end
      \end{lstlisting}
      \end{scriptsize}

      Pour que les tests réussissent, nous devons construire l'action de mise à jour sur le fichier \verb|users_controller.rb| et ajouter la route au fichier \verb|routes.rb|. Comme vous pouvez le voir, nous avons trop de code dupliqué, nous remanierons nos tests au chapitre 4.

      Tout d'abord nous ajoutons l'action le fichier routes.rb:

      \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # config/routes.rb

      Rails.application.routes.draw do
        # ...
        resources :users, only: [:show, :create, :update]
        # ...
      end
      \end{lstlisting}
      \end{scriptsize}

      Ensuite nous implémentons l'action de mise à jour sur le contrôleur utilisateur et faisons passer nos tests:

      \begin{scriptsize}
      \begin{lstlisting}[language=ruby]
      # app/controllers/api/v1/users_controller.rb
      class Api::V1::UsersController < ApplicationController
        # ...

        def update
          user = User.find(params[:id])

          if user.update(user_params)
            render json: user, status: 200, location: [:api, user]
          else
            render json: { errors: user.errors }, status: 422
          end
        end

        # ...
      end
      \end{lstlisting}
      \end{scriptsize}

      Tous nos tests devraient maintenant passer:

      \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ bundle exec rspec spec/controllers/api/v1/users_controller_spec.rb
      ............

      Finished in 0.08826 seconds (files took 0.47286 seconds to load)
      12 examples, 0 failures
      \end{lstlisting}
      \end{scriptsize}

      Vue que tout fonctionne, on effecte un \verb|commit|:

      \begin{scriptsize}
      \begin{lstlisting}[language=bash]
      $ git add .
      $ git commit -m "Adds update action the users controller"
      \end{lstlisting}
      \end{scriptsize}













\end{document}
