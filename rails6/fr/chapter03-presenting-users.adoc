[#chapter03-presenting-users]
= Présentation des utilisateurs

Dans le chapitre précédent, nous avons réussi à mettre en place les bases de la configuration de notre application. Nous avons même ajouté le _versioning_ par le biais des *en-têtes HTTP*. Dans les prochains chapitres, nous traiterons l’authentification des utilisateurs à l’aide de jetons d’authentification ainsi que la définition de permissions pour limiter l’accès aux utilisateurs connectés. Nous relierons ensuite les produits aux utilisateurs et leur donnerons la possibilité de passer des commandes.

Vous pouvez cloner le projet jusqu’à ce point avec:

[source,bash]
----
$ git clone https://github.com/madeindjs/market_place_api/tree/chapitre_2
----

Comme vous pouvez déjà l’imaginer, il existe de nombreuses solutions d’authentification pour Rails comme https://github.com/binarylogic/authlogic[AuthLogic], https://github.com/thoughtbot/clearance[Clearance] et https://github.com/plataformatec/devise[Devise]. Nous ne les utiliserons pas afin de mieux appréhender le mécanisme d'authentification.

Néanmoins nous allons mettre en place la gemme https://github.com/codahale/bcrypt-ruby[bcrypt] afin de hasher le mots de passe de l'utilisateur.

Ce chapitre sera complet. Il sera peut-être long mais je vais essayer d’aborder autant de sujets que possible. N’hésitez pas à vous prendre un café et allons-y. A la fin de ce chapitre, vous aurez construit toute la logique des utilisateurs ainsi que la validation et la gestion des erreurs.

Nous voulons suivre ce chapitre, c’est donc un bon moment pour créer une nouvelle branche:

[source,bash]
----
$ git checkout -b chapter3
----

NOTE: Assurez-vous simplement d’être sur la branche `master` avant.

== Modèle d’utilisateur

=== Génération du modèle `User`

Nous allons commencer par générer notre modèle `User`. Ce modèle sera vraiment basique et contiendra seulement deux champs:

- `email` qui sera unique et lui permettra de se connecter à l'application
- `password_digest` qui contiendra la version *haché* du mot de passe (nous en reparlerons plus tard dans ce chapitre)

Afin de générer notre modèle `User`, nous utiliserons la méthode _generate model_ fournie par Ruby on Rails. Elle s'utilise très facilement:

[source,bash]
----
$ rails generate model User email:string password_digest:string
invoke  active_record
      create    db/migrate/20190603195146_create_users.rb
      create    app/models/user.rb
      invoke    test_unit
      create      test/models/user_test.rb
      create      test/fixtures/users.yml
----


==== La migration

Cette commande génère beaucoup de fichiers! Ne vous inquiétez pas, nous allons les passer en revue les un après les autres.

Le fichier de migration contenu dans le dossier _db/migrate_ contient la *migration* qui décrie les modifications qui seront effectués sur la base de données.

Elle devrait ressembler à ceci

.db/migrate/20190603195146_create_users.rb
[source,ruby]
----
class CreateUsers < ActiveRecord::Migration[6.0]
  def change
    create_table :users do |t|
      t.string :email
      t.string :password_digest

      t.timestamps
    end
  end
end
----

Nous allons la modifier un petit peut afin de la faire correspondre à nos attentes:

- l'email est unique: on utilise la propriété `unique: true`
- le mot de passe est obligatoire: on utilise la propriété `null: false`

La migration deviens donc:

.db/migrate/20190603195146_create_users.rb
[source,ruby]
----
# ...
create_table :users do |t|
  t.string :email, unique: true
  t.string :password_digest, null: false
  # ...
end
----

Une fois la migration terminée, nous pouvons effectuer les modifications avec la commande suivante:

.db/migrate/20190603195146_create_users.rb
[source,ruby]
----
$ rake db:migrate
== 20190603195146 CreateUsers: migrating ======================================
-- create_table(:users)
   -> 0.0027s
== 20190603195146 CreateUsers: migrated (0.0028s) =============================
----

NOTE: La commande va convertir notre migration en requête SQL qui va mettre à jour la base de données SQlite3 contenue dans le dossier _db_.

==== Le modèle

Nous avons donc défini notre schéma de la base de données. La prochaine étape est de mettre à jour notre modèle afin de définir les *règles de validation*. Ces règles se définissent dans le modèle situé dans le dossier _app/models_.

Ruby on Rails propose un mécanisme complet de validation que vous pouvez consulter sur https://guides.rubyonrails.org/active_record_validations.html[leur documentation officielle]. Dans notre cas, nous voulons valider deux choses:

- l'email doit avoir un format valide
- l'email doit être unique
- le mot de passe doit être remplis

Ces trois règles se définissent par le code suivant:

.app/models/user.rb
[source,ruby]
----
class User < ApplicationRecord
  validates :email, uniqueness: true
  validates_format_of :email, with: /@/
  validates :password_digest, presence: true
end
----

Et voilà. Rails utilise une syntaxe très simple et le code est très lisible.

.Validation du courriel
****
Vous remarquerez peut être que la validation du courriel utilise une validation simpliste en ne vérifiant que la présence d'un `@`.

C'est normal.

Une infinité d'exceptions existent en la matière d'adresse mail si bien https://davidcel.is/posts/stop-validating-email-addresses-with-regex/[que même `"Look at all these spaces!"@example.com` est une adresse valide]. Il vaut mieux donc privilégier une approche simple et confirmer le mail par un mail de validation.

Par soucis de brièveté, j'ai choisi une approche simpliste.
****

==== Les tests unitaires

Nous terminons par les tests unitaires. Nous utilisons ici le framework par


Nous devons donc commencer par mettre à jour nos données de tests contenue dans le dossier `tests/fixtures`.Les  _Fixtures_ permettent donc de remplir votre base de données de tests avec des données *prédéfinies* avant l'exécution de vos tests. Il y a un fichier par modèle.

NOTE: Les _fixtures_ ne sont pas conçus pour créer tous les données dont vos tests ont besoin. Elle permettent juste de définir les données basiques dont votre application à besoins.

Nous allons donc commencer par créer une _fixture_ définissant un utilisateur:

.test/fixtures/users.yml
[source,yaml]
----
one:
  email: one@one.org
  password_digest: hashed_password
----

Nous pouvons donc maintenant créer les tests. Il y en a trois:

- on vérifie que un utilisateur avec des données valide est valide:

.test/models/user_test.rb
[source,ruby]
----
# ...
test 'user with a valid email should be valid' do
  user = User.new(email: 'test@test.org', password_digest: 'test')
  assert user.valid?
end
----

- on vérifie que un utilisateur avec un courriel invalide n'est pas valide:

.test/models/user_test.rb
[source,ruby]
----
# ...
test 'user with unvalid email should be unvalid' do
  user = User.new(email: 'test', password_digest: 'test')
  assert_not user.valid?
end
----

- on vérifie que un utilisateur avec un courriel déjà utilisé n'est pas valide. on utilise donc le même courriel que la _fixture_ que nous venons de créer.

.test/models/user_test.rb
[source,ruby]
----
# ...
test 'user with taken email should be unvalid' do
  other_user = users(:one)
  user = User.new(email: other_user.email, password_digest: 'test')
  assert_not user.valid?
end
----

Et voilà. Nous pouvons vérifier que notre est juste en lançant simplement les tests unitaires que nous venons de créer:

[source,bash]
----
$ rake test
# Running:

...

Finished in 0.114983s, 26.0908 runs/s, 26.0908 assertions/s.
3 runs, 3 assertions, 0 failures, 0 errors, 0 skips
----

// NOTE: La liste complète des _assertions_ disponibles sont listées la https://guides.rubyonrails.org/testing.html#available-assertions[documentation officielle]

Je pense qu'il est temps de faire un petit _commit_ afin de valider notre avancement:

[source,bash]
----
$ git add . && git commit -m "Create user model"
----

=== Hachage du mot de passe

Nous devons d’abord ajouter la gemme Bcrypt au _Gemfile_. Nous pouvons utiliser la commande `bundle add`. Celle-ci va s'occuper:

1. d'ajouter la gemme au Gemfile en récupérant la version actuelle
2. lancer la commande `bundle install` qui va installer la gemme et mettre à jour le fichier _Gemfile.lock_ qui "verrouille" la version actuelle de la gemme

Lancez donc la commande suivante:

[source,bash]
----
$ bundle add bcrypt
----

Une fois la commande éxécuté, la ligne suivante est ajoutée à la fin du _Gemfile_:

[source,ruby]
.Gemfile
----
gem "bcrypt", "~> 3.1"
----

NOTE: La version 3.1 de bcrypt est celle actuelle à l'heure ou j'écris ces lignes. Elle peut donc varier pour votre cas.




// CURRENT bcrypt







Maintenant, et si tout s’est bien passé, nous serons en mesure de générer le modèle `user` à l’aide du *générateur* de Devise:

[source,bash]
----
$ rails g devise User
    invoke  active_record
    create    db/migrate/20181113070805_devise_create_users.rb
    create    app/models/user.rb
    invoke    rspec
    create      spec/models/user_spec.rb
    invoke      factory_bot
    create        spec/factories/users.rb
    insert    app/models/user.rb
    route  devise_for :users
----

A partir de maintenant, chaque fois que nous créons un modèle, le générateur va également créer un fichier d’usine pour ce modèle. Cela nous aidera à créer facilement des utilisateurs de tests et facilitera la rédaction de nos tests.

[source,ruby]
.spec/factories/users.rb
----
FactoryBot.define do
  factory :user do
  end
end
----

Ensuite, nous allons migrer la base de données et préparer la base de données de test.

[source,bash]
----
$ rake db:migrate
== 20181113070805 DeviseCreateUsers: migrating ================================
-- create_table(:users)
   -> 0.0008s
-- add_index(:users, :email, {:unique=>true})
   -> 0.0005s
-- add_index(:users, :reset_password_token, {:unique=>true})
   -> 0.0007s
== 20181113070805 DeviseCreateUsers: migrated (0.0023s) =======================
----

[source,bash]
----
$ rake db:test:prepare
----

Faisons maintenant un _commit_ afin de garder un historique concis:

[source,bash]
----
$ git add .
$ git commit -m "Adds devise user model"
----

== Notre premier test sur le modèle User

Nous allons ajouter quelques spécifications pour nous assurer que le modèle utilisateur répond aux attributs `email`, `password` et `password_confirmation` fournis par Devise. Pour des raisons de commodité, nous allons modifier le fichier d’usine des utilisateurs pour ajouter les attributs correspondants.

[source,ruby]
.spec/factories/users.rb
----
FactoryBot.define do
  factory :user do
    email { FFaker::Internet.email }
    password { '12345678' }
    password_confirmation { '12345678' }
  end
end
----

Une fois les attributs ajoutés, il est temps de tester notre modèle `User`.

[source,ruby]
.spec/models/user_spec.rb
----
# ...
RSpec.describe User, type: :model do
  before { @user = FactoryBot.build(:user) }
  subject { @user }

  it { should respond_to(:email) }
  it { should respond_to(:password) }
  it { should respond_to(:password_confirmation) }
  it { should be_valid }
end
----

Vue que nous avons préparé la base de données de test avec `rake db:test:prepare`, nous pouvons exécuter les tests:

[source,bash]
----
$ bundle exec rspec spec/models/user_spec.rb
....

Finished in 0.03231 seconds (files took 0.81624 seconds to load)
4 examples, 0 failures
----

C’était facile! Nous devrions maintenant faire un `commit`:

[source,bash]
----
$ git add .
$ git commit -am 'Adds user firsts specs'
----

== Construire les utilisateurs

Il est temps de faire notre premier point d’entrée. Nous allons juste commencer à construire l’action `show` pour l’utilisateur qui va afficher un utilisateur en JSON. Nous devons d’abord générer le `users_controller`, ajouter les tests correspondants et ensuite construire le code réel. Tout d’abord, nous générons le contrôleur utilisateur:

[source,bash]
----
$ rails generate controller users
----

Cette commande va créer le fichier `users_controller_spec.rb`. Avant d’entrer dans le vif du sujet, il y a deux choses que nous voulons tester pour une API:

* La structure du JSON renvoyée par le serveur
* Le code de réponse HTTP renvoyé par le serveur

.Les codes HTTP courants
****
Le premier chiffre du code d’état spécifie l’une des cinq classes de réponse. Le strict minimum pour un client HTTP est qu’il utilise une ces cinq classes. Voici une liste des codes HTTP couramment utilisés:

* `200`: Réponse standard pour les requêtes HTTP réussies. C’est généralement sur les requêtes `GET`
* `201`: La demande a été satisfaite et a donné lieu à la création d’une nouvelle ressource. Après les demandes de `POST`
* `204`: Le serveur a traité la requête avec succès, mais ne renvoie aucun contenu. Il s’agit généralement d’une requête `DELETE` réussie.
* `400`: La requête ne peut pas être exécutée en raison d’une mauvaise syntaxe. Peut arriver pour tout type de requête.
* `401`: Similaire au 403, mais spécifiquement pour une utilisation lorsque l’authentification est requise et qu’elle a échoué ou n’a pas encore été fournie. Peut arriver pour tout type de requête.
* `404`: La ressource demandée n’a pas pu être trouvée mais peut être à nouveau disponible à l’avenir. Habituellement, concerne les requêtes `GET`
* `500`: Un message d’erreur générique, donné lorsqu’une condition inattendue a été rencontrée et qu’aucun autre message spécifique ne convient.

Pour une liste complète des codes de réponse HTTP, consultez l’ https://fr.wikipedia.org/wiki/Liste_des_codes_HTTP[article sur Wikipedia].
****

Pour garder notre code bien découpé, nous allons créer quelques répertoires sous le répertoire des tests des contrôleurs afin d’être cohérent dans la configuration. Il existe aussi une autre convention qui utilise à la place du répertoire `controllers` un répertoire de `request` ou `integration`. Dans notre cas, je préfère rester cohérent avec le répertoire `app/controllers`.

[source,bash]
----
$ mkdir -p spec/controllers/api/v1
$ mv spec/controllers/users_controller_spec.rb spec/controllers/api/v1
----

Après avoir créé les répertoires, nous devons changer le nom de la classe `UsersController` en `Api::V1::UsersController`. Le fichier doit ressembler à ça:

[source,ruby]
.spec/controllers/api/v1/users_controller_spec.rb
----
RSpec.describe Api::V1::UsersController, type: :controller do
end
----

Maintenant, voici le fichier avec les tests créés:

[source,ruby]
.spec/controllers/api/v1/users_controller_spec.rb
----
# ...
RSpec.describe Api::V1::UsersController, type: :controller do
  before(:each) { request.headers['Accept'] = "application/vnd.marketplace.v1" }

  describe "GET #show" do
    before(:each) do
      @user = FactoryBot.create :user
      get :show, params: { id: @user.id, format: :json}
    end

    it "returns the information about a reporter on a hash" do
      user_response = JSON.parse(response.body, symbolize_names: true)
      expect(user_response[:email]).to eql @user.email
    end

    it { expect(response).to be_success }
  end
end
----

Il suffit ensuite d’ajouter l’action à notre contrôleur. C’est extrêmement simple:

[source,ruby]
.app/controllers/api/v1/users\_controller.rb
----
class  Api::V1::UsersController < ApplicationController
  def show
    render json: User.find(params[:id])
  end
end
----

Les codes HTTP courants. Il est possible qu’il faille activer le module `Devise::Test::ControllerHelpers` au fichier `spec/rails_helper.rb` afin de charger les utilitaires Devise aux test. Si c’est le cas, ajoutez la ligne suivante

[source,ruby]
.spec/rails_helper.rb
----
#  ...
RSpec.configure do |config|
  #  ...
  config.include Devise::Test::ControllerHelpers, type: :controller
  #  ...
end
----

Si vous exécutez les tests avec `rspec spec/controllers` vous obtenez l’erreur suivante:

....
$ rspec spec/controllers
FF

Failures:

  1) Api::V1::UsersController GET #show returns the information about a reporter on a hash
    Failure/Error: get :show, params: { id: @user.id, format: :json}

    ActionController::UrlGenerationError:
    No route matches {:action=>"show", :controller=>"api/v1/users", :format=>:json, :id=>1}
      ...

  2) Api::V1::UsersController GET #show
    Failure/Error: get :show, params: { id: @user.id, format: :json}


    ActionController::UrlGenerationError:
    No route matches {:action=>"show", :controller=>"api/v1/users", :format=>:json, :id=>1}
      ...

Finished in 0.01632 seconds (files took 0.47675 seconds to load)
  2 examples, 2 failures
....

Ce type d’erreur est très courant lorsque vous générer vos ressources à la main! En effet, nous avons totalement oublié les routes. Alors ajoutons-les:

[source,ruby]
.config/routes.rb
----
require 'api_constraints'

Rails.application.routes.draw do
  devise_for :users
  # Api definition
  namespace :api, defaults: { format: :json }, constraints: { subdomain: 'api' }, path: '/' do
    scope module: :v1, constraints: ApiConstraints.new(version: 1, default: true) do
      resources :users, only: [:show]
    end
  end
end
----

Vos tests devraient désormais passer:

[source,bash]
----
$ bundle exec rspec spec/controllers
..

Finished in 0.02652 seconds (files took 0.47291 seconds to load)
2 examples, 0 failures
----

Comme d’habitude, après avoir ajouté une des fonctionnalités dont nous sommes satisfaits, nous faisons un `commit`:

[source,bash]
----
$ git add .
$ git commit -m "Adds show action the users controller"
----

=== Tester notre ressource avec cURL

Nous avons donc enfin une ressource à tester. Nous avons plusieurs solutions pour la tester. La première qui me vient à l’esprit est l’utilisation de cURL qui est intégré dans presque toutes les distributions Linux. Alors, essayons:

NOTE: Rappelez-vous que notre URI de base est `api.market_place_api.dev`.

[source,bash]
----
$ curl -H 'Accept: application/vnd.marketplace.v1' http://api.market_place_api.dev/users/1
----

En faisant cela nous obtenons une erreur et c’est normal: l’utilisateur n’existe pas. Créons-le avec le terminal:

[source,bash]
----
$ rails console
Loading development environment (Rails 5.2.1)
2.5.3 :001 >  User.create email: "example@marketplace.com", password: "12345678", password_confirmation: "12345678"
----

Après avoir créé l’utilisateur, notre appel cURL devrait fonctionner:

[source,bash]
----
$ curl -H 'Accept: application/vnd.marketplace.v1' \
http://api.market_place_api.dev/users/1
{"id":1,"email":"example@marketplace.com", ...
----

Et voilà! Vous avez maintenant une entrée d’API d’enregistrement d’utilisateur. Si vous avez des problèmes avec la réponse, vous devrez peut-être modifier le fichier `application_controller.rb` et ajouter la ligne suivante:

[source,ruby]
.app/controllers/application_controller.rb
----
class ApplicationController < ActionController::API
  # Prevent CSRF attacks by raising an exception.
  # For APIs, you may want to use :null_session instead.
  protect_from_forgery with: :null_session
end
----

Comme suggéré même par Rails, nous devrions utiliser `null_session` pour empêcher *les attaques CSFR*. Je vous recommande fortement de le faire sinon les requêtes `POST` et `PUT` ne fonctionneront pas. Après avoir mis à jour le fichier `application_controller.rb` c’est le moment de faire un `commit`:

[source,bash]
----
$ git add .
$ git commit -m "Updates application controller to prevent CSRF exception from being raised"
----

=== Créer les utilisateurs

Maintenant que nous avons une meilleure compréhension de la façon de construire des points d’entrée, il est temps d’étendre notre API. Une des fonctionnalités les plus importante est de laisser les utilisateurs créer un profil sur notre application. Comme d’habitude, nous allons écrire des tests avant d’implémenter notre code pour étendre notre suite de tests.

Assurez-vous que votre répertoire Git est propre et que vous n’avez pas de fichier en _staging_. Si c’est le cas, _committez_-les pour que nous puissions recommencer à zéro.

Commençons donc par écrire notre test tests en ajoutant une entrée pour créer un utilisateur sur le fichier `users_controller_spec.rb` :

[source,ruby]
.spec/controllers/api/v1/users_controller_spec.rb
----
RSpec.describe Api::V1::UsersController, type: :controller do
  # ...
  describe 'POST #create' do
    context 'when is successfully created' do
      before(:each) do
        @user_attributes = FactoryBot.attributes_for :user
        post :create, params: { user: @user_attributes }, format: :json
      end

      it 'renders the json representation for the user record just created' do
        user_response = JSON.parse(response.body, symbolize_names: true)
        expect(user_response[:email]).to eql @user_attributes[:email]
      end

      it { expect(response.response_code).to eq(201) }
    end

    context 'when is not created' do
      before(:each) do
        # notice I'm not including the email
        @invalid_user_attributes = { password: '12345678',
                                     password_confirmation: '12345678' }
        post :create, params: { user: @invalid_user_attributes }, format: :json
      end

      it 'renders an errors json' do
        user_response = JSON.parse(response.body, symbolize_names: true)
        expect(user_response).to have_key(:errors)
      end

      it 'renders the json errors on why the user could not be created' do
        user_response = JSON.parse(response.body, symbolize_names: true)
        expect(user_response[:errors][:email]).to include "can't be blank"
      end

      it {  expect(response.response_code).to eq(422) }
    end
  end
end
----

Cela fait beaucoup de code. Ne vous inquiétez pas, je vous explique tout:

* Nous devons valider les états sur lesquels l’enregistrement peut être valide ou invalide. Dans ce cas, nous utilisons les `context` pour réaliser ces scénarios.
* Au cas où tout se passe bien, nous devrions retourner un code HTTP *201* ainsi que la représentation JSON de cet objet.
* En cas d’erreur, nous devons renvoyer un code HTTP *422*. Nous retournons également un JSON représentant la raison pour laquelle la ressource n’a pas pu être sauvegardée.

A ce moment là, les tests doivent échouer:

[source,bash]
----
$ bundle exec rspec spec/controllers/api/v1/users_controller_spec.rb
.FFFFFF
----

Il est donc temps d’implémenter le code pour que nos tests réussissent:

[source,ruby]
.app/controllers/api/v1/users_controller.rb
----
class Api::V1::UsersController < ApplicationController
  # ...
  def create
    user = User.new user_params
    if user.save
      render json: user, status: 201, location: [:api, user]
    else
      render json: { errors: user.errors }, status: 422
    end
  end

  private

  def user_params
    params.require(:user).permit(:email, :password, :password_confirmation)
  end
end
----

Rappelez-vous qu’à chaque fois que nous ajoutons une entrée dans notre API il faut aussi ajouter cette action dans notre fichier `routes.rb`.

[source,ruby]
.config/routes.rb
----
Rails.application.routes.draw do
  # ...
  resources :users, only: [:show, :create]
  # ...
end
----

Comme vous pouvez le constater, l’implémentation est assez simple. Nous avons également ajouté la méthode privée `user_params` pour protéger les assignations d’attributs en masse. Maintenant, nos tests devraient passer:

[source,bash]
----
$ bundle exec rspec spec/controllers/api/v1/users_controller_spec.rb
.......

Finished in 0.05967 seconds (files took 0.4673 seconds to load)
7 examples, 0 failures
----

Oura! _Committons_ les changements et continuons à construire notre application:

[source,bash]
----
$ git add .
$ git commit -m "Adds the user create endpoint"
----

=== Mettre à jour les utilisateurs

Le schéma de mise à jour des utilisateurs est très similaire à celui de la création. Si vous êtes un développeur de Rails expérimenté, vous connaissez peut-être déjà les différences entre ces deux actions:

* L’action de mise à jour répond à une requête PUT/PATCH .
* Seul un utilisateur connecté devrait être en mesure de mettre à jour ses informations. Ce qui signifie que nous devrons forcer un utilisateur à s’authentifier. Nous en parlerons au chapitre 5.

Comme d’habitude, nous commençons par écrire nos tests:

[source,ruby]
.spec/controllers/api/v1/users_controller_spec.rb
----
RSpec.describe Api::V1::UsersController, type: :controller do
  # ...
  describe "PUT/PATCH #update" do

   context "when is successfully updated" do
     before(:each) do
       @user = FactoryBot.create :user
       patch :update, params: {
         id: @user.id,
         user: { email: "newmail@example.com" } },
         format: :json
     end

     it "renders the json representation for the updated user" do
       user_response = JSON.parse(response.body, symbolize_names: true)
       expect(user_response[:email]).to eql "newmail@example.com"
     end

     it {  expect(response.response_code).to eq(200) }
   end

   context "when is not created" do
     before(:each) do
       @user = FactoryBot.create :user
       patch :update, params: {
         id: @user.id,
         user: { email: "bademail.com" } },
         format: :json
     end

     it "renders an errors json" do
       user_response = JSON.parse(response.body, symbolize_names: true)
       expect(user_response).to have_key(:errors)
     end

     it "renders the json errors on why the user could not be created" do
       user_response = JSON.parse(response.body, symbolize_names: true)
       expect(user_response[:errors][:email]).to include "is invalid"
     end

     it {  expect(response.response_code).to eq(422) }
   end
 end
end
----

Pour que les tests réussissent, nous devons construire l’action de mise à jour sur le fichier `users_controller.rb` et ajouter la route au fichier `routes.rb`. Comme vous pouvez le voir, nous avons trop de code dupliqué, nous remanierons nos tests au chapitre 4. Tout d’abord nous ajoutons l’action le fichier `routes.rb`:

[source,ruby]
.config/routes.rb
----
Rails.application.routes.draw do
  # ...
  resources :users, only: [:show, :create, :update]
  # ...
end
----

Ensuite nous implémentons l’action de mise à jour sur le contrôleur utilisateur et faisons passer nos tests:

[source,ruby]
.app/controllers/api/v1/users_controller.rb
----
class Api::V1::UsersController < ApplicationController
  # ...
  def update
    user = User.find(params[:id])

    if user.update(user_params)
      render json: user, status: 200, location: [:api, user]
    else
      render json: { errors: user.errors }, status: 422
    end
  end
  # ...
end
----

Tous nos tests devraient maintenant passer:

[source,bash]
----
$ bundle exec rspec spec/controllers/api/v1/users_controller_spec.rb
............

Finished in 0.08826 seconds (files took 0.47286 seconds to load)
12 examples, 0 failures
----

Vue que tout fonctionne, on effectue un _commit_:

[source,bash]
----
$ git add .
$ git commit -m "Adds update action the users controller"
----

=== Supprimer l’utilisateur

Jusqu’à présent, nous avons construit pas mal d’actions sur le contrôleur des utilisateurs avec leurs tests mais ce n’est terminé. Il nous en manque juste une dernière qui est l’action de destruction. Créons donc le test:

[source,ruby]
.spec/controllers/api/v1/users_controller_spec.rb
----
RSpec.describe Api::V1::UsersController, type: :controller do
  before(:each) { request.headers['Accept'] = 'application/vnd.marketplace.v1' }
  # ...
  describe "DELETE #destroy" do
    before(:each) do
      @user = FactoryBot.create :user
      delete :destroy, params: { id: @user.id }, format: :json
    end

    it { expect(response.response_code).to eq(204) }
  end
end
----

Comme vous pouvez le voir, le test est très simple. Nous ne répondons qu’avec un statut de *204* qui signifie `No Content`. Nous pourrions aussi retourner un code d’état de *200*, mais je trouve plus naturel de répondre `No Content` dans ce cas car nous supprimons une ressource et une réponse réussie peut suffire.

La mise en œuvre de l’action de destruction est également assez simple:

[source,ruby]
.app/controllers/api/v1/users_controller.rb
----
class Api::V1::UsersController < ApplicationController
  # ...
  def destroy
    user = User.find(params[:id])
    user.destroy
    head 204
  end
  # ...
end
----

N’oubliez pas d’ajouter l’action `destroy` dans le fichier `routes.rb`:

[source,ruby]
.config/routes.rb
----
Rails.application.routes.draw do
  # ...
  resources :users, only: [:show, :create, :update, :destroy]
  # ...
end
----

Si tout est correct, vos tests devraient passer:

[source,bash]
----
$ bundle exec rspec spec/controllers/api/v1/users_controller_spec.rb
.............

Finished in 0.09255 seconds (files took 0.4618 seconds to load)
13 examples, 0 failures
----

Rappelez-vous qu’après avoir apporté quelques modifications à notre code, il est de bonne pratique de les _commiter_ afin que nous gardions un historique bien découpé.

[source,bash]
----
$ git add .
$ git commit -m "Adds destroy action to the users controller"
----

== Conclusion

Oh vous êtes là! Bien joué! Je sais que c’était probablement long mais n’abandonnez pas! Assurez-vous que vous comprenez chaque morceau de code, les choses vont s’améliorer, dans le prochain chapitre, nous remanierons nos tests pour rendre le code plus lisible et plus maintenable. Alors restez avec moi!
