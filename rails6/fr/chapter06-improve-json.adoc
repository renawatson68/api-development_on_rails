[#chapter06-improve-json]
= Modélisation du JSON

Dans le chapitre précédent, nous avons ajouté les produits à l’application et construit tous les routes nécessaires. Nous avons également associé un produit à un utilisateur et restreint certaines des actions de `products_controller`.

Maintenant, vous devriez être satisfaits de tout ce travail. Mais nous avons encore du pain sur la planche. Actuellement, nous avons une sortie JSON qui n’est pas parfaite. La sortie JSON ressemble à celle-ci:

[source,json]
----
{
  "products": [
      {
          "id": 1,
          "title": "Tag Case",
          "price": "98.7761933800815",
          "published": false,
          "user_id": 1,
          "created_at": "2018-12-20T12:47:26.686Z",
          "updated_at": "2018-12-20T12:47:26.686Z"
      },
    ]
}
----

Or nous voulons un sortie qui ne contient pas les champs `user_id`, `created_at` et `updated_at`.

Aussi, une partie importante et difficile lors de la création de votre API est de décider le format de sortie. Heureusement, certaines organisations ont déjà fait face à ce genre de problème et elles ont ainsi établi certaines conventions que vous allez découvrir dans ce chapitre.

Vous pouvez cloner le projet jusqu’à ce point avec:

[source,bash]
----
$ git checkout tags/checkpoint_chapter06
----

Commençons une nouvelle branche pour ce chapitre:

[source,bash]
----
$ git checkout -b chapter06
----


== Présentation de https://jsonapi.org/[JSON:API]

Une partie importante et difficile lors de la création de votre API est de décider le format de sortie. Heureusement, certaines conventions existes déjà.

L'une d'elles, certainement la plus utilisée est https://jsonapi.org/[JSON:API]. La https://jsonapi.org/format/#document-structure[documentation de JSON:API] nous donne quelques règles à suivre concernant le formatage du document JSON.

Ainsi, notre document *doit* contenir ces clefs:

* `data`: qui doit contenir les données que nous renvoyons
* `errors` qui doit contenir un tableau des erreurs qui sont survenues.
* `meta` qui contient un https://jsonapi.org/format/#document-meta[objet meta]

Le contenu de la clé `data` est lui aussi assez stricte:

* il doit posséder une clé `type`qui décrit le type du modèle JSON (si c’est un article, un utilisateur, etc..)
* les propriétés de l’objets doivent être placées dans une clé `attributes` et les _undescore_ (`_`) sont remplacés par des tirets (`-`)
* les liaisons de l’objets doivent être placées dans une clé `relationships`

Dans ce chapitre, nous allons personnaliser la sortie JSON en utilisant la gemme https://github.com/Netflix/fast_jsonapi[fast_jsonapi] de Netflix.


== Mise en place de la gemme

Installons donc la gemme `fast_jsonapi`:

[source,bash]
----
$ bundle add fast_jsonapi
----

Vous devriez être prêts à continuer avec ce tutoriel.

== Sérialiser l’utilisateur

Nous devons d’abord ajouter un fichier `user_serializer`. Nous pouvons le faire manuellement, mais la gemme fournit une interface en ligne de commande pour le faire:

[source,bash]
----
$ rails generate serializer User email
      create  app/serializers/user_serializer.rb
----

Ceci a créé un fichier appelé `user_serializer.rb` sous le répertoire `app/serializers`, qui devrait ressembler au fichier suivant:

[source,ruby]
.app/serializers/user_serializer.rb
----
class UserSerializer
  include FastJsonapi::ObjectSerializer
  attributes :email
end
----

Ce _serializer_ va nous permettre de convertir notre objet `User` en JSON qui implémente correctement la norme JSON:API. Nous avons spécifié l'attribut `email` afin qu'il soit présent dans le tableau `data`.

Essayons tout ça dans la console Rails avec `rails console`:

[source,ruby]
----
2.6.3 :001 > UserSerializer.new( User.first ).serializable_hash
=> {:data=>{:id=>"25", :type=>:user, :attributes=>{:email=>"tova@beatty.org"}}}
----

Et voilà. Comme vous le voyez, tout se fait très facilement. Nous pouvons donc utiliser notre nouveau _serializer_ dans notre _controller_:

.app/controllers/api/v1/users_controller.rb
[source,ruby]
----
class Api::V1::UsersController < ApplicationController
  # ...
  def show
    render json: UserSerializer.new(@user).serializable_hash
  end

  def update
    if @user.update(user_params)
      render json: UserSerializer.new(@user).serializable_hash
    else
      # ...
    end
  end

  def create
    # ...
    if @user.save
      render json: UserSerializer.new(@user).serializable_hash, status: :created
    else
      # ...
    end
  end

  # ...
end
----

Assez facile, non? Cependant nous devrions avoir un test qui échoue. Essayez par vous même:

[source,bash]
----
$ rake test

Failure:
Expected: "one@one.org"
  Actual: nil
----


Vous pouvez voir que pour une raison quelconque, la réponse n’est pas tout à fait ce que nous attendons. C’est parce que la gemme modifie la réponse que nous avions précédemment définie. Donc pour faire passer les tests, il suffit de mettre à jour notre test:

[source,ruby]
.test/controllers/api/v1/users_controller_test.rb
----
# ...
class Api::V1::UsersControllerTest < ActionDispatch::IntegrationTest
  # ...
  test "should show user" do
    # ...
    assert_equal @user.email, json_response['data']['attributes']['email']
  end
  # ...
end
----

Si vous faites les tests maintenant, ils devraient passer:

[source,bash]
----
$ rake test

# Running:

........................
----

_Commitons_ ces changements et continuons d’avancer:

[source,bash]
----
$ git add .
$ git commit -am "Adds user serializer for customizing the json output"
----

== Sérialiser les produits

Maintenant que nous comprenons comment fonctionne la gemme de sérialisation, il est temps de personnaliser la sortie des produits. La première étape est identique à celle pour l’utilisateur, nous avons besoin d’un sérialiseur de produit, alors faisons-le:

[source,bash]
----
$ rails generate serializer Product title price published
      create  app/serializers/product_serializer.rb
----

Ajoutons maintenant les attributs à sérialiser pour le produit, comme nous l’avons fait avec l’utilisateur dans la section précédente:

[source,ruby]
.app/serializers/product_serializer.rb
----
class ProductSerializer
  include FastJsonapi::ObjectSerializer
  attributes :title, :price, :published
end
----

Et voilà. Ce n’est pas plus compliqué que ça. Modifions un petit peu notre contrôleur.

[source,ruby]
.app/controllers/api/v1/products_controller.rb
----
class Api::V1::ProductsController < ApplicationController
  # ...
  def index
    @products = Product.all
    render json: ProductSerializer.new(@products).serializable_hash
  end

  def show
    render json: ProductSerializer.new(@product).serializable_hash
  end

  def create
    product = current_user.products.build(product_params)
    if product.save
      render json: ProductSerializer.new(product).serializable_hash, status: :created
    else
      # ...
    end
  end

  def update
    if @product.update(product_params)
      render json: ProductSerializer.new(@product).serializable_hash
    else
      # ...
    end
  end
  # ...
end
----

Et on met à jour notre test fonctionnel:

[source,ruby]
.app/controllers/api/v1/products_controller.rb
----
# ...
class Api::V1::ProductsControllerTest < ActionDispatch::IntegrationTest
  # ...
  test 'should show product' do
    # ...
    assert_equal @product.title, json_response['data']['attributes']['title']
  end
  # ...
end
----

Vous pouvez lancer les tests pour vérifier mais ils devraient encore être bons.

_Commitons_ ces petits changements:

[source,bash]
----
$ git add .
$ git commit -m "Adds product serializer for custom json output"
----

=== Sérialiser les associations

Nous avons travaillé avec des sérialiseurs et vous remarquerez peut-être que c’est très simple. Dans certains cas, la décision difficile est de savoir comment nommer vos routes ou comment structurer la sortie JSON afin que votre solution soit pérenne. Lorsque vous travaillez avec des associations entre les modèles sur une API, il existe de nombreuses approches que vous pouvez prendre.

Nous n'avons pas à nous soucier de ce problème dans notre cas, la norme JSON:API l'a fait pour nous!

Pour résumer, nous avons une association de type `has_many` entre l’utilisateur et le modèle de produit.

[source,ruby]
.app/models/user.rb
----
class User < ApplicationRecord
  has_many :products, dependent: :destroy
  # ...
end
----

[source,ruby]
.app/models/product.rb
----
class Product < ApplicationRecord
  belongs_to :user
  # ...
end
----

C’est une bonne idée d’intégrer des modèles dans d’autres modèles dans d’autres modèles car cela évite au client de l’API d’exécuter plusieurs requêtes. Cela rendra la sortie un peu plus lourde mais lorsque vous récupérez de nombreux enregistrements, cela peut vous éviter un énorme goulet d’étranglement.

== Théorie de l'injection des relations

Imaginez un scénario où vous allez chercher les produits dans l’API, mais dans ce cas, vous devez afficher une partie des informations de l’utilisateur.

Une solution possible serait d’ajouter l’attribut `user_id` au `product_serializer` pour que nous puissions récupérer l’utilisateur correspondant plus tard. Cela peut sembler être une bonne idée, mais si vous vous souciez de la performance, ou si les transactions de votre base de données ne sont pas assez rapides, vous devriez reconsidérer cette approche. Vous devez comprendre que pour chaque produit que vous récupérez, vous allez devoir récupérer son utilisateur correspondant.

Face à ce problème, il y a plusieurs alternatives possibles.

=== Intégrer dans un attribut meta

La première solution  Une bonne solution à mon avis est d’intégrer les identifiants des utilisateurs liés aux produits dans un attribut meta, donc nous avons une sortie JSON comme:
[source,json]
----
{
  "meta": { "user_ids": [1,2,3] },
  "data": [

  ]
}
----
Cela peut nécessiter une configuration supplémentaire sur le terminal de l’utilisateur, afin que le client puisse récupérer ces utilisateurs à partir de ces `user_ids`.

=== Incorporer l'objet dans l'attribut

Une autre solution, est d’incorporer l’objet `user` dans l’objet `product`. Ce qui peut rendre la première requête un peu plus lente, mais de cette façon le client n’a pas besoin de faire une autre requête supplémentaire. Un exemple des résultats escomptés est présenté ci-dessous:

[source,json]
----
{
  "data":
  [
      {
         "id": 1,
         "type": "product",
         "attributes": {
           "title": "First product",
           "price": "25.02",
           "published": false,
           "user": {
             "id": 2,
             "attributes": {
               "email": "stephany@lind.co.uk",
               "created_at": "2014-07-29T03:52:07.432Z",
               "updated_at": "2014-07-29T03:52:07.432Z",
               "auth_token": "Xbnzbf3YkquUrF_1bNkZ"
             }
           }
         }
      }
   ]
}
----

Le problème de cette approche est que nous devons dupliquer les objets `User` pour chaque produits qui appartiennent au même utilisateur:

[source,json]
----
{
  "data":
  [
      {
         "id": 1,
         "type": "product",
         "attributes": {
           "title": "First product",
           "price": "25.02",
           "published": false,
           "user": {
             "id": 2,
             "type": "user",
             "attributes": {
               "email": "stephany@lind.co.uk",
               "created_at": "2014-07-29T03:52:07.432Z",
               "updated_at": "2014-07-29T03:52:07.432Z",
               "auth_token": "Xbnzbf3YkquUrF_1bNkZ"
             }
           }
         }
      },
      {
         "id": 2,
         "type": "product",
         "attributes": {
           "title": "Second product",
           "price": "25.02",
           "published": false,
           "user": {
             "id": 2,
             "type": "user",
             "attributes": {
               "email": "stephany@lind.co.uk",
               "created_at": "2014-07-29T03:52:07.432Z",
               "updated_at": "2014-07-29T03:52:07.432Z",
               "auth_token": "Xbnzbf3YkquUrF_1bNkZ"
             }
           }
         }
      }
   ]
}
----

=== Incorporer les relation dans `include`

La troisième solution, choisie par la norme JSON:API, est un mélange des deux premières.

Nous allons inclure tous les relations dans une clé `include` qui contiendra tous les relations des objets précédemment cité. Aussi, chaque objet inclura une clé `relationships` définissant la relation et qu'il faudra retrouver dans la clé `include`.

Un JSON vaux mile mots:

[source,json]
----
{
  "data":
  [
      {
         "id": 1,
         "type": "product",
         "attributes": {
           "title": "First product",
           "price": "25.02",
           "published": false
         },
         "relationships": {
           "user": {
             "id": 1,
             "type": "user"
           }
         }
      },
      {
         "id": 2,
         "type": "product",
         "attributes": {
           "title": "Second product",
           "price": "25.02",
           "published": false
         },
         "relationships": {
           "user": {
             "id": 1,
             "type": "user"
           }
         }
      }
   ],
   "include": [
     {
       "id": 2,
       "type": "user",
       "attributes": {
         "email": "stephany@lind.co.uk",
         "created_at": "2014-07-29T03:52:07.432Z",
         "updated_at": "2014-07-29T03:52:07.432Z",
         "auth_token": "Xbnzbf3YkquUrF_1bNkZ"
       }
     }
   ]
}
----

Vous voyez la différence? Cette solution réduit drastiquement la taille du JSON et donc la bande passante utilisée.

== Application de l'injection des relations

// CURRENT



Donc, nous allons incorporer l’objet utilisateur dans le produit. Commençons par ajouter quelques tests. Nous allons simplement modifier les tests des routes `Products#index` et `Products#show` .

[source,ruby]
.spec/controllers/api/v1/products_controller_spec.rb
----
# ...
RSpec.describe Api::V1::ProductsController, type: :controller do
  describe 'GET #show' do
    # ...
    it 'has the user as a embedded object' do
      expect(json_response[:user][:email]).to eql @product.user.email
    end
  end

  describe 'GET #index' do
    # ...
    it 'returns the user object into each product' do
      json_response.each do |product_response|
        expect(product_response[:user]).to be_present
      end
    end
  end
  # ...
end
----

L’implémentation est très simple: il suffit d’ajouter une ligne au sérialiseur du produit:

[source,ruby]
.app/serializers/product_serializer.rb
----
class ProductSerializer < ActiveModel::Serializer
  attributes :id, :title, :price, :published
  has_one :user
end
----

Maintenant, tous les tests devraient passer:

[source,bash]
----
$ rspec spec
............................................................

Finished in 0.57068 seconds (files took 0.67788 seconds to load)
60 examples, 0 failures
----

=== Récupérer les produits pour des utilisateurs

Maintenant, vous vous demandez peut-être si vous devriez intégrer les produits dans l’utilisateur (comme dans la section précédente). Même si cela peut sembler bien, cela peut entraîner de graves problèmes d’optimisation. Vous pourriez être en train de charger d’énormes quantités d’informations et il est vraiment facile de tomber dans le problème des *dépendances circulaires* qui boucle le programme jusqu’à épuiser la mémoire.

Mais ne vous inquiétez pas, tout n’est pas perdu, nous pouvons facilement résoudre ce problème en intégrant seulement les identifiants des produits dans l’utilisateur. Cela donnera à votre API une meilleure performance et cela évitera de charger des données supplémentaires. Dans cette section, nous allons donc étendre notre route de l’index des produits pour traiter un paramètre `product_ids` et formater la sortie JSON en conséquence.

Tout d’abord, nous nous assurons que le `product_ids` fait partie de l’objet sérialisé de l’utilisateur:

[source,ruby]
.spec/controllers/api/v1/users_controller_spec.rb
----
# ...
RSpec.describe Api::V1::UsersController, type: :controller do
  describe 'GET #show' do
    # ...
    it 'has the product ids as an embedded object' do
      expect(json_response[:product_ids]).to eql []
    end
  end
  # ...
end
----

L’implémentation est très simple, comme décrit dans https://github.com/rails-api/active_model_serializers/blob/0-10-stable/docs/howto/add_relationship_links.md#links-as-an-attribute-of-a-resource[la documentation] de la gemme `active_model_serializers`:

[source,ruby]
.app/serializers/user_serializer.rb
----
class UserSerializer < ActiveModel::Serializer
  attribute :product_ids do
    object.products.map(&:id)
  end
  # ...
end
----

Nos tests devraient passer:

[source,bash]
----
$ rspec spec/controllers/api/v1/users_controller_spec.rb
..............

Finished in 0.16791 seconds (files took 0.65902 seconds to load)
14 examples, 0 failures
----

Nous devons maintenant étendre l’action `index` depuis le `products_controller` pour qu’il puisse gérer le paramètre `product_ids` et afficher les enregistrements _scopés_. Commençons par ajouter quelques tests:

[source,ruby]
.spec/controllers/api/v1/products_controller_spec.rb
----
# ...
RSpec.describe Api::V1::ProductsController, type: :controller do
  # ...
  describe 'GET #index' do
    before(:each) do
      4.times { FactoryBot.create :product }
      get :index
    end

    context 'when is not receiving any product_ids parameter' do
      before(:each) do
        get :index
      end

      it 'returns 4 records from the database' do
        expect(json_response).to have(4).items
      end

      it 'returns the user object into each product' do
        json_response.each do |product_response|
          expect(product_response[:user]).to be_present
        end
      end

      it { expect(response.response_code).to eq(200) }
    end

    context 'when product_ids parameter is sent' do
      before(:each) do
        @user = FactoryBot.create :user
        3.times { FactoryBot.create :product, user: @user }
        get :index, params: { product_ids: @user.product_ids }
      end

      it 'returns just the products that belong to the user' do
        json_response.each do |product_response|
          expect(product_response[:user][:email]).to eql @user.email
        end
      end
    end
  end
  # ...
end
----

Comme vous pouvez le voir, nous venons d’envelopper l’action index dans deux contextes séparés: l’un qui recevra les `product_ids` et l’autre l’ancien que nous avions écrit. Ajoutons le code nécessaire pour faire passer les tests:

[source,ruby]
.app/controllers/api/v1/products_controller.rb
----
class Api::V1::ProductsController < ApplicationController
  before_action :authenticate_with_token!, only: %i[create update destroy]

  def index
    products = params[:product_ids].present? ? Product.find(params[:product_ids]) : Product.all
    render json: products
  end
  # ...
end
----

Comme vous pouvez le voir l’implémentation est super simple. Nous allons simplement chercher les produits avec le paramètre `product_ids` au cas où ils seraient présents, sinon nous les cherchons tous. Assurons-nous que les tests sont bons:

[source,bash]
----
$ rspec spec/controllers/api/v1/products_controller_spec.rb
..................

Finished in 0.35027 seconds (files took 0.65369 seconds to load)
18 examples, 0 failures
----

_Commitons_ nos changements:

[source,bash]
----
$ git commit -am "Embeds the products_ids into the user serialiser and fetches the correct products from the index action endpoint"
----

== Rechercher les produits

Dans cette dernière section, nous continuerons à renforcer l’action `Products#index` en mettant en place un mécanisme de recherche très simple pour permettre à n’importe quel client de filtrer les résultats. Cette section est facultative car elle n’aura aucun impact sur les modules de l’application. Mais si vous voulez pratiquer davantage avec le TDD, je vous recommande de compléter cette dernière étape.

J’utilise https://github.com/activerecord-hackery/ransack[Ransack] pour construire des formulaires de recherche avancée extrêmement rapidement. Mais ici, comme le but est d'apprendre et que la recherche que nous allons effectuer est très simple, je pense que nous pouvons construire un moteur de recherche à partir de zéro. Nous devons simplement considérer les critères par lesquels nous allons filtrer les attributs. Accrochez-vous bien à vos sièges, ça va être un voyage difficile.

Nous filtrerons donc les produits selon les critères suivants:

* Par titre
* Par prix
* Trier par date de création

Cela peut sembler court et facile, mais croyez-moi, cela vous donnera mal à la tête si vous ne le planifiez pas.

=== Le mot-clé by

Nous allons créer un _scope_ pour trouver les enregistrements qui correspondent à un motif particulier de caractère. Appelons-le `filter_by_title`. Ajoutons d’abord quelques tests:

[source,ruby]
.spec/models/product_spec.rb
----
# ...
RSpec.describe Product, type: :model do
  # ...
  describe '.filter_by_title' do
    before(:each) do
      @product1 = FactoryBot.create :product, title: 'A plasma TV'
      @product2 = FactoryBot.create :product, title: 'Fastest Laptop'
      @product3 = FactoryBot.create :product, title: 'CD player'
      @product4 = FactoryBot.create :product, title: 'LCD TV'
    end

    context "when a 'TV' title pattern is sent" do
      it 'returns the 2 products matching' do
        expect(Product.filter_by_title('TV')).to have(2).items
      end

      it 'returns the products matching' do
        expect(Product.filter_by_title('TV').sort).to match_array([@product1, @product4])
      end
    end
  end
end
----

Le test ici est de s’assurer que quel que soit le cas du titre envoyé, nous devons l’aseptiser afin de faire la comparaison appropriée. Dans notre cas nous utiliserons l’approche en minuscules. Implémentons le code nécessaire:

[source,ruby]
.app/models/product.rb
----
class Product < ApplicationRecord
  # ...
  scope :filter_by_title, lambda { |keyword|
    where('lower(title) LIKE ?', "%#{keyword.downcase}%")
  }
end
----

L’implémentation est suffisante pour que nos tests passent:

[source,bash]
----
$ rspec spec/models/product_spec.rb
...........

Finished in 0.17178 seconds (files took 3.59 seconds to load)
11 examples, 0 failures
----

=== Par prix

Pour filtrer par prix, les choses peuvent devenir un peu plus délicates. Nous allons briser la logique de filtrer par prix en deux méthodes différentes: l’une qui va chercher les produits plus grands que le prix reçu et l’autre qui va chercher ceux qui sont sous ce prix. De cette façon, nous garderons une certaine flexibilité et nous pouvons facilement tester les _scope_.

Commençons par construire les tests du _scope_ `above_or_equal_to_price`:

[source,ruby]
.spec/models/product_spec.rb
----
# ...
RSpec.describe Product, type: :model do
  # ...
  describe '.above_or_equal_to_price' do
    before(:each) do
      @product1 = FactoryBot.create :product, price: 100
      @product2 = FactoryBot.create :product, price: 50
      @product3 = FactoryBot.create :product, price: 150
      @product4 = FactoryBot.create :product, price: 99
    end

    it 'returns the products which are above or equal to the price' do
      expect(Product.above_or_equal_to_price(100).sort).to match_array([@product1, @product3])
    end
  end
end
----

L’implémentation est très très simple:

[source,ruby]
.app/models/product.rb
----
class Product < ApplicationRecord
  # ...
  scope :above_or_equal_to_price, lambda { |price|
    where('price >= ?', price)
  }
end
----

L’implémentation est suffisante pour que nos tests passent:

[source,bash]
----
$ rspec spec/models/product_spec.rb
............

Finished in 0.1566 seconds (files took 0.64782 seconds to load)
12 examples, 0 failures
----

Vous pouvez maintenant imaginer le comportement de la méthode opposée. Voici les tests:

[source,ruby]
.spec/models/product_spec.rb
----
# ...
RSpec.describe Product, type: :model do
  # ...
  describe '.below_or_equal_to_price' do
    before(:each) do
      @product1 = FactoryBot.create :product, price: 100
      @product2 = FactoryBot.create :product, price: 50
      @product3 = FactoryBot.create :product, price: 150
      @product4 = FactoryBot.create :product, price: 99
    end

    it 'returns the products which are above or equal to the price' do
      expect(Product.below_or_equal_to_price(99).sort).to match_array([@product2, @product4])
    end
  end
end
----

Et l’implémentation:

[source,ruby]
.app/models/product.rb
----
class Product < ApplicationRecord
  # ...
  scope :below_or_equal_to_price, lambda { |price|
    where('price <= ?', price)
  }
end
----

Pour notre bien, faisons les tests et vérifions que tout est beau et vert:

[source,bash]
----
$ rspec spec/models/product_spec.rb
.............

Finished in 0.18008 seconds (files took 0.6544 seconds to load)
13 examples, 0 failures
----

Comme vous pouvez le voir, nous n’avons pas eu beaucoup de problèmes. Ajoutons simplement une autre _scope_ pour trier les enregistrements par date de dernière mise à jour. Dans le cas où le propriétaire des produits décide de mettre à jour certaines données il voudra sûrement trier ses produits par date de création.

=== Tri par date de création

Ce _scope_ est très facile. Ajoutons d’abord quelques tests:

[source,ruby]
.spec/models/product_spec.rb
----
# ...
RSpec.describe Product, type: :model do
  # ...
  describe '.recent' do
    before(:each) do
      @product1 = FactoryBot.create :product, price: 100
      @product2 = FactoryBot.create :product, price: 50
      @product3 = FactoryBot.create :product, price: 150
      @product4 = FactoryBot.create :product, price: 99

      # we will touch some products to update them
      @product2.touch
      @product3.touch
    end

    it 'returns the most updated records' do
      expect(Product.recent).to match_array([@product3, @product2, @product4, @product1])
    end
  end
end
----

Et l’implémentation:

[source,ruby]
.app/models/product.rb
----
class Product < ApplicationRecord
  # ...
  scope :recent, lambda {
    order(:updated_at)
  }
end
----

Tous nos tests devraient passer:

[source,bash]
----
$ rspec spec/models/product_spec.rb
.............

Finished in 0.18008 seconds (files took 0.6544 seconds to load)
13 examples, 0 failures
----

_Commitons_ nos changements:

[source,bash]
----
$ git commit -am "Adds search scopes on the product model"
----

=== Moteur de recherche

Maintenant que nous avons la base pour le moteur de recherche que nous utiliserons dans l’application, il est temps de mettre en œuvre une méthode de recherche simple mais puissante. Elle s’occupera de gérer toute la logique pour récupérer les enregistrements des produits.

La méthode consistera à enchaîner tous les `scope` que nous avons construits précédemment et à retourner le résultat. Commençons par ajouter quelques tests:

[source,ruby]
.spec/models/product_spec.rb
----
# ...
RSpec.describe Product, type: :model do
  # ...
  describe '.search' do
    before(:each) do
      @product1 = FactoryBot.create :product, price: 100, title: 'Plasma tv'
      @product2 = FactoryBot.create :product, price: 50, title: 'Videogame console'
      @product3 = FactoryBot.create :product, price: 150, title: 'MP3'
      @product4 = FactoryBot.create :product, price: 99, title: 'Laptop'
    end

    context "when title 'videogame' and '100' a min price are set" do
      it 'returns an empty array' do
        search_hash = { keyword: 'videogame', min_price: 100 }
        expect(Product.search(search_hash)).to be_empty
      end
    end

    context "when title 'tv', '150' as max price, and '50' as min price are set" do
      it 'returns the product1' do
        search_hash = { keyword: 'tv', min_price: 50, max_price: 150 }
        expect(Product.search(search_hash)).to match_array([@product1])
      end
    end

    context 'when an empty hash is sent' do
      it 'returns all the products' do
        expect(Product.search({})).to match_array([@product1, @product2, @product3, @product4])
      end
    end

    context 'when product_ids is present' do
      it 'returns the product from the ids' do
        search_hash = { product_ids: [@product1.id, @product2.id] }
        expect(Product.search(search_hash)).to match_array([@product1, @product2])
      end
    end
  end
end
----

Nous avons ajouté un tas de code mais je vous assure que l’implémentation est très facile. Vous pouvez aller plus loin et ajouter quelques tests supplémentaires mais, dans mon cas, je n’ai pas trouvé cela nécessaire.

[source,ruby]
.app/models/product.rb
----
class Product < ApplicationRecord
  # ...
  def self.search(params = {})
    products = params[:product_ids].present? ? Product.find(params[:product_ids]) : Product.all

    products = products.filter_by_title(params[:keyword]) if params[:keyword]
    products = products.above_or_equal_to_price(params[:min_price].to_f) if params[:min_price]
    products = products.below_or_equal_to_price(params[:max_price].to_f) if params[:max_price]
    products = products.recent(params[:recent]) if params[:recent].present?

    products
  end
end
----

Il est important de noter que nous retournons les produits en tant qu’objet https://api.rubyonrails.org/classes/ActiveRecord/Relation.html:[`ActiveRelation`] afin de pouvoir enchaîner d’autres méthodes en cas de besoin ou les paginer comme nous allons le voir dans les derniers chapitres. Il suffit de mettre à jour l’action `Product#index` pour récupérer les produits à partir de la méthode de recherche:

[source,ruby]
.app/controllers/api/v1/products_controller.rb
----
class Api::V1::ProductsController < ApplicationController
  before_action :authenticate_with_token!, only: %i[create update destroy]

  def index
    render json: Product.search(params)
  end
  # ...
end
----

Nous pouvons exécuter l’ensemble de la suite de tests, pour nous assurer que l’application est en bonne santé jusqu’ici:

[source,bash]
----
$ rspec spec
.......................................................................

Finished in 1.49 seconds (files took 6.53 seconds to load)
71 examples, 0 failures
----

_Commitons_ ces changements:

[source,bash]
----
$ git commit -am "Adds search class method to filter products"
----

== Conclusion

Jusqu’à présent, et grâce à la gemme https://github.com/rails-api/active_model_serializers[active_model_serializers], c’était facile. Sur les chapitres à venir, nous allons commencer à construire le modèle `Order` qui associera les utilisateurs aux produits.
