[#chapter04-athentification]
= Authentification des utilisateurs

Cela fait longtemps que vous avez commencé. J’espère que vous appréciez ce voyage autant que moi.

Dans le chapitre précédent nous avons mis en place des entrée de ressources utilisateur. Si vous avez sauté ce chapitre ou si vous n’avez pas tout compris, je vous recommande vivement de le regarder. Il couvre les premières bases des tests et c’est une introduction aux réponses JSON.

// Au chapitre 4, nous avons factorisé notre suite de tests et, comme nous n’avons pas ajouté beaucoup de code, cela n’a pas pris trop de temps. Si vous avez sauté ce chapitre, je vous recommande de le lire, car nous allons utiliser certaines méthodes dans les chapitres à venir.

Vous pouvez cloner le projet jusqu’ici:

[source,bash]
----
$ git checkout tags/checkpoint_chapter04
----

Dans ce chapitre, les choses vont devenir plus intéressantes. Nous allons mettre en place notre mécanisme d’authentification. À mon avis, ce sera l’un des chapitres les plus intéressants car nous allons introduire beaucoup de nouveaux concepts. A la fin, vous aurez un système d’authentification simple mais puissant. Ne paniquez pas, nous y arriverons.

Commençons par le commencement. Comme d’habitude quand nous démarrons un nouveau chapitre, nous allons créer une nouvelle branche:

[source,bash]
----
$ git checkout -b chapter04
----

== Session sans état

Avant d’aller plus loin, quelque chose doit être clair: *une API ne gère pas les sessions*. Si vous n’avez pas d’expérience dans la création de ce genre d’applications, cela peut paraître un peu fou. Une API doit être sans état. Ce qui signifie par définition qu’il s’agit d’une API qui fournit une réponse après votre demande et qui ne nécessite aucune autre attention. Cela à pour conséquence qu’aucun état antérieur ou futur n’est nécessaire pour que le système fonctionne.

Le processus d’authentification de l’utilisateur via une API est très simple:

. Le client *demande* une ressource de sessions avec les informations d’identification correspondantes (généralement un e-mail et un mot de passe).
. Le serveur *renvoie* la ressource utilisateur avec son jeton d’authentification correspondant.
. Pour chaque page qui nécessite une authentification, le client doit envoyer ce jeton d’authentification.

Dans cette section et la suivante, nous nous concentrerons sur la construction d’un contrôleur de sessions avec ses actions correspondantes. Nous compléterons ensuite le flux de demandes en ajoutant l’accès d’autorisation nécessaire.


=== Présentation de JSON Web Token

Lorsqu'on parle de jeton d'authentification, un standard existe: le JSON Web Token (JWT).

> JWT est un standard ouvert défini dans la RFC 75191. Il permet l'échange sécurisé de jetons (tokens) entre plusieurs parties. - https://fr.wikipedia.org/wiki/JSON_Web_Token[Wikipedia]

Globalement, un jeton JWT est composé de trois parties:

- un en-tête structuré en JSON qui contiendra par exemple la date de validité du jeton.
- un _payload_ structuré en JSON qui peut contenir n'importe quelle données. Dans notre cas, il contiendra l’identifiant de l'utilisateur a titulaire du jeton.
- une signature qui nous permettra de vérifier que le jeton a bien été chiffré par notre application et donc qu'il est valide.

Ces trois parties sont chacune encodées en base64 puis concaténées en utilisant des points (`.`). Ce qui nous donne quelque chose comme ça:

.Un jeton JWT valide
----
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
----

Une fois décodé, ce jeton nous donne les informations suivantes:

.L'en-tête du jeton JWT
[source,json]
----
{ "alg": "HS256", "typ": "JWT" }
----

.Le payload du jeton JWT
[source,json]
----
{ "sub": "1234567890", "name": "John Doe", "iat": 1516239022 }
----


NOTE: Pour plus d'information à propos des jetons JWT je vous invite à consulter https://jwt.io[jwt.io]


=== Mise en place du jeton d’authentification

La norme JWT possède beaucoup d'implémentation dans des langages et des librairies diverses. Bien entendu, il existe une gemme Ruby à ce sujet: https://github.com/jwt/ruby-jwt[ruby-jwt].

Commençons donc par l'installer:

[source,bash]
----
$ bundle add jwt
----

Une fois effectué, il ligne est ajoutée dans votre _Gemfile_:

[source,ruby]
----
gem "jwt", "~> 2.2"
----

La libraire s'utilise très facilement avec `JWT.encode` et `JWT.decode`. Ouvrons un terminal avec `rails console`.

[source,ruby]
----
2.6.3 :001 > token = JWT.encode({message: 'Hello World'}, 'my_secret_key')
2.6.3 :002 > JWT.decode(token, 'my_secret_key')
 => [{"message"=>"Hello World"}, {"alg"=>"HS256"}]
----

Lors de la première ligne nous avons encodé un _payload_ avec la clé secrète _my_secret_key_. Nous obtenons donc un jeton que nous pouvons décoder, tout simplement.


Nous allons maintenant englober toute cette logique dans une classe `JsonWebToken` qui nous permettra d'éviter créer une classe `lib/json_web_token.rb` qui s'occupera d'encoder et de décoder les jeton JWT. Voici donc l'implémentation.


.lib/json_web_token.rb
[source,ruby]
----
class JsonWebToken
  SECRET_KEY = Rails.application.secrets.secret_key_base.to_s

  def self.encode(payload, exp = 24.hours.from_now)
    payload[:exp] = exp.to_i
    JWT.encode(payload, SECRET_KEY)
  end

  def self.decode(token)
    decoded = JWT.decode(token, SECRET_KEY).first
    HashWithIndifferentAccess.new decoded
  end
end
----

"Hé, ça fait beaucoup plus de code que dans ton exemple!", je sais, mais nous allons le revoir ensemble.

- la méthode `JsonWebToken.encode` va s'occuper d'encoder le _payload_ en rajoutant une expiration à 24 heures par défaut. Nous utilisaons aussi la même clé de chiffrement que celle configurée avec Rails
- la méthode `JsonWebToken.decode` va décoder le jeton JWT et récupérer le _payload_. Nous utilisons ensuite la classe https://api.rubyonrails.org/classes/ActiveSupport/HashWithIndifferentAccess.html[`HashWithIndifferentAccess`] fournie par Rails qui permet de récupérer une valeur d'un `Hash` avec un `Symbol` ou un `String`.


Et voilà. Afin de charger le fichier dans notre application, il faut spécifier le dossier `lib` dans la liste des _autoload_ de Ruby on Rails. Pour cela, rajoutez la configuration suivante dans le fichier `application.rb`:


.lib/json_web_token.rb
[source,ruby]
----
# ...
module MarketPlaceApi
  class Application < Rails::Application
    # ...
    config.autoload_paths << Rails.root.join('lib')
  end
end
----

Et voilà. Il est temps de faire un _commit_.

[source,bash]
----
$ git add . && git commit -m "Setup JWT gem"
----




=== Le contrôleur de jeton

Nous avons donc mis en place le système de génération d'un jeton JWT. Il est maintenant temps de créer une route qui générer un jeton JWT.

Les actions que nous allons implémenter seront gérées en tant que services _RESTful_: la connexion sera gérée par une demande POST à l’action `create`.

// et la déconnexion par une demande `DELETE` à l’action `destroy`.

Pour commencer, nous allons commencer par créer le contrôleur de et la méthode `create` dans le _namespace_ `/api/v1`. Avec Rails, une comande suffit:

[source,bash]
----
$ rails generate controller api::v1::tokens create
----

Nous allons modifier un peu la route afin de respecter les conventions _REST_:

.config/routes.rb
[source,ruby]
----
Rails.application.routes.draw do
  namespace :api, defaults: { format: :json } do
    namespace :v1 do
      # ...
      resources :tokens, only: [:create]
    end
  end
end
----

Avant d'aller plus loin, nous allons mettre les tests fonctionnel. Les tests sont: si j'envoie un couple courriel / mot de passe valide, je reçois un jeton, sinon j'ai une réponse de type `forbidden`. Le test se matérialise donc comme ceci:

.test/controllers/api/v1/tokens_controller_test.rb
[source,ruby]
----
require 'test_helper'

class Api::V1::TokensControllerTest < ActionDispatch::IntegrationTest
  setup do
    @user = users(:one)
  end

  test 'should get JWT token' do
    post api_v1_tokens_url, params: { user: { email: @user.email, password: 'g00d_pa$$' } }, as: :json
    assert_response :success

    json_response = JSON.parse(response.body)
    assert_not_nil json_response['token']
  end

  test 'should not get JWT token' do
    post api_v1_tokens_url, params: { user: { email: @user.email, password: 'b@d_pa$$' } }, as: :json
    assert_response :unauthorized
  end
end
----

Vous vous demandez sûrmenent: "mais comment peux tu connaitre le mot de passe de l'utilisateur?". Il suffit tout simplement d'utiliser la méthode `BCrypt::Password.create` dans les _fixtures_ des utilisateurs:

.test/fixtures/users.yml
[source,yaml]
----
one:
  email: one@one.org
  password_digest: <%= BCrypt::Password.create('g00d_pa$$') %>
----

A ce moment précis, si vous lancez les test vous obtenez deux erreurs:

----
$ rake test

# Running:

........E

Error:
Api::V1::TokensControllerTest#test_should_get_JWT_token:
JSON::ParserError: 767: unexpected token at ''


Failure:
Expected response to be a <401: unauthorized>, but was a <204: No Content>

Finished in 0.199738s, 55.0721 runs/s, 75.0983 assertions/s.
11 runs, 15 assertions, 1 failures, 1 errors, 0 skips
----

C'est normal. Il est maintenant temps d'implémenter la logique pour créer le jeton JWT. Elle est très simple.


.config/routes.rb
[source,ruby]
----
class Api::V1::TokensController < ApplicationController
  def create
    @user = User.find_by_email(user_params[:email])
    if @user&.authenticate(user_params[:password])
      render json: {
        token: JsonWebToken.encode(user_id: @user.id),
        email: @user.email
      }
    else
      head :unauthorized
    end
  end

  private

  # Only allow a trusted parameter "white list" through.
  def user_params
    params.require(:user).permit(:email, :password)
  end
end
----

// CURRENT



== Utilisateur connecté

Si vous avez déjà travaillé avec https://github.com/plataformatec/devise[devise], vous connaissez sûrement déjà les méthodes générées pour gérer l’authentification ou bien pour obtenir l’utilisateur connecté (voir la https://github.com/plataformatec/devise#getting-started[documentation]).

Dans notre cas, nous allons remplacer la méthode `current_user` pour répondre à nos besoins. C’est-à-dire retrouver l’utilisateur grâce à son jeton d’authentification qui est envoyé sur chaque requête. Laissez moi clarifier ce point.

Une fois que le client se connecte, l’API lui retourne son jeton d’authentification. A chaque fois que ce client demande une page protégée, nous devrons retrouver l’utilisateur à partir de ce jeton d’authentification que l’utilisateur aura passé en paramètre ou dans l’en-tête HTTP.

Dans notre cas, nous utiliserons l’en-tête HTTP `Authorization` qui est souvent utilisé pour ça. Personnellement, je le trouve que c’est la meilleure manière parce que cela donne un contexte à la requête sans polluer l’URL avec des paramètres supplémentaires.

Quand il s’agit de l’authentification, j’aime ajouter toutes les méthodes associées dans un fichier séparé. Il suffit ensuite d’inclure le fichier dans le `ApplicationController`. De cette façon, il est très facile à tester de manière isolée. Créons-donc le fichier dans le répertoire `controllers/concerns`:

[source,bash]
----
$ touch app/controllers/concerns/authenticable.rb
----

Ensuite, créons un répertoire `concerns` sous `spec/controllers/` et un fichier `authenticable_spec.rb` pour nos tests d’authentification:

[source,bash]
----
$ mkdir spec/controllers/concerns
$ touch spec/controllers/concerns/authenticable_spec.rb
----

Comme d’habitude, nous commençons par écrire nos tests. Dans ce cas, notre méthode `current_user` va chercher un utilisateur par le jeton d’authentification dans l’en-tête HTTP `Authorization`.

[source,ruby]
.spec/controllers/concerns/authenticable_spec.rb
----
# ...
class Authentication < ActionController::API
  include Authenticable
end

RSpec.describe Authenticable do
  let(:authentication) { Authentication.new }
  subject { authentication }

  describe "#current_user" do
    before do
      @user = FactoryBot.create :user
      request.headers["Authorization"] = @user.auth_token
      authentication.stub(:request).and_return(request)
    end
    it "returns the user from the authorization header" do
      expect(authentication.current_user.auth_token).to eql @user.auth_token
    end
  end
end
----

Notre test doivent échouer. Implémentons donc le code pour qu’il passe:

[source,ruby]
.app/controllers/concerns/authenticable.rb
----
module Authenticable
  # Devise methods overwrites
  def current_user
    @current_user ||= User.find_by(auth_token: request.headers['Authorization'])
  end
end
----

Maintenant notre test devrait passer:

[source,bash]
----
$ rspec spec/controllers/concerns/authenticable_spec.rb
.

Finished in 0.0149 seconds (files took 0.49496 seconds to load)
1 example, 0 failures
----

Nous n’avons plus qu’à inclure le module `Authenticable` dans la classe `ApplicationController`:

[source,ruby]
.app/controllers/application_controller.rb
----
class ApplicationController < ActionController::API
  # ...
  include Authenticable
end
----

Et maintenant il est temps de _commiter_ nos changements:

[source,bash]
----
$ git add .
$ git commit -m "Adds authenticable module for managing authentication methods"
----

== Authentification avec le jeton

L’autorisation joue un rôle important dans la construction des applications car, contrairement à l’authentification qui permet d’identifier l’utilisateur, l’autorisation nous aide à définir ce qu’il a le droit de faire.

Nous avons une route pour mettre à jour l’utilisateur mais il y a un problème: n’importe qui peut mettre à jour n’importe quel utilisateur. Dans cette section, nous allons mettre en œuvre une méthode qui exigera que l’utilisateur soit connecté afin d’empêcher tout accès non autorisé. Nous retournerons un message d’erreur JSON avec un code HTTP correspondant.

Tout d’abord, nous allons ajouter quelques tests sur le fichier `authenticable_spec.rb` pour la méthode `authenticate_with_token` .

[source,ruby]
.spec/controllers/concerns/authenticable_spec.rb
----
# ...
class Authentication < ActionController::API
  include Authenticable
end

RSpec.describe Authenticable do
  # ...
  describe '#authenticate_with_token' do
    before do
      @user = FactoryBot.create :user
      authentication.stub(:current_user).and_return(nil)
      response.stub(:response_code).and_return(401)
      response.stub(:body).and_return({ 'errors' => 'Not authenticated' }.to_json)
      authentication.stub(:response).and_return(response)
    end

    it 'render a json error message' do
      expect(json_response[:errors]).to eql 'Not authenticated'
    end

    it { expect(response.response_code).to eq(401) }
  end
end
----

Comme vous pouvez le voir, nous utilisons à nouveau la classe Authentification et nous écrasons la requête et la réponse pour traiter la réponse attendue du serveur. Il est maintenant temps d’implémenter le code pour faire passer nos tests.

[source,ruby]
.app/controllers/concerns/authenticable.rb
----
module Authenticable
  # ...
  def authenticate_with_token!
    unless current_user.present?
      render json: { errors: 'Not authenticated' },
             status: :unauthorized
    end
  end
end
----

A ce stade, nous venons de construire un mécanisme d’autorisation très simple pour empêcher les utilisateurs non signés d’accéder à l’API. Il suffit de mettre à jour le fichier `users\_controller.rb` avec la méthode `current_user` et d’empêcher l’accès avec la commande `authenticate_with_token!`!

_Commitons_ ces changements et continuons d’avancer:

[source,bash]
----
$ git commit -m "Adds the authenticate with token method to handle access to actions"
----

== Autoriser les actions

Il est maintenant temps de mettre à jour notre fichier `users_controller.rb` pour refuser l’accès à certaines actions. Nous allons aussi implémenter la méthode `current_user` sur l’action `update` et `destroy` afin de s’assurer que l’utilisateur qui est connecté ne sera capable de mettre à jour que ses données et qu’il ne pourra supprimer que (et uniquement) son compte.

Nous allons commencer par l’action `update`. Nous n’irons plus chercher l’utilisateur par son identifiant mais par l’ `auth_token` sur l’en-tête `Authorization` fourni par la méthode `current_user`.

[source,ruby]
----
# app/controllers/api/v1/users_controller.rb
class Api::V1::UsersController < ApplicationController
  # ...
  def update
    # on change juste la methode ici
    user = current_user

    if user.update(user_params)
      render json: user, status: 200, location: [:api, user]
    else
      render json: { errors: user.errors }, status: 422
    end
  end
  # ...
end
----

Et comme vous pouvez vous y attendre, si nous exécutons les tests de notre _controller_ utilisateurs, ils devraient échouer:

....
$ rspec spec/controllers/api/v1/users_controller_spec.rb
.......FFFFF.

Failures:

  1) Api::V1::UsersController PUT/PATCH #update when is successfully updated renders the json representation for the updated user
     Failure/Error: if user.update(user_params)

     NoMethodError:
       undefined method 'update' for nil:NilClass
   ...
....

La solution est assez simple, il suffit d’ajouter l’en-tête `Authorization` à la requête:

[source,ruby]
.spec/controllers/api/v1/users_controller_spec.rb
----
# ...
RSpec.describe Api::V1::UsersController, type: :controller do
  # ...
  describe 'PUT/PATCH #update' do
    context 'when is successfully updated' do
      before(:each) do
        @user = FactoryBot.create :user
        request.headers['Authorization'] = @user.auth_token
        patch :update, params: { id: @user.id, user: { email: 'newmail@example.com' } }, format: :json
      end
      # ...
    end

    context 'when is not created' do
      before(:each) do
        @user = FactoryBot.create :user
        request.headers['Authorization'] = @user.auth_token
        patch :update, params: { id: @user.id, user: { email: 'bademail.com' } }, format: :json
      end
      # ...
    end
  end
  # ...
end
----

Maintenant, les tests devraient passer. Mais attendez, quelque chose ne va pas, n’est-ce pas? Nous pouvons factoriser la ligne que nous venons d’ajouter et la mettre dans le module `HeadersHelpers`:

[source,ruby]
.spec/support/request_helpers.rb
----
module Request
  # ...
  module HeadersHelpers
    # ...
    def api_authorization_header(token)
      request.headers['Authorization'] = token
    end
  end
end
----

Maintenant, chaque fois que nous avons besoin d’avoir l’utilisateur courant sur nos tests, nous appelons simplement la méthode `api_authorization_header`. Je vous laisse le faire avec `users_controller_spec.rb` pour le test de mise à jour ?:

[source,ruby]
.spec/controllers/api/v1/users_controller_spec.rb
----
# ...
RSpec.describe Api::V1::UsersController, type: :controller do
  # ...
  describe 'PUT/PATCH #update' do
    context 'when is successfully updated' do
      before(:each) do
        @user = FactoryBot.create :user
        api_authorization_header @user.auth_token
        patch :update, params: { id: @user.id, user: { email: 'newmail@example.com' } }, format: :json
      end
      # ...
    end

    context 'when is not created' do
      before(:each) do
        @user = FactoryBot.create :user
        api_authorization_header @user.auth_token
        patch :update, params: { id: @user.id, user: { email: 'bademail.com' } }, format: :json
      end
      # ...
    end
  end
  # ...
end
----

Pour l’action `destroy`, nous ferons la même chose car nous devons juste nous assurer qu’un utilisateur est capable de se supprimer:

[source,ruby]
.app/controllers/api/v1/users_controller.rb
----
class Api::V1::UsersController < ApplicationController
  # ...
  def destroy
    current_user.destroy
    head 204
  end
  # ...
end
----

Maintenant, pour le fichier de spécification, et comme mentionné précédemment, nous avons juste besoin d’ajouter l’en-tête `api_authorization_header`:

[source,ruby]
.spec/controllers/api/v1/users_controller_spec.rb
----
# ...
RSpec.describe Api::V1::UsersController, type: :controller do
  # ...
  describe 'DELETE #destroy' do
    before(:each) do
      @user = FactoryBot.create :user
      api_authorization_header @user.auth_token
      delete :destroy, params: { id: @user.id }
    end

    it { expect(response.response_code).to eq(204) }
  end
end
----

Tous nos tests devraient passer. La dernière étape de cette section consiste à ajouter les droits d’accès correspondants pour ces deux dernières actions.

Il est courant de simplement empêcher les actions sur lesquelles l’utilisateur effectue des actions sur le modèle lui-même. Dans ce cas l’action `update` et `destroy`.

Sur le `users_controller.rb` nous devons filtrer certaines de ces actions pour empêcher l’accès.

[source,ruby]
.app/controllers/api/v1/users_controller.rb
----
class Api::V1::UsersController < ApplicationController
  before_action :authenticate_with_token!, only: %i[update destroy]
  respond_to :json
  # ...
end
----

Nos tests devraient être encore bons. Et à partir de maintenant, chaque fois que nous voulons éviter qu’une action ne soit déclenchée, nous ajoutons simplement la méthode `authenticate_with_token!` sur un _hook_ `before_action`.

_Commitons_ tout ça:

[source,bash]
----
$ git add .
$ git commit -m "Adds authorization for the users controller"
----

Enfin, nous terminerons le chapitre en remaniant la méthode `authenticate_with_token!`, C’est une petite amélioration mais cela rendra la méthode plus parlante. Vous comprendrez ce que je veux dire dans une minute, mais avant tout, ajoutons quelques tests.

[source,ruby]
.spec/controllers/concerns/authenticable_spec.rb
----
# ...
RSpec.describe Authenticable do
  # ...
  describe '#user_signed_in?' do
    context "when there is a user on 'session'" do
      before do
        @user = FactoryBot.create :user
        authentication.stub(:current_user).and_return(@user)
      end

      it { should be_user_signed_in }
    end

    context "when there is no user on 'session'" do
      before do
        @user = FactoryBot.create :user
        authentication.stub(:current_user).and_return(nil)
      end

      it { should_not be_user_signed_in }
    end
  end
end
----

Comme vous pouvez le voir, nous avons ajouté deux simples tests pour savoir si l’utilisateur est connecté ou non. Et comme je l’ai déjà dit, c’est juste pour la clarté visuelle. Mais continuons et ajoutons l’implémentation:

[source,ruby]
.app/controllers/concerns/authenticable.rb
----
module Authenticable
  # ...
  def authenticate_with_token!
    unless user_signed_in?
      render json: { errors: 'Not authenticated' }, status: :unauthorized
    end
  end

  def user_signed_in?
    current_user.present?
  end
end
----

Comme vous pouvez le voir, maintenant `authenticate_with_token!` est plus facile à lire non seulement pour vous mais aussi pour les autres développeurs qui rejoigneront le projet. Cette approche a également un avantage secondaire: si vous voulez modifier ou améliorer la façon de valider, vous pouvez simplement le faire sur la méthode `user_signed_in?`.

Maintenant, nos tests devraient être tous verts:

[source,bash]
----
$ rspec spec/controllers/concerns/authenticable_spec.rb
.....

Finished in 0.07415 seconds (files took 0.702 seconds to load)
5 examples, 0 failures
----

_Commitons_ tout ça:

[source,bash]
----
$ git add .
$ git commit -m "Adds user_signed_in? method to know whether the user is logged in or not"
----

== Conclusion

Vous l’avez fait! Vous êtes à mi-chemin! Ce chapitre a été long et difficile, mais c’est un grand pas en avant sur la mise en place d’un mécanisme solide pour gérer l’authentification utilisateur et nous grattons même la surface pour de simples règles d’autorisation.

Dans le prochain chapitre, nous nous concentrerons sur la personnalisation de la sortie JSON pour l’utilisateur avec `active_model_serializers` et l’ajout d’un modèle de produit en donnant à l’utilisateur la possibilité de créer un produit et le publier pour la vente.
